<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>面试准备 | 温泉</title><meta name="keywords" content="Spring"><meta name="author" content="温泉"><meta name="copyright" content="温泉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="实习项目做了哪些算法？ 节假日假冒客一、大件运输车逃费、假冒免费车辆、有入无出、跨省屏蔽通行介质 介绍下实习中遇到的困难？ 有入无出 a) 根据3天范围数据进行检索(3天内的入口数据，3天范围内的出数据表，门架表，牌识表).b) 没有与入口数据对应的出口数据.对应上的条件为(车牌+入口时间相同)或(卡号+入口时间相同)或(站点+入口时间相同)或（出口流水中为无通行介质且出入口时间相同，则使用入口车">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备">
<meta property="og:url" content="http://ppnostalgia.github.io./c5576490.html">
<meta property="og:site_name" content="温泉">
<meta property="og:description" content="实习项目做了哪些算法？ 节假日假冒客一、大件运输车逃费、假冒免费车辆、有入无出、跨省屏蔽通行介质 介绍下实习中遇到的困难？ 有入无出 a) 根据3天范围数据进行检索(3天内的入口数据，3天范围内的出数据表，门架表，牌识表).b) 没有与入口数据对应的出口数据.对应上的条件为(车牌+入口时间相同)或(卡号+入口时间相同)或(站点+入口时间相同)或（出口流水中为无通行介质且出入口时间相同，则使用入口车">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200713_4526251967369630_5.jpg">
<meta property="article:published_time" content="2022-08-26T07:55:34.000Z">
<meta property="article:modified_time" content="2022-11-04T06:23:11.315Z">
<meta property="article:author" content="温泉">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200713_4526251967369630_5.jpg"><link rel="shortcut icon" href="/img/bitbug_favicon.ico"><link rel="canonical" href="http://ppnostalgia.github.io./c5576490"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index_ori.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4acf95f558e1933f1d46fbf0e26e25a1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-40VH67TNSM"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-40VH67TNSM');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"E3RMSV6NOB","apiKey":"799a9b701a8200953a57527637eaa2eb","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 温泉","link":"链接: ","source":"来源: 温泉","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试准备',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-04 14:23:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/nav/nav_menu.css"><link rel="stylesheet" href="/css/archive/archive.css"><script src="https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js"></script><link rel="stylesheet" href="//at.alicdn.com/t/font_3022232_oy5w40isw6a.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="温泉" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/configuration/avatar01.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw far fa-newspaper"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-globe-asia"></i><span> 统计</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/article_statistical/"><i class="fa-fw iconfont icon-wenzhangtongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/blog_statistical/"><i class="fa-fw iconfont icon-yujingtongji"></i><span> 博客统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-magic"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa fa-compass"></i><span> 导航</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.luckyshrek.top"><i class="fa-fw fas fa-meteor"></i><span> 收藏夹</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 本站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa fa-address-card"></i><span> 关于本站</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><div class="back-home-button" tabindex="-1"><i class="back-home-button-icon fas fa-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="/" title="前往博客主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/05/6315ec9737ac4.png"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" href="https://www.cloud.anzhiy.cn/" rel="external nofollow" title="前往云盘主页" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/15/63232b7d91d22.jpg"/><span class="back-menu-item-text">云盘主页</span></a><a class="back-menu-item" href="https://cloud.anzhiy.cn/" rel="external nofollow" title="前往安知鱼云盘" target="_blank" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/04/27/6268e7d9de532.png"/><span class="back-menu-item-text">安知鱼云盘</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" href="http://1.15.238.92:5700/login" title="前往青龙面板" target="_blank" rel="noopener nofollow" one-link-mark="yes"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/15/6322cd942dbd9.png"/><span class="back-menu-item-text">青龙面板</span></a></div></div></div></div><a id="site-name" href="/"><div class="title">温泉</div><i class="fa-solid fa-house"></i></a></span><div class="mask-name-container"><center id="name-container"><a id="page-name" href="javascript:btf.scrollToDest(0, 500)">PAGE_NAME</a></center></div><div id="menus"><div class="nav-button" id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> search.title</span></a></div><div class="nav-button" id="darkmode_navswitch"><a class="darkmode_switchbutton" type="button" title="浅色和深色模式转换" onclick="document.getElementById('darkmode').click()"><i class="fas fa-adjust"></i></a></div><div class="nav-button" id="nav-totop"><a class="totopbtn"><i class="fas fa-arrow-up"></i><span id="percent" onclick="btf.scrollToDest(0,500)">0</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa-fw far fa-newspaper"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-globe-asia"></i><span> 统计</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/article_statistical/"><i class="fa-fw iconfont icon-wenzhangtongji"></i><span> 文章统计</span></a></li><li><a class="site-page child" href="/blog_statistical/"><i class="fa-fw iconfont icon-yujingtongji"></i><span> 博客统计</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-magic"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/photo/"><i class="fa-fw fas fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa fa-compass"></i><span> 导航</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://nav.luckyshrek.top"><i class="fa-fw fas fa-meteor"></i><span> 收藏夹</span></a></li><li><a class="site-page child" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 本站</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa fa-address-card"></i><span> 关于本站</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">面试准备<a class="post-edit-link" href="https://github.com/PPnostalgia/blog-source/tree/master/source/_posts/项目面试准备.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-26T07:55:34.000Z" title="发表于 2022-08-26 15:55:34">2022-08-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-04T06:23:11.315Z" title="更新于 2022-11-04 14:23:11">2022-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Web%E5%BC%80%E5%8F%91/">Web开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">34.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>110分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试准备"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a>实习项目</h1><p><strong>做了哪些算法？</strong></p>
<p>节假日假冒客一、大件运输车逃费、假冒免费车辆、有入无出、跨省屏蔽通行介质</p>
<p><strong>介绍下实习中遇到的困难？</strong></p>
<p><strong>有入无出</strong></p>
<p>a) 根据3天范围数据进行检索(3天内的入口数据，3天范围内的出数据表，门架表，牌识表).<br>b) <strong>没有与入口数据对应的出口数据</strong>.对应上的条件为(车牌+入口时间相同)或(卡号+入口时间相同)或(站点+入口时间相同)或（出口流水中为无通行介质且出入口时间相同，则使用入口车牌+入口站相同且入口时间&lt;出口时间）<br>c）根据相邻的入口数据入口时间取轨迹检索截断时间？？？。<br>d) 符合上述,在上述时间范围内检索门架数据。要求： 门架轨迹长度&gt;15,结尾不是承载门架或省界门架。<br>e）同上规则检索牌识轨迹：牌识轨迹长度&gt;15,,结尾不是承载门架或省界门架。<br>f)符合上述：输出</p>
<p><strong>跨省屏蔽通行介质</strong></p>
<p>高速公路有一种逃费方法是<strong>跨省屏蔽通行介质</strong>的，这种类型的车是全程屏蔽etc的，它在出入口中均没有记录，难点就是可用数据太少，唯一提供鉴别性的门架牌识信息，写了一种算法</p>
<p>在入口表和出口表中，均没有该车的记录，在门架表中，也没有该车的记录。但是在牌识表中，能找到该车的记录，且从牌识表中，能看到该车经过省界门架进入和离开</p>
<p>1.查询单位时间内(现在是使用 1天 为单位)的牌识数据.vehiclePlate.截取车牌号,以 出口数据表.exVehicleId.截取车牌号 和 入口数据表.vehicleId.截取车牌 作为查询条件,过滤掉能找到对应记录的,保留找不到的.（可改为出入口流水的passID进行比较）<br>2.对剩余牌识数据,按牌识数据.vehiclePlate进行分组,合并轨迹,按时间升序排序.删除数据长度小于10的.<br>3.分组合并后的牌识轨迹,若首/尾门架都是省界门架,则保留否则删除.<br>4.剩余的轨迹,若首-尾时间范围内在 门架表 中按”vehicleplate.截取车牌号(无颜色约束)”查询不到,则输出<br>逃费金额计算：修复门架金额。</p>
<p><strong>实习收获</strong></p>
<p>数据库sql优化经验</p>
<ol>
<li>索引字段不要太长，否则会导致索引节点可以存储的key变少，B+数高度增加，增大io次数，减慢查询效率</li>
<li>尽量使用join代替子查询，因为子查询是临时表没有索引</li>
<li>尽量避免使用函数对列进行转换和计算</li>
</ol>
<p>20%</p>
<h1 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h1><p>不熟悉的一些问题</p>
<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><ol>
<li><p>10亿条数据，如何找到出现频率最高Top100</p>
<p>分治+Trie树/hash+小顶堆（就是上面提到的最小堆），即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树或者Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数（小顶堆的话会每次弹出K个中最小的元素），最后在所有top K中求出最终的top K。</p>
</li>
<li><p>如何保证三个线程<strong>顺序执行</strong>？</p>
<ol>
<li>使用reentrantlock，底层有个线程等待队列，可以通过condition方法</li>
<li>使用<strong>countdownlatch</strong>减数器，定义一个（几个线程n-1个这个）countdownlatch（1），a线程执行完调用减数器的countdown方法减一，若为0，唤醒其他处于同步队列中的线程，其他线程为await  例子：A countDown(AB) -1, B await  (AB 0)唤醒 countDown(BC) -1 C   await(BC  0)</li>
<li>jdk1.8中的CompletableFuture对象方法</li>
<li>semaphore信号量（0） A 执行完，调用release方法信号量+1，B调用acquire方法-1，执行完，释放+1，C-1</li>
</ol>
</li>
<li><p>大文件去重：8G内存，50G的文件，如何去重</p>
<ol>
<li>先将50G的数据分别做hash%1000，分成1000个文件，理论上hash做得好那么这1000个文件的大小是差不多接近的。如果有重复，那么<strong>A和B的重复数据一定在相对同一个文件内</strong>，因为hash结果是一样的。将1000个文件分别加载进来，<strong>一一比对是否有hash重复</strong>。这种想法是先把所有数据按照相关性进行分组，相关的数据会处于同样或者接近的位置中，再将小文件进行对比。</li>
</ol>
</li>
<li><p>十万个数，找最频繁的数</p>
<ol>
<li><p>常规思路：map，key：数  value：出现次数。取出value数组，排序，找到key对应的value等于最大出现次数的</p>
</li>
<li><p>小顶堆（一般我们直接用优先队列实现堆：）: 维护一个k大小的小顶堆，若大小大于k，弹出顶部元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;o1.getValue()-o2.getValue());</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:entries)&#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span>(queue.size()&gt;k)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            result[i]=queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>可视化工具：sourcetree</p>
<ol>
<li><p>git <strong>remote</strong> add origin 。。。</p>
</li>
<li><p>git push origin master</p>
</li>
<li><p>git checkout -b test 创建并切换分支 </p>
</li>
<li><p>git merge test 将当前分支与test分支合并  git rebase master test 把master分支合并到test分支，（这一步的场景就可以类比为我们在自己的分支feature上开发了一段时间了，准备从主干master上拉一下最新改动）</p>
<p>当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到<strong>基分支的最新提交的后面</strong>。不建议使用，容易篡改历史</p>
<p>git merge只需要解决一次冲突  git rebase需要解决多次冲突</p>
</li>
</ol>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ol>
<li>docker ps</li>
<li>docker image ls 查看所有已下载镜像</li>
<li>docker container ls 查看所有容器</li>
<li>docker build -t hello</li>
</ol>
<p>​    怎么打包docker镜像？</p>
<pre><code> 1. 准备jar包
 2. 编写dockerfile文件
 3. 编译镜像包 docker build -t hello
 4. docker run 
</code></pre><p>​    docker exec -it container id/names /bin/bash</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><strong>常用命令</strong></p>
<ol>
<li><p>查看端口： lsof -i </p>
</li>
<li><p>创建文件：touch a.txt  vi a.txt</p>
</li>
<li><p>远程拷贝文件： scp -r 用户名@ip地址：文件路径  目录</p>
</li>
<li>cat/tail 查看文件</li>
<li>tar -zcvf xxx 压缩  tar -xvf 解压</li>
<li>r4w2x1  所有者 所在组 其他用户  chmod 777 test.txt</li>
<li>ps -ef 查看正在运行的进程  ps -ef | grep redis</li>
<li>网卡信息 ipconfig  </li>
<li><strong>netstat -an</strong>  查看端口使用情况</li>
<li>pwd 查看当前位置</li>
<li><strong>查找文件</strong>  <strong>find /home -name “*.txt”</strong>  find . 当前目录下所有文件和文件夹</li>
<li>查看一个进程的内存  top -p xxx  或者ps -ef | grep kafka</li>
</ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>稳定性：待排序的序列中有两元素相等,排序之后它们的<strong>先后顺序</strong>不变</p>
<p>时间复杂度：“以nlog2n的速度<strong>快些归队</strong>”，其中快指<strong>快速排序</strong>，些指<strong>希尔排序</strong>，归指<strong>归并排序</strong>，队指<strong>堆排序</strong>。<br>初始有序的情况下，直接插入排序和冒泡排序的时间复杂度为O(n)，简记为“容易插”和“冒得好”<br>算法稳定性：“情绪<strong>不稳定</strong>，<strong>快些选一堆</strong>零食解压吧”，其中快指<strong>快速排序</strong>，些指希尔排序，选指<strong>简单选择排序</strong>，堆指<strong>堆排序</strong>，这四种排序方式是不稳定的。</p>
<p><strong>冒泡排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Set a flag, if true, that means the loop has not been swapped,</span></span><br><span class="line">        <span class="comment">// that is, the sequence has been ordered, the sorting has been completed.</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li>
<li><strong>空间复杂度</strong> ：O(1)</li>
</ul>
<p><strong>归并排序思想</strong></p>
<p>采用分治法，先使每个子序列有序，再使子序列段间有序</p>
<p>步骤：</p>
<p>将序列中待排序数字分为若干组，每个数字分为一组。然后将若干组两两合并，保证合并的组都是有序的。重复上一步的操作，直到剩下最后一组即为有序数列。</p>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>
<li><strong>空间复杂度</strong> ：O(n)</li>
</ul>
<p>为什么最坏为nlogn?</p>
<p><strong>这是因为无论是最坏情况还是平均情况，合并排序只是在每个阶段将数组分成两半，这给它 lg(n) 分量，而另一个 N 分量来自它在每个阶段进行的比较.因此，将其组合起来几乎是 O(nlg n)。无论是平均情况还是最坏情况，lg(n) 因子始终存在。剩余 N 因子取决于在两种情况下进行的比较所进行的比较。现在最坏的情况是在每个阶段对 N 个输入进行 N 次比较。所以它变成了 O(nlg n)。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] arr_1 = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">int</span>[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(arr_1), mergeSort(arr_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Merge two sorted arrays</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr_1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr_2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> sorted_arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] arr_1, <span class="keyword">int</span>[] arr_2) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] sorted_arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr_1.length + arr_2.length];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, idx_1 = <span class="number">0</span>, idx_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx_1 &lt; arr_1.length &amp;&amp; idx_2 &lt; arr_2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr_1[idx_1] &lt; arr_2[idx_2]) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_1[idx_1];</span><br><span class="line">            idx_1 += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sorted_arr[idx] = arr_2[idx_2];</span><br><span class="line">            idx_2 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx_1 &lt; arr_1.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx_1 &lt; arr_1.length) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_1[idx_1];</span><br><span class="line">            idx_1 += <span class="number">1</span>;</span><br><span class="line">            idx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx_2 &lt; arr_2.length) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_2[idx_2];</span><br><span class="line">            idx_2 += <span class="number">1</span>;</span><br><span class="line">            idx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序思想</p>
<p>​        通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p>
<p>​        步骤：</p>
<pre><code>        1. 从序列中**随机**挑出一个元素，做为 “基准”(`pivot`)；
        1. 重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
        1. 递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。
</code></pre><p>​    算法分析</p>
<ul>
<li><strong>稳定性</strong> ：不稳定 不稳定发生在中枢元素和a[j] 交换的时刻。</li>
<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(n^2)，平均：O(nlogn)</li>
<li><strong>空间复杂度</strong> ：O(nlogn)</li>
</ul>
<p>​        最差情况：划分不平衡，每次选取的主元素为最大或最小元素</p>
<p>​        解决：选取随机化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> leftBound,<span class="keyword">int</span> rightBound)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(leftBound &gt;= rightBound) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> mid= partition(arr, leftBound, rightBound); <span class="comment">//得到轴的位置</span></span><br><span class="line">		sort(arr, leftBound, mid-<span class="number">1</span>); <span class="comment">//左边排序</span></span><br><span class="line">		sort(arr, mid+<span class="number">1</span>, rightBound); <span class="comment">//右边排序</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> leftBound,<span class="keyword">int</span> rightBound)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pivot = arr[rightBound]; <span class="comment">//指定数组最右边的数是用来比较的值 轴</span></span><br><span class="line">		<span class="keyword">int</span> left = leftBound;</span><br><span class="line">		<span class="keyword">int</span> right = rightBound - <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">			<span class="keyword">while</span>(left &lt;= right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line">			<span class="keyword">while</span>(left &lt;= right &amp;&amp; arr[right] &gt; pivot) right--;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">				<span class="comment">//如果 左边的数比右边的数小  两个数交换</span></span><br><span class="line">				swap(arr, left, right);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把left最后一次指向的位置与pivot（轴）的位置交换</span></span><br><span class="line">		swap(arr, left, rightBound);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> left; <span class="comment">//返回轴的位置</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>栈和队列的区别</p>
<ol>
<li>队列：先进先出(First In First Out)FIFO 栈：先进后出(First In Last Out )FILO</li>
<li>队列：只能在表的一端进行插入，并在表的另一端进行删除;栈：只能在表的一端插入和删除。</li>
</ol>
<p>堆</p>
<p>堆是一种满足以下条件的树：</p>
<p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>
<p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong> 堆的初始化时间复杂度为 <code>O(nlog(n))</code>，堆可以做到<strong>O(1)</strong>时间复杂度取出最大值或者最小值，<strong>O(log(n))</strong>时间复杂度插入或者删除数据</p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ol>
<li><p>抽象类和接口的区别</p>
<p>语法层面上的区别：</p>
<ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li>
<li>接口中不能含有静态代码块以及静态方法，而<strong>抽象类可以有静态代码块和静态方法</strong>；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<p>设计层面上的区别：</p>
<ul>
<li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对<strong>整个类整体进行抽象</strong>，包括属性、行为，但是接口却是对类<strong>局部（行为）</strong>进行抽象。</li>
<li>设计层面不同，抽象类作为很多子类的父类，它是一种<strong>模板式设计</strong>。而接口是一种<strong>行为规范</strong>，它是一种辐射式设计。</li>
</ul>
</li>
<li><p>解决hash冲突方法？</p>
<ol>
<li>开放定址法（再散列法）：如果<code>p=H(key)</code>出现冲突时，则以<code>p</code>为基础，再次hash，<code>p1=H(p)</code>,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址<code>pi</code>。</li>
<li>多重散列法：提供<strong>多个不同的hash</strong>函数，当<code>R1=H1(key1)</code>发生冲突时，再计算<code>R2=H2(key1)</code>，直到没有冲突为止。 </li>
<li>链地址法：将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li>
</ol>
</li>
<li><p>switch支持<strong>枚举类型和字符串</strong>，byte、short、char、int</p>
</li>
<li><p><strong>Threadlocal</strong></p>
<ol>
<li><p>应用场景：</p>
<p>   数据库连接池、会话管理</p>
</li>
<li><p>ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。</p>
</li>
<li><p>内存泄漏问题</p>
<p>   如何解决？</p>
<p>   使用完ThreadLocal后，及时调用remove()方法释放内存空间。在拦截器的aftercompletion方法里释放空间</p>
</li>
<li><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p>
</li>
</ol>
</li>
<li><p>泛型</p>
<pre><code>   定义：泛型就是将类型参数化，其在编译时才确定具体的参数。

   原理：一种语法糖，基本原理是类型擦除：使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数。

   好处：1. 提供了编译期类型安全，确保只把正确类型的对象放入对象中   2. 避免强制类型转换
</code></pre></li>
<li><p>hashmap为什么线程不安全？</p>
<pre><code>  1. 多线程put时，可能会导致相同hash值元素的覆盖
  2. put和get并发时，若put导致元素个数超出threshold而导致rehash，线程2此时执行get获得null

  链表转红黑树阈值为8？泊松分布，链表中元素个数为 8 时的概率已经非常小，再多的就更少了
</code></pre></li>
<li><p>Concurrenthashmap</p>
<pre><code>  1. 1.7是由segment数组+hashentry数组组成（锁分段）   1.8 数组+链表+红黑树（锁元素）
  2. 如何保证线程安全的？ 1.7用了分段锁  1.8用了cas+synchronized
</code></pre></li>
<li><p>hashtable</p>
<pre><code>  Hashtable是使用Synchronized来实现线程安全的，**给整个哈希表加了一把大锁**，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放
</code></pre><p>   <strong>与hashmap的区别：</strong></p>
<p>   <strong>底层数据结构</strong>不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树<br>   Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。<br>   添加key-value的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法,而HashTable是直接采用key的hashCode()<br>   <strong>实现方式不同</strong>：Hashtable 继承的是 Dictionary类，而 HashMap 继承的是 AbstractMap 类。<br>   <strong>初始化容量不同</strong>：HashMap 的初始容量为：<strong>16，</strong>Hashtable 初始容量为：<strong>11</strong>，两者的负载因子默认都是：0.75。<br>   <strong>扩容机制不同</strong>：当已用容量&gt;总容量 <em> 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 +1。<br>   支持的遍历种类不同：HashMap只支持Iterator遍历,而HashTable支持Iterator和Enumeration两种方式遍历<br>   <em>*迭代器不同</em></em>：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。<br>   部分API不同：HashMap不支持contains(Object value)方法，没有重写toString()方法,而HashTable支持contains(Object value)方法，而且重写了toString()方法<br>   同步性不同: Hashtable是同步(synchronized)的，适用于多线程环境, 而hashmap不是同步的，适用于单线程环境。多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。</p>
</li>
<li><p>hashset去重原理</p>
<pre><code>   获取对象的hashcode值，然后得到数组存储下标，如果为空直接添加，如果不为空，调用equals判断如果相同插入失败
</code></pre></li>
<li><p>Java的多态怎么理解？什么是运行时多态和编译时多态？</p>
<pre><code>             它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。

             重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法。

             编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。
</code></pre></li>
<li><p>static理解</p>
<pre><code>               static修饰的成员被所有对象共享，位于方法区中，static优于对象存在，它在类加载过程中的准备阶段，会为static变量分配存储空间，并进行初始化。
</code></pre></li>
<li><p>访问控制权限</p>
<pre><code>           package（默认）、private、public和protected.

           package:同一个包内的其他类可以访问

           private:只能被同一个类的其他方法访问

           public:都可以访问

           protected:只能在子类和同一个包里面的类访问
</code></pre></li>
<li><p>Object类有哪些方法</p>
<pre><code>           - toString
           - getClass

           - finalize：该方法用于释放资源
           - equals
           - hashCode
           - wait(使当前线程等待该对象的锁)、notify(唤醒在该对象上等待的某个线程)、notifyAll
</code></pre></li>
<li><p>反射</p>
<pre><code>        在**运行状态**中，对于任意一个类，都能够知道这个类的所有属性和方法

        getMethod  invoke

        **反射应用在哪些地方？**

        1. JDBC数据库连接  1. 加载类驱动程序 2. 通过drivermanager类进行连接，输入参数  3. 通过connection接口接收连接
        2. spring通过xml配置bean的过程 1. 将xml配置文件存入内存中 2. 调用java类进行解析，得到对应实体类字节码字符串及相关属性信息 3. 通过class.forname以这个字符串为参数生成class对象， 4. 动态配置
</code></pre></li>
<li><p>异常</p>
<pre><code>        exception(可以捕获的异常)和error（无法捕获）
</code></pre></li>
<li><p>NIO：非阻塞同步，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。相比于BIO一个连接占用一个线程，NIO是一个请求占用一个线程，它中的线程可以处理多个连接请求</p>
</li>
<li><p>hashcode与equals</p>
<p>   两个对象==相等，则其hashcode一定相等，反之不一定成立。</p>
<pre><code> 两个对象equals相等，则其hashcode一定相等，反之不一定成立。

 其实这个重写自己的hashCode方法并没有什么绝对正确的答案，但是我们的目标是：不相等的对象尽可能有不同的hashCode，而且必须满足的一个通用约定是：**相等的对象应该具有相同的hashCode**。

 **如果两个对象的hashcode相等，那么这两个对象可能是不同的对象吗？**

 可能是两个完全不同，没有任何关系的对象。因为hashcode的本质上是一个整数，这个整数默认情况下由内存地址计算而来，怎么计算？假设hashcode的取值范围是0-10，假设 散列算法是 除10 取余【当然这只是假设，具体算法可以去看源码，但是大致效果应该是差不多，都是把可能相当大的一个数字 收敛到一个 小的区间 方便使用】，那么 对象A内存地址假设为 101，则对象A的hashcode为1， 对象B内存地址假设为201 ，则对象B的hashcode为1.AB两个对象地址不同 是 不同的对象，但是他们的hashcode还是相同的。
</code></pre></li>
<li><p>Map遍历方式</p>
<pre><code>  **第一种方法：使用for循环的Entry遍历**

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  **第二种方法：使用for循环，按需遍历**

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())</span><br><span class="line"><span class="keyword">for</span>(Integer value:map.values())</span><br></pre></td></tr></table></figure>

  **第三种方法：使用Iterator遍历**

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it=map.entrySet().iterator()</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     Map.Entry&lt;String, Integer&gt; entry = it.next();</span><br><span class="line">     System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

  **第四种方法：先遍历键，然后通过键找值**

  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">     Integer value = map.get(key);</span><br><span class="line">     System.out.println(<span class="string">&quot;Key = &quot;</span> + key + <span class="string">&quot;, Value = &quot;</span> + value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ol>
<pre><code>​      
</code></pre><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p>
<p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</strong> </p>
<p>最好用这个方法创建线程池，否则可能会造成资源耗尽</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<p>Executor: 1. 任务（需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>） 2. 任务的执行(<code>Executor</code>)  3. 异步计算的结果(<code>Future</code>) (任务返回结果)</p>
<ol>
<li><p>线程池有哪些参数（7个）？</p>
<p>corePoolSize: 核心线程数量（最小可以同时运行的线程数量），默认情况下，线程池的线程数量为0，只有任务来时，才会创建线程，<strong>当线程池中的线程数量达到corePoolSize</strong>，就会把达到的任务放到缓存队列当中。</p>
<p>maximumPoolSize: 线程池最大线程数量。非核心线程数量（空闲线程）=maximumPoolSize-corePoolSize（队列线程数）</p>
<p>keepAliveTime: <strong>空闲的线程保留时间</strong>。意思是线程被用过之后，一定时间没有再用后，就会自动放回线程池。</p>
<p>unit :keepAliveTime的单位</p>
<p>workingQueue: <strong>阻塞队列</strong>（不是执行队列！）。 <strong>用来存放被提交但是尚未被执行的任务</strong>。ArrayBlockingQueue、<br>LinkedBlockingQueue、SynchronousQueue可选。</p>
<p>defaultHandler ：饱和策略。队列已满，而且任务量大于最大线程的异常处理策略。。ThreadPoolExecutor类中一共有4种饱和策略。通过实现RejectedExecutionHandler接口。</p>
<ul>
<li>AbortPolicy ： 线程任务丢弃报错。默认饱和策略。</li>
<li>DiscardPolicy ： 线程任务直接丢弃不报错。</li>
<li>DiscardOldestPolicy ： 将workQueue<strong>队首任务丢弃</strong>，将最新线程任务重新加入队列执行。</li>
<li>CallerRunsPolicy ：线程池之外的线程直接调用run方法执行。</li>
</ul>
<p>ThreadFactory ：线程工厂。executor创建新线程会用到</p>
</li>
<li><p>为什么要用线程池？</p>
<ul>
<li><strong>降低资源消耗</strong>，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>， 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
</li>
<li><p>线程池工作原理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//任务队列</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">     <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line">     <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">     <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line">             <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.loli.net/2022/08/04/GIEQMegNJ2BuyxY.png" alt="图解线程池实现原理"></p>
</li>
<li><p>有哪几种线程池，底层是怎么实现的？</p>
<p>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。工作线程的创建数量几乎没有限制<br>newFixedThreadPool ：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>newScheduledThreadPool： 创建一个定长线程池，支持定时及周期性任务执行。<br>newSingleThreadExecutor ：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，<strong>保证所有任务按照指定顺序</strong>(FIFO, LIFO, 优先级)执行。</p>
<p>有哪几种阻塞队列？</p>
<p>无界队列（LinkedBlockingQueue），有界队列（ArrayBlockingQueue）</p>
<p><strong>如何合理配置线程池参数？</strong></p>
<ol>
<li><p>首先分析线程池处理的程序是CPU密集型（I/O在很短的时间就可以完成，而CPU还有许多运算要处理,只有在真正的多核CPU才可能得到加速）还是IO密集型（CPU性能相对硬盘、内存要好很多，任务需要大量的IO，即大量的阻塞。）？</p>
<p>CPU密集型：corePoolSize = CPU核数 + 1<br>IO密集型：corePoolSize = CPU核数 * 2</p>
</li>
<li><p>阻塞队列：无界队列不适合qps较高的场景，容易造成OOM。有界队列可以减少内存消耗，但会降低吞吐量</p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p><strong>如何实现线程安全</strong>？</p>
<ol>
<li><p>阻塞（互斥）同步，一种悲观锁，认为只有不加锁，一定会出现问题</p>
<p>一个线程进入监视器（可以认为是一个只允许一个线程进入的盒子），其他线程必须等待，直到那个线程退出监视器为止。最常见的synchronized</p>
<p><strong>synchronized底层原理</strong></p>
<p>synchronized 同步代码块的实现是通过 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，<strong>线程试图获取锁</strong>也就是获取 <strong>monitor</strong>(monitor对象存在于<strong>每个Java对象的对象头中</strong>，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。</p>
<p><strong>其内部包含一个计数器，当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</strong></p>
</li>
<li><p>非阻塞同步，一种乐观锁</p>
<p>使用锁会有性能损耗</p>
<p><strong>先进行操作，如果没有其他线程争用共享数据，那么操作就成功了，如果共享数据有争用，就采取补偿措施（不断地重试）。</strong></p>
<p><strong>CAS</strong>是实现非阻塞同步的计算机指令，是一种<strong>硬件对并发的支持</strong>。它有三个操作数：内存位置，旧的预期值，要修改的更新值 ，在执行CAS操作时，当且仅当内存地址的值符合旧的预期值的时候，才会用新值来更新内存地址的值，否则就不执行更新。</p>
<p>例子：一个线程从主内存中得到num值，并对num进行操作，写入值的时候，线程会把第一次取到的num值和主内存中num值进行比较，如果相等，就会将改变后的num写入主内存，如果不相等，则一直循环对比，知道成功为止。</p>
<p>jdk1.5中java.util.concurrent.  AtomicInteger类的compareAndSet通过原子操作实现了CAS操作，最底层基于汇编语言实现。</p>
<pre><code> 使用方法：使用JUC包下的整数原子类（AtomicInteger）的decompareAndSet（）和getAndIncrement（）方法
</code></pre><p>  缺点 ：<strong>ABA 问题</strong> ，如何解决？</p>
<p>使用<strong>版本号方法</strong>来解决，使用<strong>AtomicStampedReference</strong>对象代替AtomicInteger对象，其内部维护了初始值和初始版本号，<strong>当该对象设置值时，必须对象值和状态戳都满足期望值</strong>，写入才会成功</p>
</li>
</ol>
</li>
</ol>
<ol>
<li><p>无同步方案</p>
<p>线程本地存储：将共享数据的可见范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题。</p>
<p><strong>访问threadlocal变量的每个线程都有这个变量的本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</strong></p>
<p>经常使用的就是ThreadLocal类</p>
<p>ThreadLocal类 最常见的ThreadLocal使用场景为 用来解决数据库连接、Session管理等。</p>
<ul>
<li>Thread类有一个类型为ThreadLocal.ThreadLocalMap的<strong>成员变量</strong>threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。</li>
<li><strong>ThreadLocalMap</strong>内部维护着<strong>Entry数组</strong>，每个Entry代表一个完整的对象，key是ThreadLocal本身，<strong>value是ThreadLocal的泛型值。（项目中的User对象）</strong></li>
<li>每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li>
</ul>
<p><strong>内存泄漏问题：</strong></p>
<p>threadlocal本身引用类型是弱引用（只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。），而threadlocalmap的生命周期和thread是一样的，所以可能造成key这个threadlocal本身虽然被回收了，但是value还在，就造成了…。</p>
</li>
</ol>
<ol>
<li><p>Synchronized和Reentrantlock的区别</p>
<p><strong>1.两者都是可重入锁</strong></p>
<p>可重入锁：重入锁，也叫做递归锁，可重入锁指的是在<strong>一个线程中可以多次获取同一把锁</strong>，比如： 一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而<strong>无需重新获得锁</strong>， 两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p>
<ul>
<li>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的</li>
<li>ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）</li>
</ul>
<p><strong>3.ReentrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知</strong>（锁可以绑定多个条件）</p>
<ul>
<li>等待可中断.通过lock.lockInterruptibly()来实现这个机制。也就是说<strong>正在等待的线程可以选择放弃等待，改为处理其他事情。</strong></li>
<li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是<strong>先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 <strong>ReentrantLock类的ReentrantLock(boolean fair)构造方法</strong>来制定是否是公平的。</li>
<li>ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，<strong>用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong></li>
</ul>
<p><strong>4.使用选择</strong></p>
<ul>
<li>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。</li>
<li>synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放</li>
</ul>
</li>
<li><p>synchronized 和 Lock 有什么区别？</p>
<ul>
<li>synchronized 可以给<strong>类. 方法. 代码块</strong>加锁；而 <strong>lock</strong> 只能给<strong>代码块</strong>加锁。</li>
<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 <strong>lock 需要自己加锁和释放锁</strong>，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>
<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>
</ul>
</li>
</ol>
<ol>
<li><p>自己设计线程池要考虑哪些问题</p>
<p>并发量、任务执行时间——&gt;核心线程数、最大线程数、阻塞队列、饱和策略</p>
</li>
<li><p>Java中有哪些锁？</p>
<p>1、<strong>悲观锁和乐观锁</strong><br>悲观锁：当前线程去操作数据的时候，总是认为别的线程会去修改数据，所以每次操作数据的时候都会上锁，别的线程去操作数据的时候就会阻塞，比如synchronized；</p>
<p>乐观锁：当前线程每次去操作数据的时候<strong>都认为别人不会修改，更新的时候会判断别人是否会去更新数据，通过版本来判断，如果数据被修改了就拒绝更新</strong>，例如cas是乐观锁，但是严格来说并不是锁，通过原子性来保证数据的同步，例如数据库的乐观锁，通过版本控制来实现，cas不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响</p>
<p>总结：悲观锁适合<strong>写操作多</strong>的场景，乐观锁适合<strong>读操作多</strong>的场景，乐观锁的吞吐量会比悲观锁高</p>
<p>2、<strong>公平锁和非公平锁</strong><br>公平锁：有多个线程按照申请锁的顺序来获取锁，就是说，如果一个线程组里面，能够保证每个线程都能拿到锁，例如：ReentrantLock（使用的同步队列FIFO）</p>
<p>非公平锁：获取锁的方式是随机的，保证不了每个线程都能拿到锁，会存在有的线程饿死，一直拿不到锁，例如：synchronized，ReentrantLock</p>
<p>总结：非公平锁性能高于公平锁，更能重复利用CPU的时间</p>
<p>3、<strong>可重入锁和不可重入锁</strong><br>可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不会产生死锁</p>
<p>不可重入锁：在当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞</p>
<p>总结：可重入锁能一定程度的避免死锁，例如：synchronized，ReentrantLock</p>
<p>4、<strong>自旋锁</strong><br>自旋锁：<strong>一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待</strong>，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环，任何时刻最多只能有一个执行单元获得锁</p>
<p>总结：不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU</p>
<p>5、<strong>共享锁和独享锁</strong><br>共享锁：也叫读锁，可以查看数据，但是不能修改和删除的一种数据锁，加锁后其他的用户可以并发读取，但不能修改、增加、删除数据，该锁可被多个线程持有，用于资源数据共享</p>
<p>独享锁：也叫排它锁、写锁、独占锁、独享锁，该锁每一次只能被一个线程所持有，加锁后任何线程试图再次加锁都会被阻塞，直到当前线程解锁。例如：线程A对data加上排它锁后，则其他线程不能再对data加任何类型的锁，获得互斥锁的线程既能读数据又能修改数据</p>
</li>
<li><p>线程状态                      </p>
<p>新建、就绪、运行、阻塞、死亡</p>
<p><strong>就绪状态是进入到运行状态的唯一入口</strong>，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
</li>
</ol>
<p>​        <strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同</p>
<p>​        1.<strong>等待阻塞</strong>：运行状态中的线程执行<strong>wait()方法</strong>，使本线程进入到等待阻塞状态，JVM 会将线程放入等待序列（waitting queue）；</p>
<p>​        2.<strong>同步阻塞</strong> — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态，若该 <strong>同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中</strong>；</p>
<p>​        3.其他阻塞 — 通过调用线程的<strong>sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。</strong>当<strong>sleep()状态超时. join()等待线程终止或者超时</strong>. 或者I/O处理完毕时，线程重新转入就绪状态。</p>
<ol>
<li><p>sleep和wait方法的区别（thread类的yield方法也能暂停线程）</p>
<ul>
<li><p>wait方法是Object的方法，需要与synchronized关键字一起使用，sleep是线程中的方法</p>
</li>
<li><p>sleep阻塞期间不释放锁，wait释放</p>
</li>
<li>sleep时间到了重新进入就绪，wait需要另一个线程调用notify或notifyall唤醒，重新占用互斥锁后进入就绪状态</li>
<li>sleep通常用于暂停线程，wait用于线程间通信（join底层使用wait）</li>
</ul>
</li>
<li><p>volatile</p>
<p>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作。</p>
<p>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值。</p>
<p>有序性：按照代码顺序执行</p>
<p>实现了可见性（当volatile变量被修改，新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的。）、有序性，无法保证原子性，只能保证单次读写的原子性。</p>
<p>原理：</p>
<p>JVM底层使用了<strong>内存屏障的操作禁止了指令重排</strong>保证了有序性，而且使本线程工作内存中的volatile变量值立即写入到主内存中，并使其他工作内存中volatile变量无效化，这样其他线程必须重新从主内存中读取变量值保证了可见性。</p>
</li>
<li><p>synchronized和volatile的区别</p>
<ol>
<li>volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li>volatile <strong>仅能使用在变量级别</strong>；synchronized 则可以使用在 <strong>变量. 方法. 和类级别的</strong></li>
<li>volatile 仅能实现变量的修改可见性，<strong>不能保证原子性</strong>；而synchronized 则可以 <strong>保证变量的修改可见性和原子性</strong></li>
<li>volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ol>
</li>
<li><p>介绍下原子类</p>
<p>Atomic-Integer、boolean、long、atomicstampedReference</p>
<p>AtomicInteger 类主要利用 <strong>CAS</strong>和 <strong>volatile</strong> 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
</li>
<li><p>线程通信的方式：1. wait、notify  2. join  3. volatile共享内存</p>
</li>
<li><p>进程通信方法: 1. 消息队列 2. socket（网络）</p>
</li>
<li><p>synchronized锁<strong>类</strong>和<strong>this</strong>有什么区别？</p>
<ol>
<li><p>当加了类锁的方法或代码块处于访问状态时，<strong>该类</strong>的其他加了类锁的方法或代码块将拒绝其他线程的访问，但是<strong>其他线程可以访问该类的普通方法或者未被占用的this锁或object锁</strong>。只有当该方法或代码块执行完毕，其他线程才能访问该类的类锁（注意是方法执行完毕，而不是线程执行完毕。）</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20210501165343705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDk1NjA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>当加了this锁（对象锁）处于访问状态时，那么<strong>该对象的其他this锁（对象锁）将拒绝其他线程访问</strong>，但是它的普通方法或者加了<strong>类锁、object锁只要不被其他线程占有，其他线程依然可以进行访问</strong>。只有当该方法或代码块执行完毕，其他线程才能访问该对象的对象锁（注意是<strong>对象锁，同一个类的不同对象，他们之间的对象锁是没有任何关系的，只有处于同一个对象，他们的对象锁才会发生阻塞。</strong>）</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img-blog.csdnimg.cn/20210501171140383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDk1NjA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
<li><p>讲讲你对AQS的理解？</p>
<p>​    AQS是一个并发包的基础组件，内部实现的关键是：<strong>先进先出的线程等待队列</strong>、代表<strong>加锁状态</strong>的state变量、表示<strong>当前占锁的线程</strong>的变量，拥有两种线程模式独占模式和共享模式。在LOCK包中的相关锁(常用的有ReentrantLock、 ReadWriteLock)都是<strong>基于AQS来构建</strong>，一般我们叫<strong>AQS为同步器</strong>。</p>
</li>
<li><p>Reentrant(可重入)Lock原理</p>
<p>reentrant底层是基于AQS组件实现的，当reentrantloc调用lock方法进行加锁的过程，就是将state状态变量利用cas操作从0变1的过程，一旦加锁成功，那么它就可以设置当前加锁线程是它自己，说它是可重入锁的原因就是它每次加锁的时候都会判断当前加锁线程是否是他自己，是就可以对state进行累加。</p>
<p>线程2进行加锁的时候，先看是否能将state值从0变1，若失败，查看当前加锁线程是否是它自己，若不是就放入等待队列中，等锁释放后（state递减，加锁线程变量设置为null）将其唤醒</p>
</li>
</ol>
</li>
</ol>
<p>​        </p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM内存模型：</p>
<p>方法区：存放已加载的类信息、常量、静态变量等。jdk1.8中不存在方法区，被<strong>元空间</strong>替代。原方法区分为两部分：加载的类信息放在元空间中，运行时常量池保存在堆中</p>
<p>堆：java堆是所有线程共享的一块内存，<strong>几乎所有对象的实例和数组都要在堆上分配内存</strong>，因此该区域经常发生垃圾回收的操作；</p>
<p>程序计数器：用于记录当前虚拟机<strong>正在执行</strong>的<strong>线程指令地址</strong></p>
<p>本地方法栈：保存的是<strong>本地方法</strong>的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的<strong>动态链接并直接调用该方法</strong>；</p>
<p>虚拟机栈：线程私有，<strong>每个方法</strong>执行的时候都会创建一个<strong>栈帧</strong>，用于存储<strong>局部变量表</strong>、<strong>操作数</strong>、动态链接和<strong>方法返回</strong>等信息</p>
<ol>
<li><p>类加载过程</p>
<pre><code>  加载——链接——初始化

  加载：1. 通过类的全限定性类名获取该类的二进制流； 2、将该二进制流的静态存储结构转为方法区的运行时数据结构； 3、在堆中为该类生成一个class对象；

  验证：验证该class文件中的字节流信息复合虚拟机的要求，不会威胁到jvm的安全；

  准备：为class对象的静态变量分配内存，初始化其初始值；

  解析：该阶段主要完成符号引用转化成直接引用；

  初始化：到了初始化阶段，才开始执行类中定义的java代码；初始化阶段是调用类构造器的过程；
</code></pre></li>
<li><p>双亲委派机制</p>
<p>   类加载器：<strong>启动类加载器</strong>、扩展类加载器、系统类加载器、自定义类加载器</p>
<p>   当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；</p>
<p>   <strong>那怎么打破双亲委派模型</strong>？</p>
<p>   自定义类加载器，继承ClassLoader类，重写<strong>loadClass方法</strong>和<strong>findClass</strong>方法。</p>
<p>   打破类加载器的例子：</p>
<p>   Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。</p>
</li>
<li><p>分代垃圾回收</p>
<p>   原因：不同对象的生命周期是不一样的</p>
<p>   堆内存划分为新生代和老年代，新生代采用复制算法进行垃圾回收，分为伊甸区和幸存者from、to区。</p>
<p>   <strong>第一次minor GC</strong>, 伊甸区满了之后利用可达性分析算法将存活对象放到幸存者to区中，同时交换from、to, 幸存区寿命+1，伊甸区垃圾回收</p>
<p>   第二次minor GC 与第一次类似，也会回收幸存区中垃圾，当from区中寿命超过一定阈值，晋升到老年代</p>
<p>   Full GC  如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
</li>
<li><p>内存溢出和内存泄漏？。</p>
<p>   内存溢出：程序申请内存时，没有足够的内存空间供其使用</p>
<p>   内存泄漏：指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费</p>
</li>
<li><p>内存泄漏举个例子？有没有什么方法避免写出这种情况？threadlocal </p>
</li>
<li><p>CMS垃圾回收器</p>
<p>   <strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
<p>   <strong>并发标记</strong>：根据上一步的结果，继续向下标识所有关联的对象，直到这条链上的最尽头。是进行GC Roots Tracing 的过程，找出存活对象且用户线程可<strong>并发执行</strong>(不需要STW)</p>
<p>   <strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在<strong>Stop The World</strong>问题 （较慢）</p>
<p>   <strong>并发清除</strong>：对标记的对象进行清除回收</p>
</li>
<li><p>volatile原理</p>
<p>   volatile底层使用了一个内存屏障的操作，它可以使本线程工作内存中的volatile变量立即写入到主内存中，并且使其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。</p>
</li>
<li><p><strong>根对象</strong>(GC ROOT)：肯定不能被当成垃圾被回收的对象</p>
<ul>
<li><strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong></li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中<strong>常量</strong>引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
</li>
<li><p>如何手动去调用GC？</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 或者下面，两者等价</span></span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol>
<li><p>osi七层模型及各层作用</p>
<p>物理层：实现相邻节点间<strong>比特流</strong>的透明传输，尽可能屏蔽传输介质和通信手段的差异。</p>
<p>数据链路层：数据链路层通常简称为链路层。将网络层传下来的<strong>IP数据包</strong>组装成<strong>帧</strong>，并再相邻节点的链路上<strong>传送帧</strong>。（交换机，mac表）</p>
<p>网络层：选择合适的<strong>路由和交换结点</strong>，确保数据及时传送。主要包括IP协议。</p>
<p>传输层：向主机<strong>进程</strong>提供通用的数据传输服务。tcp、udp</p>
<p>会话层: 负责在网络中的两节点之间建立、维持和终止<strong>通信</strong></p>
<p>表示层: 主要负责数据格式的转换，如<strong>加密解密、转换翻译、压缩解压缩</strong>等</p>
<p>应用层: 为<strong>应用程序提供交互服务</strong>。在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等。</p>
</li>
<li><p>TCP拥塞控制的四种算法：</p>
<p>围绕着拥塞窗口来说</p>
<ul>
<li><strong>慢开始</strong> (slow-start)：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。</li>
<li><strong>拥塞避免</strong> (congestion avoidance)：每经过<strong>一个往返时间RTT</strong>就把发送方的<strong>拥塞窗口cwnd加1而不是加倍</strong>。这样拥塞窗口按线性规律缓慢增长。</li>
<li><strong>快速重传</strong> (fast retransmit)：比如<strong>接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
<li><strong>快速恢复</strong> (fast recovery)：主要是配合快重传。<strong>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半</strong>（为了预防网络发生拥塞），但接下来并不执行慢开始算法</li>
</ul>
</li>
<li><p>浏览器输入url到显示页面的简要流程</p>
<ol>
<li><p>域名解析（域名 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com </a>变为 ip 地址）。</p>
<p><strong>浏览器搜索自己的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索<strong>操作系统的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索操作系统的<strong>hosts文件</strong>（维护一张域名与IP的对应表）。</p>
<p>若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即<strong>本地 dns 服务器</strong>（递归查询），<strong>本地域名服务器查询自己的dns缓存</strong>，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。</p>
</li>
<li><p>发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 <strong>80</strong> 端口发起 tcp 的连接。</p>
</li>
<li><p>建立 tcp 连接后发起 http 请求。</p>
</li>
<li><p>服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。</p>
</li>
<li><p>浏览器解析 html 代码，并请求 html 中的资源。</p>
</li>
<li><p>浏览器对页面进行渲染，并呈现给用户。</p>
</li>
</ol>
</li>
<li><p>TCP三次握手、四次挥手</p>
<ul>
<li>第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN=1），同时选择一个随机数 seq = x 作为<strong>初始序列号</strong>，并进入SYN_SENT状态，等待服务器确认。</li>
<li>第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN=1，ACK=1），确认号为 ack = x + 1，同时选择一个随机数 seq = y 作为<strong>初始序列号</strong>，此时服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK=1），确认号为 ack = y + 1，序列号为 seq = x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ul>
</li>
</ol>
<p>   ​    </p>
<ul>
<li><p>第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认。</p>
<ul>
<li>序列号 seq = u，即客户端上次发送的报文的最后一个字节的序号 + 1</li>
<li>确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1</li>
</ul>
</li>
<li><p>第二次挥手：服务端收到连接释放报文后，立即发出<strong>确认报文</strong>（ACK=1），（确认序号为收到的序号加 1 。）序列号 seq = k，确认号 ack = u + 1。</p>
<p>这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</p>
</li>
<li><p>第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认。</p>
<ul>
<li>序列号 seq = w，即服务端上次发送的报文的最后一个字节的序号 + 1。</li>
<li>确认号 ack = u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据</li>
</ul>
</li>
<li><p>第四次挥手：客户端收到服务端的连接释放报文后，立即发出<strong>确认报文</strong>（ACK=1），序列号 seq = u + 1，确认号为 ack = w + 1。</p>
<p>此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p>
<p><strong>为什么需要三次握手，而不是两次？</strong></p>
<p>在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，<strong>由于网络原因造成 A 暂时无法到达服务器</strong>，服务器接收不到请求报文段就不会返回确认报文段。</p>
<p>客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。</p>
<p>此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致<strong>服务器长时间单方面等待，造成资源浪费。</strong></p>
<p><strong>为什么需要三次握手，而不是四次？</strong></p>
<p>因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p>
<ul>
<li>第一次握手：服务端确认“自己收、客户端发”报文功能正常。</li>
<li>第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。</li>
<li>第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。</li>
</ul>
</li>
</ul>
<ol>
<li><p>http和https的区别</p>
<ul>
<li>端口：80 443</li>
<li>安全性：https有加密机制，安全性更高</li>
<li>https需要证书，http不需要</li>
<li>http运行在tcp协议之上，https在ssl协议之上</li>
</ul>
</li>
<li><p>状态码</p>
<p>3：重定向 4：客户端错误 5：服务器端错误</p>
<p>403：服务器收到请求，但是拒绝提供服务。</p>
<p>301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示<strong>旧地址A的资源还在</strong>（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会<strong>抓取新的内容而保存旧的网址</strong>。</p>
</li>
<li><p>get和post的区别</p>
<ul>
<li>GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。</li>
<li>GET方式提交的数据有<strong>长度限制</strong>，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</li>
<li>POST比GET<strong>安全</strong>，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</li>
</ul>
</li>
<li><p>请求报文格式</p>
<ol>
<li>请求行（<strong>请求方法+URI协议+版本</strong>）</li>
<li>请求头部</li>
<li>空行</li>
<li>请求主体</li>
</ol>
</li>
<li><p>cookie和session</p>
<p>Cookie（也叫 Web Cookie或浏览器 Cookie）是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p>
<p>Session 代表着<strong>服务器和客户端一次会话的过程。</strong> 当<strong>客户端关闭会话，或者 Session 超时失效</strong>时会话结束。</p>
</li>
</ol>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol>
<li><p>索引匹配原则</p>
<p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>、<strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p>
</li>
<li><p>索引失效情况？</p>
<ol>
<li>有or</li>
<li>范围查询，或like查询是以%开头</li>
<li>索引列参与计算</li>
<li>违背最左匹配原则</li>
</ol>
</li>
<li><p>数据误删除操作之后能不能回滚</p>
<p>不能，能恢复binlog记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。</p>
</li>
<li><p>写sql语句：可以灵活使用 order by count() limit 1等方法</p>
</li>
<li><p>怎么做分页？limit 偏移量 数目</p>
</li>
<li><p>获取当前时间？select now()</p>
</li>
<li><p>Mysql的左连接和右连接有什么区别？左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据。右连接类似（横向）</p>
<p>  1、left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。<br>   　　<br>   　 2、right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。<br>   　<br>   　 3、inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。</p>
</li>
<li><p>索引类型？</p>
<p>主键索引（不能为null, 不能重复），普通索引、唯一索引（不能重复，可以为null）、复合索引等</p>
</li>
<li><p>介绍下事务</p>
<p>事务就是<strong>一组原子性的操作</strong>，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。</p>
</li>
<li><p>说下可重复读</p>
<p>  这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。<strong>读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。</strong></p>
</li>
<li><p>mysql是如何实现事务隔离的？</p>
<pre><code>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。

MySQL 在可重复读级别解决了幻读问题，是通过**行锁**和**间隙锁**的组合 Next-Key 锁实现的。
</code></pre></li>
<li><p>B+树特点</p>
<p>  能使B+树<strong>保持较低的高度</strong>，从而达到有效避免<strong>磁盘过于频繁的查找存取操作</strong>，从而有效提高查找效率，若是二叉树可能会退化成线性查找，导致高度过高（B+树的节点，即非叶子节点大小 = 页大小 读取一页需要一次IO）</p>
<pre><code>- 只有叶子节点存放key和data, 其他节点只存放key

  B+树的优点：

  由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。

  搜索时间复杂度mlogN(m是每个节点有几个数据)
</code></pre></li>
</ol>
<ol>
<li><p>聚簇索引和非聚簇索引</p>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是<strong>数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引</strong>（或聚集索引）（有且只有一个，是<strong>主键索引</strong>）”，而其余的索引都作为辅助索引，<strong>辅助索引的 data 域存储相应记录主键的值而不是地址</strong>，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要<strong>先取出主键的值，再走一遍主索引</strong>。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
</li>
<li><p>索引失效的场景</p>
<ul>
<li>select *</li>
<li>索引列上有计算</li>
<li>不满足最左匹配原则</li>
<li>索引列用了函数</li>
<li>like %开头</li>
<li>or关键字</li>
</ul>
</li>
<li><p>B+树索引的优点</p>
<ol>
<li>B+树的非叶节点只包含键，而不包含真实数据，因此相同内存情况下<strong>每个节点存储的记录个数比B数多很多</strong>（即阶m更大），因此<strong>B+树的高度更低</strong>，<strong>访问时所需要的IO次数更少</strong></li>
<li>在B树中进行范围查询时，首先找到要查找的下限，然后对<strong>B树进行中序遍历</strong>，直到找到查找的上限；而B+树的范围查询，只需要对<strong>双向链表进行遍历即可</strong>。</li>
<li>B树的查询时间复杂度在<strong>1到树高之间</strong>(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。</li>
</ol>
</li>
<li><p>mysql分页优化(翻页过多时，查询性能急剧下降)</p>
<p>​        <strong>分页游标</strong>：当我们查询第二页的时候，把<strong>第一页的查询结果</strong>放到第二页的<strong>查询条件中</strong>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from user </span><br><span class="line">where create_time&gt;<span class="string">&#x27;2022-07-03&#x27;</span> and id&gt;<span class="number">10</span> </span><br><span class="line">limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>​                    适用于没有跳转到指定页面需求的应用，如瀑布流新闻等。</p>
<p>​                <strong>避免回表查询</strong></p>
<p>​                使用inner join关联查询</p>
<ol>
<li><p>mysql的索引</p>
<p><strong>InnoDB 的 B+Tree 索引分为主索引（聚集索引）和辅助索引(非聚集索引)。一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树。</strong></p>
<p>InnoDB聚集索引的叶子节点存储<strong>行记录</strong>，因此， InnoDB必须要有，<strong>且只有一个聚集索引</strong>：</p>
<p>（1）如果表定义了PK，则PK就是<strong>聚集索引</strong>；</p>
<p>（2）如果表没有定义PK，则第一个not NULL unique列是聚集索引；</p>
<p>（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；</p>
<p>表中有四条记录：</p>
<p>　　1, shenjian, m, A</p>
<p>　　3, zhangsan, m, A</p>
<p>　　5, lisi, m, A</p>
<p>　　9, wangwu, f, B</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220818150438243.png" alt="image-20220818150438243"></p>
<p>两个B+树索引分别如上图：</p>
<p>　　（1）id为PK，聚集索引，叶子节点存储行记录；</p>
<p>　　（2）name为KEY，普通索引，叶子节点存储PK值，即id；既然从普通索引无法直接定位行记录，那普通索引的查询过程是怎么样的呢？</p>
<p>通常情况下，需要扫码两遍索引树。</p>
</li>
</ol>
<pre><code>例如：

select * from t where name=&#39;lisi&#39;;　

是如何执行的呢？



如粉红色路径，需要扫码两遍索引树：

（1）先通过普通索引定位到主键值id=5；

（2）在通过聚集索引定位到行记录；

 ![image-20220818150552992](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220818150552992.png)

不宜使用过长的字段作为索引，可能导致相同内存情况下，高度变高，io次数变多

这就是所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。

18. **MySQL中如何解决幻读**

    1. 使用串行化隔离级别，它是加表级锁，所以效率较低
    2. 在快照读（普通select）下，采用 MVCC 机制解决幻读，读取的是快照中的数据。
    3. 在当前读（update、delete）下，不仅对扫描到的行进行加锁，还对**行之间的间隙**进行加锁，这样就能杜绝新数据的插入和更新。这个其实就是记录锁 **Record Lock** 和间隙锁 **Gap Lock**，也被称为临键锁 **Next-Lock Key**。
       临键锁只在**可重复读**也就是 InnoDB 的默认隔离级别下生效。也可以采用更高的可串行化隔离级别，所有的操作都是串行执行的，可以直接杜绝幻读问

    SELECT查询分为快照读和实时读，快照读通过MVCC（并发多版本控制）来解决幻读问题，实时读通过行锁来解决幻读问题。

19. MVCC实现原理

    隐藏字段：在InnoDB存储引擎中，对于每一条记录都会有隐藏字段，包括**ROWID，事务ID（最新一次被哪个事务修改），回滚指针**

    ReadView： 当前数据的快照

    在READ COMMITTED隔离级别下，一个事务执行过程中**每次执行SELECT操作都会生成一个ReadView**，ReadView本身就保证了事务不可以读取到未提交的事务做出的修改，也就避免了脏读现象
    在REPETABLE READ隔离级别下，**一个事务执行过程中只有第一次执行SELECT操作时才会生成一个ReadView，之后的SELECT操作都是复用这个ReadView**，这也就避免了不可重复度和幻读

    对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：

    - ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。
    - 事务 ID：记录最后一次修改该记录的事务 ID。
    - 回滚指针：指向这条记录的上一个版本。

    InnoDB 每一行数据都有一个隐藏的回滚指针，用于**指向该行修改前的最后一个历史版本**，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。

    MVCC 作用于**读取已提交**和**可重复读（默认）**这两个隔离级别，这俩隔离级别下的**普通 select 操作就是快照读**, **读取快照中的数据，不需要进行加锁。**
</code></pre><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol>
<li><p>死锁的四个必要条件</p>
<ul>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺：当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ul>
</li>
<li><p>线程和进程的关系？</p>
<p>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上<strong>各进程是独立</strong>的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。<strong>线程执行开销小，但不利于资源的管理和保护</strong>；而进程正相反。</p>
</li>
<li><p>两个进程怎么通信？</p>
<ol>
<li>消息队列</li>
<li>套接字： 此方法主要用于在客户端和服务器之间通过网络进行通信。</li>
<li><strong>共享内存</strong>：使得多个进程可以访问同一块内存空间，<strong>不同进程可以及时看到对方进程中对共享内存中数据的更新</strong>。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</li>
</ol>
</li>
<li><p>线程同步的方式</p>
<ol>
<li>临界区：<strong>一段独占对某些共享资源访问的代码</strong>，在任意时刻只允许一个线程对共享资源进行访问。</li>
<li>互斥锁（reentranklock）：<strong>采用互斥对象机制</strong>。 <strong>只有拥有互斥对象的线程才有访问公共资源的权限</strong>，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。<strong>和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效</strong>率。</li>
<li>事件：事件机制，则<strong>允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。</strong></li>
</ol>
</li>
</ol>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Autowired注解自动注入原理"><a href="#Autowired注解自动注入原理" class="headerlink" title="Autowired注解自动注入原理"></a>Autowired注解自动注入原理</h3><h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><p>简答版：</p>
<p>启动类的@SpringBootApplication注解由@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解组成，三个注解共同完成自动装配；</p>
<p>@SpringBootConfiguration 注解标记启动类为配置类<br>@ComponentScan 注解实现启动时扫描启动类所在的包以及子包下所有标记为bean的类由IOC容器注册为bean<br>@EnableAutoConfiguration通过 <strong>@Import 注解</strong>导入 <strong>AutoConfigurationImportSelector</strong>类，然后通过AutoConfigurationImportSelector 类的 <strong>selectImports</strong> 方法去读取spring.factories中的自动配置类的类全名，并按照一定的规则（@ConditionalOnxxx注解）过滤掉不符合要求的组件的类全名，将剩余读取到的各个组件的类全名集合返回给IOC容器并将这些组件注册为bean</p>
<p>原理：</p>
<p><strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>
<p>@SpringBootApplication:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//允许在上下文中注册额外的 bean 或导入其他配置类</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">//启用 SpringBoot 的自动配置机制</span></span><br><span class="line">	AutoConfigurationImportSelector类 <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line">        selectImports方法：获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。</span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">//扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//&lt;2&gt;.获取所有需要装配的bean</span></span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Spring两大特性</p>
<ul>
<li><p>IOC（控制反转）: 把对象的创建、销毁的权利交给容器框架,由容器来管理对象的生命周期；  ioc包括<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=依赖注入&amp;spm=1001.2101.3001.7020">依赖注入</a>(DI,核心) 和 依赖查找；DI:依赖注入 就是在spring实例化对象的时候,由容器来设置这些对象的属性值，也就是组件之间依赖关系由容器在运行期决定。</p>
</li>
<li><p>AOP（面向切面编程）：采用<strong>横向抽取</strong>机制,能够将那些与业务无关，却为业务模块所共同调用的<strong>逻辑或责任</strong>（例如事务处理、日志管理、权限控制等）封装起来。便于减少重复代码，降低模块间的耦合度。</p>
<p>Spring AOP 就是基于<strong>动态代理</strong>的，如果要代理的对象，实现了某个<strong>接口</strong>，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p>
</li>
<li><p>​    通知(Advice):aop在切点上执行的增强处理。<br>​    切点(Pointcut):就是带有通知的连接点。<br>​    切面(Aspect):通常上就是一个类,里面定义了 通知和切点。<br>​    AOP=通知+切点</p>
<ul>
<li>应用场景：日志记录、事务管理、权限验证、性能检测</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Spring bean的生命周期</strong></p>
<p>实例化：实例化一个bean对象</p>
<p>属性赋值：为bean设置相关属性和依赖</p>
<p>初始化</p>
<p>销毁</p>
<p><strong>实例化阶段</strong><br>1.spring读取xml配置文件,容器就会调用doCreateBean方法进行实例化,底层是通过工厂+反射完成的创建<br>2.bean实例化后,进行bean对象属性填充<br>3.执行Aware接口的方法,spring会检查bean对象是否实现了Aware接口,通过Aware接口我们可以拿到spring为我们提供的一些资源,比如实现了BeanNameAware接口获取beanName,实现BeanFactoryAware接口可以获取工厂对象<br>.<br><strong>初始化阶段</strong><br>1.检查是否实现了BeanPostProcessor接口执行postProcessBeforeInitialization()对bean进行前置初始化<br>2.检查是否实现了InitializingBean接口如果实现了就调用afterPropertiesSet方法完成初始化 使用场景比如我们想在对象创建完之后调用其他bean对象的方法可以在afterPropertiesSet方法完成调用,<br>如果你是在构造方法里进行调用其他bean的对象或者在普通代码块调用都会出现空指针异常,这是因为你调用bean对象没有完成实例化,afterPropertiesSet方法是在所有bean对象完成实例化后进行执行的<br>3.检查是否实现了BeanPostProcessor后置处理接口执行ProcessAfterInitialization()方法,可以获取这个bean对象添加一些默认值的属性,甚至可以返回一个代理对象<br>.<br><strong>销毁阶段</strong><br>4.检查bean对象是否实现DisposbleBean接口调用destroy方法</p>
</li>
<li><p>spring mvc是怎么从url解析到具体的方法的？</p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
</li>
<li><p>mybatis传递参数？</p>
<p>传表名用${ }，传参用#{}，#相当于对数据 加上 单引号，可以防止sql注入，$相当于直接显示数据，</p>
</li>
<li><p>mybatis如何自增，设置主键</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​        优缺点？</p>
<ul>
<li>自增，趋势自增，可作为聚集索引，提升查询效率</li>
<li>节省磁盘空间。500W数据，UUID占5.4G,自增ID占2.5G.</li>
<li>查询，写入效率高：查询略优。写入效率自增ID是UUID的四倍。</li>
</ul>
<p>​        缺点：</p>
<ul>
<li>导入旧数据时，可能会ID重复，导致导入失败。</li>
<li>分布式架构，多个Mysql实例可能会导致ID重复。</li>
</ul>
<ol>
<li><p>IOC创建对象用的哪几种设计模式</p>
<ol>
<li><p>工厂模式：将将创建对象的责任转移到工厂类。</p>
</li>
<li><p>单例模式，<strong>Spring中bean的默认作用域就是singleton(单例)的</strong>  @Scope(value = “singleton”) scpoe: singleton、prototype、request、session、global-session  </p>
<p>Spring通过<code>ConcurrentHashMap</code>实现单例注册表的特殊方式实现单例模式。检查map中是否存在以beanname为key的对象，如果不存在，则添加到concurrenthashmap中（使用了synchronized锁住了对象），否则直接返回</p>
</li>
<li><p>策略模式：一个类的行为或其算法可以在运行时更改。Spring框架提供了一个InstantiationStrategy实例化策略接口，当实例化bean对象，在autowire方法中，其会获取当前factory中的InstantiationStrategy接口实现类，并调用instantiate方法来完成实例化，此时，便可以根据factory中不同的实现类完成不同的实例化策略，从而提高可扩展性。</p>
</li>
</ol>
</li>
<li><p>restcontroller=responsebody+controller</p>
</li>
<li><p>AOP有哪些实现类？</p>
</li>
<li><p>bean的作用域</p>
<p>singleton: 仅创建一个bean实例，ioc每次返回的都是同一个实例</p>
<p>prototype: 可见创建多个实例，每次返回的都是一个新的实例</p>
<p>request :每次http请求都会创建一个新的bean</p>
<p>session: 仅用于http session,同一个session共享一个bean实例，不同session使用不同实例</p>
<p>global-session: 在spring5.x中已删除</p>
</li>
<li><p>@Autowired  @Resource</p>
<p>@Autowird默认的注入方式为byType，也就是根据类型匹配，当有多个实现时，则通过byName注入，也可以通过配合@Qualifier注解来显式指定name值，指明要使用哪个具体的实现类</p>
<p>@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的<br>@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入<br>@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required=false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错</p>
</li>
<li><p>forward和redirect的区别</p>
<p>从<strong>url地址</strong>来说</p>
<p>forward：是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.</p>
<p>redirect:服务端根据逻辑,<strong>发送一个状态码</strong>,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p>
<p><strong>数据共享</strong>：</p>
<p>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p>
<p>从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>
<p><strong>运用地方</strong></p>
<p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>
</li>
<li><p>spring依赖注入有哪几种方式</p>
<ul>
<li><p>构造器注入：<strong>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖</strong>。</p>
<p>优点：<strong>对象初始化完成后便可获得可使用的对象</strong>；</p>
<p>缺点：<strong>当需要注入的对象很多时，构造器参数列表将会很长；不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;myStudent&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.bit.ba03.Student&quot;</span> &gt;</span><br><span class="line"> </span><br><span class="line">&lt;constructor-arg name=<span class="string">&quot;myage&quot;</span> value=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;constructor-arg name=<span class="string">&quot;mySchool&quot;</span> ref=<span class="string">&quot;myXueXiao&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;constructor-arg name=<span class="string">&quot;myname&quot;</span> value=<span class="string">&quot;周良&quot;</span>/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setter方法注入</p>
<p><strong>Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入</strong>；</p>
<p>优点：<strong>灵活。可以选择性地注入需要的对象</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;xx&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yyy.Id&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">&lt;property name=<span class="string">&quot;属性名字&quot;</span> value=<span class="string">&quot;此属性的值&quot;</span>/&gt;</span><br><span class="line"> </span><br><span class="line">一个property只能给一个属性赋值</span><br><span class="line"> </span><br><span class="line">&lt;property name=<span class="string">&quot;school&quot;</span> ref=<span class="string">&quot;mySchool&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol>
<li><p>手写单例模式</p>
<ol>
<li><p>饿汉式(线程安全，类加载时就初始化实例，在线程访问单例对象之前，其就已经创建好了。)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hunger</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Hunger instance = <span class="keyword">new</span> Hunger();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hunger</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hunger <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>懒汉式(线程不安全，实例对象在第一次被调用的时候才真正构建的)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双重校验锁（DCL）-针对懒汉式优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: DCL双检锁/双重校验锁（DCL，即 double-checked locking）线程安全，效率高</span></span><br><span class="line"><span class="comment"> * 区别于懒汉的加锁</span></span><br><span class="line"><span class="comment"> * dcl只锁创建单例，不锁获取单例，如果已经创建好了则不会加锁</span></span><br><span class="line"><span class="comment"> * @<span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> sujiaying</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/7/29 12:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DCL instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCL</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCL <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DCL.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问：为什么要有第二个if？<br>因为如果没有第二个if的话，在当前A线程获得锁的线程后可能有其他如B线程也在等待进入这个Class锁，A线程获取锁后创建实例，然后释放锁，之后<strong>等待池中的B线程获得锁</strong>，然后就会产生创建两个对象的错误情况。</p>
<p>问：instance为什么需要采⽤ volatile 关键字修饰？<br>instance采⽤ volatile 关键字修饰也是很有必要的，在上述代码中有下面这一句代码<br>instance= new DCL();<br>其实是分为三步执⾏的：<br>1.为 instance 分配内存空间</p>
<ol>
<li>初始化 instance</li>
<li>将 instance指向分配的内存地址<br> 但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。<br> *（例如，线程A 执⾏了 1 和3，此时线程B调⽤ getInstance() 后发现 instance不为空，因此返回instance，但此时instance还未被初始化。）<br> 使⽤ volatile 可以禁⽌ JVM 的指令重排 ，保证在多线程环境下也能正常运⾏。</li>
</ol>
</li>
<li><p>代理模式</p>
<p><strong>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p>代理模式有静态代理和动态代理两种实现，动态代理最常见的是JDK动态代理和GLIB动态代理</p>
<p>动态代理的核心是<strong>InvocationHandler接口</strong>和<strong>Proxy类</strong></p>
</li>
</ol>
</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><strong>内存淘汰策略</strong></p>
<p>volatile：从已设置过期时间的key中淘汰  allkeys:从键空间中淘汰</p>
<p>lru:最近最少使用  lfu:最不经常使用   random:随机淘汰</p>
<p>默认淘汰策略：noeviction:对于写请求不再提供服务，直接返回错误</p>
<p><strong>双写一致性</strong></p>
<p>两个更新：如果数据库更新失败或回滚，可能会造成并发更新导致的覆盖，或缓存更新成功，数据库更新失败导致的数据不一致</p>
<p>先删除缓存，后更新数据库  A写B读-&gt;a删缓存，b读，将数据加到缓存，a更新数据库。  读取的是脏数据。延时双删：（1）先淘汰缓存 （2）再写数据库（这两步和原来一样） （3）休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>先更新数据库，后删除缓存</p>
<p>消息队列解决删除缓存失败的问题</p>
<p><strong>多线程模型</strong></p>
<p>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，<strong>执行命令仍然是单线程顺序执行。</strong></p>
<ol>
<li>主线程获取 socket 放入等待列表</li>
<li>将 socket 分配给各个 <strong>IO 线程</strong>（并不会等列表满）</li>
<li>主线程阻塞等待 IO 线程（多线程）读取 socket 完毕</li>
<li><strong>主线程执行命令 - 单线程</strong>（如果命令没有接收完毕，会等 IO 下次继续）</li>
<li>主线程<strong>阻塞等待 IO 线程（多线程）将数据回写 socket 完毕</strong>（一次没写完，会等下次再写）</li>
<li>解除绑定，清空等待队列</li>
</ol>
<p><strong>哨兵模型</strong></p>
<p>哨兵可以监视一个或者多个redis <strong>master服务</strong>，以及这些master服务的所有<strong>从服务</strong>。 某个master服务宕机后，会把这个master下的某个从服务<strong>升级</strong>为master来替代已宕机的master继续工作。</p>
<p>分布式锁</p>
<p>setnx key test 当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败；</p>
<p>del key 当得到的锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式就是执行del指令。</p>
<p>expire</p>
<p><strong>如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？</strong></p>
<p>如果是读高并发的话，先看读并发的数量级是多少，因为Redis单机的读QPS在万级，每秒几万没问题，使用一主多从+哨兵集群的缓存架构来承载每秒10W+的读并发，主从复制，读写分离。</p>
<p>使用哨兵集群主要是提高缓存架构的可用性，解决单点故障问题。主库负责写，多个从库负责读，支持水平扩容，根据读请求的QPS来决定加多少个Redis从实例。如果读并发继续增加的话，只需要增加Redis从实例就行了。</p>
<h1 id="校园论坛项目"><a href="#校园论坛项目" class="headerlink" title="校园论坛项目"></a>校园论坛项目</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><ol>
<li><p>项目有四张表（loginticket保存在redis中）：评论、帖子、消息、用户</p>
</li>
<li><p>索引加了没有？创建索引的方法？</p>
<ul>
<li>创建表时创建</li>
</ul>
<p>index/key st_name(sname)</p>
<p>key/index (sname)</p>
<ul>
<li>create (unique)index index_name on table (column_name)</li>
</ul>
<p><strong>各个表的索引</strong></p>
<p>评论comment表   userid     entity_id</p>
<p>帖子表discuss_post      userid</p>
<p>消息表message   from_id  to_id   conversation_id</p>
<p>用户表user  username email</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `comment` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id` int(11) DEFAULT NULL,</span><br><span class="line">  `entity_type` int(11) DEFAULT NULL,</span><br><span class="line">  `entity_id` int(11) DEFAULT NULL,</span><br><span class="line">  `target_id` int(11) DEFAULT NULL,</span><br><span class="line">  `content` text,</span><br><span class="line">  `status` int(11) DEFAULT NULL,</span><br><span class="line">  `create_time` timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `index_user_id` (`user_id`) /*!80000 INVISIBLE */,</span><br><span class="line">  KEY `index_entity_id` (`entity_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>常用注解：</p>
<p>Component、Configuration、Repository、Service、Controller、RequestMapping、Responsebody、Value</p>
<p>Controller和RestController的区别？</p>
<p>restcontroller是controller和responsebody的合体，controlller可以通过返回string跳转到模板页面，也可以通过responsebody返回实体对象</p>
</li>
<li><p>如何开启事务？</p>
<p>在service层的方法上加上@Transactional注解，设置隔离级别为读取已提交（避免脏读问题），设置事务传播行为为REQUIRED(默认), 如果当前存在事务则加入该事务，否则创建新事务 </p>
</li>
<li><p>explain mysql</p>
<p>在select语句之前增加explain关键字，执行后MySQL就会返回执行计划的信息，而不是执行sql。但如果from中包含子查询，MySQL仍会执行该子查询，并把子查询的结果放入临时表中。用来查询是否命中索引等信息</p>
</li>
<li><p>springboot的核心配置文件？</p>
<p>application.properties   application.yml</p>
<p>使用方式？@Value注解</p>
</li>
<li><p><strong>怎么部署的？</strong></p>
<p>先使用jar -cvf xxx.jar进行打包</p>
<p>复制到对应目录</p>
<p>启动redis(6379)、kafka(9092)、nacos、zookeeper等</p>
<p>java -jar xxx.jar命令启动项目</p>
<p>tomcat端口：8080</p>
</li>
<li><p>异步请求controller</p>
<p>加上responsebody注解</p>
<p>使用fastjson工具类，封装了状态码（0）和消息对象（发布成功等），controller返回时返回这个封装好的对象</p>
</li>
</ol>
<h2 id="项目难点或亮点"><a href="#项目难点或亮点" class="headerlink" title="项目难点或亮点"></a>项目难点或亮点</h2><ol>
<li><p>帖子或评论敏感词过滤</p>
<p>步骤：</p>
<ul>
<li><p>定义前缀树</p>
<ul>
<li>主要有两个成员变量，关键词结束标志和子节点，在节点的数据结构中建立hashmap用于存储结构</li>
</ul>
</li>
<li><p>根据敏感词，初始化前缀树</p>
<ul>
<li><p>通过类加载器在classPath目录下获取资源.并且是以流的形式。<strong>（</strong>InputStream  数据流类</p>
<p>　一般来说，就是将字符串、管道数据（socket通倒）、文件、字节等转换为输入流，以流的方式去读取；</p>
<p>但是inputstream的读取速率较低，为了提高读取速率，一般将InputStream 交给 BufferedReader，然后调用BufferedReader的读取方法；BufferedReader 缓存阅读器，简单来说吧，就是通过BufferedReader，将要读取的数据调入缓冲区，这样读取效率就高了。<strong>）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;sensitive-words.txt&quot;</span>);</span><br><span class="line"><span class="comment">//字节流转字符流</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code> - 遍历字符串，取出字符

 - 若当前节点存在以c为key的子节点，指向子节点，进入下一轮循环

 - 若不存在，初始化子节点，并放入

 - 若达到敏感词结尾，设置关键词结束标志为true
</code></pre><ul>
<li><p>编写过滤敏感词的方法</p>
<p>定义3个指针，指针1为根节点，指针2为begin，指针3为position。</p>
<p>遍历字符串，如果遇到符号，符号在begin位置，23都加1，否则3加1.</p>
<p>检查前缀树中是否存在以begin位置所在字符开头的节点，若不存在，将其添加到结果中，postition和begin指向下一个位置，指针1节点归位，如果存在并且为关键词结束标识，将替换字符串(**)添加到结果中，begin从position下一位置开始，树节点归位</p>
<p>难点：</p>
<p>遇到敏感词为fabcd和abc，要检测的字符串最后一段为fabc<br>原来以指针3position作为循环判断条件，此时指针2为f，循环之后指针3为c，c不是fabcd的敏感词标志位节点，所以直接跳出了，<strong>没有检测f之后的字符作为begin的情况。</strong><br>所以要以指针2begin作为循环条件。</p>
</li>
</ul>
<ol>
<li>评论回复功能</li>
</ol>
<h2 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h2><p>Mybatis 获取自增主键？</p>
<p>若数据库支持自动生成主键（比如 MySQL 和 SQL Server），则可以设置 <strong>useGeneratedKeys=“true”，</strong>表明使用自增主键获取主键值策略，然后再利用 <strong>keyProperty</strong> 属性指定对应的主键属性，也就是 Mybatis 获取到主键值后，将这个值封装给 JavaBean 的哪个属性。</p>
<h2 id="登录验证码"><a href="#登录验证码" class="headerlink" title="登录验证码"></a>登录验证码</h2><p>使用了开源的谷歌的验证码库</p>
<p>生成验证码文本和图片，并存入redis和cookie（cookie再放入response中，返回给客户端）（因为属于敏感数据）中</p>
<p>登录时从cookie（@CookieValue注解）中取出，并与redis缓存中的数据进行对比</p>
<h2 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h2><p>点赞功能如何实现的？</p>
<p>前端传入点赞指向类型，指向类型id，指向类型的发布用户id(帖子、评论还是评论回复)</p>
<p>查询某用户是否给实体点赞了，用的set数据类型<strong>isMember</strong>方法，key为对应的实体类型和实体id组成的字段，查询对应的实体集合里是否有该用户的userid</p>
<p>开启事务</p>
<p>如果有</p>
<p>则取消点赞，将userid从实体集合里移除，并将该用户点赞数减一</p>
<p>否则添加到集合，并点赞数加1</p>
<p>结束事务</p>
<h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>邮箱功能用到了网络中的什么协议？</p>
<p>应用层的SMTP POP3</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>使用aop做了日志记录功能，用户在何时访问了哪些服务</p>
<p>定义一个切面类使用@Component、@Aspect注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span> <span class="comment">//指告诉切面类，通知方法在什么时候运行</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.ps.community.service.*.*(..))&quot;)</span> <span class="comment">//定义在service包里的任意方法的执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行顺序，编写before方法</span></span><br><span class="line"><span class="meta">@Before(&quot;pointCut&quot;)</span></span><br><span class="line"><span class="comment">//参数为joinpoint类</span></span><br><span class="line"><span class="comment">//从requestcontextholder类中取出request对象，再进一步取出用户的ip值，从joinpoint类中取出当前方法名</span></span><br><span class="line"><span class="comment">//logger.info()输出</span></span><br></pre></td></tr></table></figure>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ol>
<li>定义了三个继承了HandlerInterceptor类的自定义拦截器<ol>
<li><strong>统计网站uv和dau的拦截器</strong>： 从<strong>HttpServletRequest</strong>对象中取出<strong>ip</strong>值，调用redis中的<strong>hyperloglog</strong>存入ip值。从<strong>threadlocal</strong>中取出<strong>user</strong>对象，调用redis中的<strong>bitmap</strong>将<strong>userid</strong>存入对应的key中，设置状态为true</li>
<li><strong>登录拦截器</strong><ul>
<li>preHandle（handler调用前，首次登录存入）: 从HttpServletRequest对象中取出cookie，再从cookie中取出ticket值，根据ticket值找出loginticket对象，取出userid, 找到user对象，存入threadlocal。并存入springsecurity中的authentication对象，将此对象存入securtiycontextholder对象</li>
<li>postHandle(渲染之前，handler调用之后)：从threadlocal里取出user，存入modelandview，方便后续调用</li>
<li>aftercompletion(<strong>DispatcherServlet进行视图的渲染之后</strong>):清除threadlocal，防止内存泄漏</li>
</ul>
</li>
<li><strong>消息拦截器</strong>(统计用户未读消息总数)<ul>
<li>postHandle: 调用未读消息数量方法和未读私信数量方法，放入modelandview对象中</li>
</ul>
</li>
</ol>
</li>
<li>重写了preHandle、postHandle、afterCompletion方法</li>
</ol>
<p>并在继承了WebMvcConfigurer类的自定义配置类上，重写addInterceptor方法，调用registry对象进行注册拦截器，并过滤静态资源</p>
<h2 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h2><ol>
<li><p>redis在项目中主要用在哪些地方？</p>
<ul>
<li><strong>社交网络</strong>：与用户相关的一些操作如：点赞（Set、String,opsForValue）、关注（zset, add,remove,score为关注时间）等。社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。如在微博中的共同好友，通过Redis的set能够很方便得出。</li>
<li>保存用户登录凭证</li>
<li><strong>计数器</strong>：统计网站的uv(浏览用户数量，没有时间限制，一天内同一个用户多次访问只能算一次)和日活跃用户数量DAU（计算在一日之内，不重复的访问用户数量；）</li>
<li><strong>缓存</strong>：使用Redis作为缓存保存用户信息</li>
</ul>
</li>
<li><p>如何保证数据库和缓存双写时的一致性？</p>
<p>​    <strong>先更新数据库，再删除缓存</strong></p>
<p>​    可能存在的问题：比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p>
<p>解决方案：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.loli.net/2022/06/27/MsJjgWpG6DFvqoc.png" alt="image-20220627142602478"></p>
<p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p>
<ol>
<li>请求 A 先对数据库进行更新操作</li>
<li>在对 Redis 进行删除操作的时候发现报错，删除失败</li>
<li>此时将Redis 的 key 作为消息体发送到消息队列中</li>
<li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li>
</ol>
</li>
<li><p>统计网站的uv和日活跃用户DAU用到了什么数据结构？</p>
<p>uv和dau其实没多大区别，只是uv没有时间限制，dau指的是一天内</p>
<p>hyperloglog有一定误差0.81%，但对于统计UV这种不需要很精确的数据是可以忽略不计的。</p>
<ul>
<li><p>UV使用了HyperLogLog（ip）</p>
<p><strong>使用原因</strong>：如果使用set统计元素数量的方法, 当网站访问量过大是，占用内存过大。而hyperloglog是一种算法，访问在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数</strong>((不重复元素))</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String redisKey = RedisUtil.getUVKey(df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">redisTemplate.opsForHyperLogLog().add(redisKey, ip);</span><br></pre></td></tr></table></figure>
<p>指定范围内的uv，取到日期keylist，调用<strong>union</strong>方法，最后返回size大小</p>
</li>
<li><p>DAU使用了Bitmap(user, 只有用户登录了，代表活跃)，属于string数据类型</p>
<p>统计用户信息是否活跃，是否经常登录，两种状态的。Bitmap位图都是操作二进制来进行记录，只有0和1两个状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String redisKey = RedisUtil.getDAUKey(df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">redisTemplate.opsForValue().setBit(redisKey, userId, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>项目采用默认的<strong>RDB持久化方法</strong></p>
<p>细说AOF: 命令追加（将写指令追加到aof缓冲区，将缓冲区内容写入到aof文件，将文件保存到磁盘）</p>
</li>
</ol>
<h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><ol>
<li><p>在哪些地方用到了事务管理</p>
<p>添加评论模块</p>
<p>当多个用户对帖子添加评论时，可能会出现第一类丢失更新的问题（某一个事务的回滚，导致另一个事务已更新的数据丢失）</p>
<p>设置事务隔离级别：读取已提交，通过@Transactional关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="comment">//TransactionDefinition.PROPAGATION_REQUIRED：</span></span><br><span class="line">   如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="缓存设置"><a href="#缓存设置" class="headerlink" title="缓存设置"></a>缓存设置</h2><p><strong>redis缓存</strong>：缓存热点数据，指用户主页信息界面中的user信息以及右上角的头像信息，</p>
<p><strong>本地缓存：</strong>本地缓存是指将<strong>客户端本地的物理内存划分出一部分空间</strong>用来<strong>缓冲客户机回写到服务器的数据，如cookie等</strong></p>
<p>本地缓存是在<strong>同一个进程内的内存空间中缓存数据，数据读写都是在同一个进程内完成</strong>；而分布式缓存是一个独立部署的进程并且一般都是与应用进程部署在不同的机器，故需要通过网络来完成分布式缓存数据读写操作的数据传输。</p>
<p> 多级缓存机制</p>
<p>帖子列表使用本地缓存（caffine，底层使用concurrenthashmap）,使用<strong>@PostContrust</strong>注解，该注解修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。在spring中在autowired注解实现依赖注入之后调用。</p>
<p><strong>Caffine.buidler返回一个LoadingCache的map，在builder中重写load方法</strong></p>
<p>​    使用redis缓存存储用户信息(user对象），如果拦截器cookie里的ticket值不为空，根据ticket值去redis缓存中查找该ticket对象，若有则根据ticket对象中的userId去缓存找对应的user对象，如果没有再去数据库中找，并初始化缓存，找到后放到threadlocal的map里)</p>
<p>使用redis缓存存储用户登录凭证loginTicket</p>
<p>​    </p>
<h2 id="Elasticserach搜索"><a href="#Elasticserach搜索" class="headerlink" title="Elasticserach搜索"></a>Elasticserach搜索</h2><p>使用elasticsearch搜索帖子</p>
<ol>
<li><p>elasticsearch怎么实现的？实现关键点？</p>
<ol>
<li>自定义一个接口继承<strong>ElasticsearchRepository</strong></li>
<li>构建服务类导入自定义接口和elasticsearch模板</li>
<li>调用接口实现增删方法</li>
<li>构建nativesearchquery查询，设置相关属性。调用模板返回结果</li>
</ol>
<p>高亮显示关键词：使用nativesearchbuilder中的<strong>withhighlightField</strong>方法指定<strong>高亮字段</strong></p>
</li>
<li><p>elasticsearch查询为什么快？为什么不用mysql</p>
<p>mysql使用的b-tree 索引是为<strong>写入</strong>优化的索引结构。当我们不需要支持快速的更新的时候，可以用预先排序等方式换取更小的存储空间，更快的检索速度等好处，其代价就是更新慢，即倒排索引。</p>
<p>现在我们可以回答“为什么 Elasticsearch/Lucene 检索可以比 mysql 快了。Mysql 只有 term dictionary 这一层，是以 b-tree 排序的方式存储在磁盘上的。<strong>检索一个 term 需要若干次的 random access 的磁盘操作</strong>。而 Lucene 在 term dictionary 的基础上<strong>添加了 term index</strong> （这棵树不会包含所有的 term，它包含的是 term 的一些前缀。<strong>通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。</strong>再加上一些压缩技术（搜索 Lucene Finite State Transducers FST） term index 的尺寸可以只有所有 term 的尺寸的几十分之一，使得用内存缓存整个 term index 变成可能。）来加速检索，<strong>term index</strong> 以树的形式缓存在内存中。从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，<strong>大大减少了磁盘的 random access 次数。</strong></p>
</li>
<li><p>elasticsearch原理（倒排索引）</p>
<p>Elasticsearch分别为每个field都建立了一个倒排索引，Kate, John, 24, Female这些叫term，而 [1,2] 就是Posting List。Posting list就是一个int的数组，存储了所有符合某个term的文档id。通过posting list这种索引方式可以很快进行查找，比如要找age=24的人。</p>
<h4 id="Term-Dictionary"><a href="#Term-Dictionary" class="headerlink" title="Term Dictionary"></a>Term Dictionary</h4><p>Elasticsearch为了能快速找到某个term，将所有的term排序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。类似于传统数据库的B-Tree的，但是Term Dictionary较B-Tree的查询快。</p>
<h4 id="Term-Index"><a href="#Term-Index" class="headerlink" title="Term Index"></a>Term Index</h4><p>B-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过<strong>内存</strong>查找term，不读磁盘，但是如果term太多，term dictionary也会很大，放内存不现实，于是有了<strong>Term Index</strong>，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，term index其实是一颗 (trie) 前缀树：<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.loli.net/2022/07/18/g7IpiwYrVeB4unT.webp" alt="img"></p>
</li>
</ol>
<p>   这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。</p>
<p>   <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s2.loli.net/2022/07/18/jDoa3TIb2VmxM5f.webp" alt="img"></p>
<p>   所以term index不需要存下所有的term，而仅仅是他们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST(Finite State Transducers)的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。</p>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>功能：</p>
<ul>
<li>异步（接口的吞吐量会大幅度提高（因为未做真正实际调用，接口RT会非常低））</li>
<li>解耦</li>
<li>削峰（ 即便有大批量的消息调用接口都不会让系统受到影响（流量由消息队列承载））</li>
</ul>
<ol>
<li><p>kafka为什么吞吐量高呢？</p>
<ul>
<li><p>顺序读写</p>
<p>kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能，顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写。</p>
</li>
<li><p>零拷贝</p>
<p>减少拷贝次数，直接将文件数据发送到网卡上</p>
</li>
<li><p>分区</p>
<p>kafka中的topic中的内容可以被分为多个partition，每个partition又分为多段segment，所以每次操作都是针对一小部分做操作，很轻便，并且增加并行操作的能力。</p>
</li>
<li><p>批量发送</p>
<p>kafka允许进行批量发送消息，producer发送消息的时候，可以将消息缓存在本地，等到固定条件再发送到kafka</p>
<ul>
<li>消息条数满足固定条数</li>
<li>一段时间发送一次数据压缩</li>
</ul>
</li>
</ul>
</li>
<li><p>kafka如何保证数据可靠性(高可用）</p>
<p>Kafka的ack机制，指的是<strong>producer的消息发送确认机制</strong></p>
<p>在kafka中，<strong>每个主题可以有多个分区，每个分区又可以有多个副本。这多个副本中，只有一个是leader，而其他的都是follower副本。</strong>仅有leader副本可以对外提供服务。</p>
<p>kafka每个分区上的数据都会同步到其他机器，形成自己的几个副本。为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p>
<ul>
<li><p>副本数据同步策略： kafka用的策略为全部同步完成，发送ack</p>
</li>
<li><p>ISR</p>
<p> leader维护了一个集合（同步副本），和leader保持同步的follower集合。当ISR中的follower完成数据的同步之后，leader就会给生产者发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定（默认：10s）。</p>
<p>如果Leader发生故障，就会从ISR中选举新的leader</p>
</li>
<li><p>ack应答机制</p>
</li>
</ul>
</li>
</ol>
<pre><code> Kafka为用户提供了三种可靠性级别（acks参数）：

  acks：
               0：producer不等待broker的ack，直接发送下一条数据，提供了最低的延迟，broker一接受到还没写入磁盘，就已经返回，当broker故障时有可能丢失数据
               1：producer等待broker的ack，partition的leader确认接收后返回ack，如果在follower同步之前leader故障，将会丢失数据
              -1：producer等待broker的cak，partition的leader和follower全部落盘成功后才返回ack，但如果在follower同步完成后，broker发送ack之前，leader发生故障，那么将会造成数据重复。
</code></pre><ol>
<li><p>kafka选主机制</p>
<p>它在所有的broker中选出一个controller，所有的partition的leader选举都有controller决定。controller会将leader的改变直接通过RPC的方式（比zookeeper Queue的方式更高效）通知需要为此作为响应的broker。</p>
</li>
<li><p>消费者如何提高吞吐量（数据积压问题）</p>
<ul>
<li>增加分区数，不能大于broker数，大于时会出现无法消费数据的情况</li>
<li>多线程消费一个分区的数据，但需要手动维护每个分区的offset</li>
</ul>
</li>
<li><p>保证消息顺序性？</p>
<ul>
<li>设定topic有且只有一个分区（kafka只保证分区内有序）</li>
<li>多个分区时可以指定message key, 将key的hash值与topic的分区数取余得到对应分区，保证同一条数据会被分配到同一个分区内</li>
<li>为了保证一个消费者中多个线程去处理时，不会使得消息的顺序被打乱，则可以在消费者中，<strong>消息分发至不同的线程时，加一个队列，通过消息key，消费者去做hash分发</strong>，<strong>将具有相同key的数据，分发至同一个内存队列中</strong>，最后多个线程从队列中取数据。（写N个queue，将具有相同key的数据都存储在同一个queue，然后对于N个线程，每个线程分别消费一个queue即可。）</li>
</ul>
</li>
<li><p>消息丢失问题？</p>
<p>生产者端：设置消息应答重试机制，保证在生产端不会造成数据丢失</p>
<p>消费者端：auto.commit.enable=true，消费端自动提交offersets设置为true时，当消费者拉到消息之后还没有处理完而commit interval 提交间隔就到了，提交了offersets。这时consummer又挂了，重启后，从下一个offersets开始消费，之前的消息丢失了（设置auto.commit.enable=false 消费端手动提交，确保消息真的被消费并处理完成）</p>
</li>
<li><p>kafka订阅模式</p>
<p>指定分区、指定主题</p>
</li>
</ol>
<h2 id="帖子功能"><a href="#帖子功能" class="headerlink" title="帖子功能"></a>帖子功能</h2><ol>
<li><p>获取帖子</p>
<p>前端get请求，携带帖子id，controller使用pathvariable注解获得参数</p>
</li>
</ol>
<h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p>封装了一个page对象，里面有current当前页，每页条数limit, 总数rows，访问路径path。</p>
<p>getoffset方法：(current-1)*limit</p>
<p>获取总页数方法： rows/limit。</p>
<p>controller传入page对象,只有<strong>当前页数</strong>，设置对象参数</p>
<p>limit : 5</p>
<p>path：相对路径+帖子id</p>
<p>rows: 调用方法</p>
<h2 id="通知功能"><a href="#通知功能" class="headerlink" title="通知功能"></a>通知功能</h2><p>站内通知主要是系统通知，定义了一个事件类（topic、userid、entitytype、entityid、entityuserid、data）, 当handler触发<strong>评论或点赞或关注</strong>事件时，生成一个event对象，调用生产者类中的kafkatemplate.send方法发送消息（json序列化，JSONObject.toJSONString）到指定主题，在消费者端定义一个方法，该方法上有<strong>kafkalistener</strong>注解，监听指定topic上的事件，对传过来的记录解析成event对象，并从event对象中取出相关字段，封装到message对象中，然后将message添加到message表中。</p>
<h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>post方法传入comment类，请求url传入贴子id，补齐字段，添加评论，添加过程中使用@Tranactional注解，设置隔离级别为读已提交，事务传播行为为默认，然后插入评论及更新评论数量</p>
<h2 id="数据统计功能"><a href="#数据统计功能" class="headerlink" title="数据统计功能"></a>数据统计功能</h2><p>使用拦截器的prehandle方法获取用户的ip值，然后使用hyperloglog(add)，以当前日期为key，ip值为value添加，使用bitmap(<strong>opsForValue.setBit</strong>)，以日期为key，userid为value,状态为true</p>
<p>controller层，传入起始日期和终止日期，统计范围内的uv（使用Calendar工具类，每隔一天取出日期，转换到arraylistlist列表中,将天数里的value合并到一起，用union方法，最后返回总key的size）和dau(使用or运算)。</p>
<h2 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h2><p>刷新帖子分数</p>
<p>Quartz定时任务实现过程?</p>
<p>当<strong>评论或点赞的controller层中传过来的实体类型是帖子类型的话，</strong>事件触发时，将对应的帖子id存入redis的set集合中</p>
<ol>
<li><p>定义quartz配置类，定义jobdetail bean和trigger触发器bean（5分钟执行一次），注入到工厂中</p>
</li>
<li><p>定义实现了quartz的job接口的任务类，重写<strong>execute</strong>方法，从redis对应的set中依次取出（pop）所有postid</p>
<p>根据postId查询帖子，查询该帖子是否加精、评论数量及点赞数量，以此计算帖子分数，并更新到数据库中</p>
<p>分数计算规则：帖子权重+帖子距离天数</p>
</li>
</ol>
<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>这个spring security权限控制是怎么做的。</p>
<ol>
<li>因为没有使用security的登录认证，所以使用一个拦截器，在处理前查找cookie中是否有登录凭证，如果有根据登录凭证查找用户，定义authentication对象，保存用户相关信息，并存入SecurityContextHolder中方便后面配置类取出</li>
<li>定义一个配置类，继承自<strong>WebsecurityConfigureAdapter</strong>类。</li>
<li>重写<strong>configure</strong>方法，对不同访问路径设置不同权限</li>
<li>并配置没有登录及权限不够时的处理规则<ul>
<li>分为两种请求情况：没有登录时，若是ajax异步请求，使用json工具类封装一个json对象，里面包含403状态码及响应信息，并写到httpservletresponse里。若是普通请求，response.sendredirect重定向到登录页面</li>
</ul>
</li>
</ol>
<h2 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h2><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>
<p>分布式 Session 一般会有以下几种解决方案：</p>
<ul>
<li><p><strong>客户端存储</strong>：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息</p>
</li>
<li><p><strong>Nginx ip_hash 策略</strong>：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</p>
</li>
<li><strong>Session 复制</strong>：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li><strong>共享 Session</strong>：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ul>
<p>本项目使用redis存储用户的ticket（userid, status, 随机字符串， 过期时间），直接将ticket保存在cookie中的方法</p>
<h2 id="登录机制"><a href="#登录机制" class="headerlink" title="登录机制"></a>登录机制</h2><p>用户登录时生成一个类似session的loginticket登录凭证对象，该对象由userid, 状态码，ticket值，过期时间组成，将该对象存入redis中，登录成功后将ticket值存入cookie中，访问时通过拦截器查询ticket值找到ticket对象，如果不为空，根据ticket对象里的userid取出对应的user对象，并存入当前线程中，即threadlocal局部变量中，可以在同一线程中很方便的获取用户信息，方便后续访问</p>
<h2 id="后端如何传数据到前端"><a href="#后端如何传数据到前端" class="headerlink" title="后端如何传数据到前端"></a>后端如何传数据到前端</h2><p>使用ModelAndView+Map    使用HttpServletRequest    使用Model</p>
<h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="BIO-NIO"><a href="#BIO-NIO" class="headerlink" title="BIO NIO"></a>BIO NIO</h2><p>BIO: 线程等待某个条件，如果条件不满足，会一直等待下去，这个线程会阻塞住不能做其他操作</p>
<p>NIO: 线程等待某个条件，如果条件不满足,会直接返回-1，并去做其他的操作。</p>
<p>IO多路复用：程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”。</p>
<p>内核态：<strong>内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备</strong>，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况。</p>
<p>用户态:：用户态运行的程序只能受限地访问内存，<strong>只能直接读取用户程序的数据</strong>，<strong>并且不允许访问外围设备</strong>，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</p>
<h2 id="复用Channel怎么实现的？"><a href="#复用Channel怎么实现的？" class="headerlink" title="复用Channel怎么实现的？"></a>复用Channel怎么实现的？</h2><ol>
<li>定义一个concurrenthashmap存储channel对象，其中key为连接地址和序列化器代码的拼接字符串，值为channel对象</li>
<li>发送请求包时先判断map中是否有对应的channel对象，若有并且处于激活状态则直接返回</li>
<li>若未激活从map中移除该对象</li>
<li>初始化一个bootstrap，设置好handler, 调用connect方法，设置监听器addListener异步返回连接成功的channel对象</li>
<li>并放入map中</li>
</ol>
<p>设置一个静态方法，返回值为channel对象，并维护、一个ConcurrentHashMap用于存储channel对象，其中对象以连接地址和序列化器作为key存储，如果map中有并且channel处于激活状态则直接返回对象，如果没有则进行连接并生成一个channel对象并放入</p>
<p>为什么这么做？</p>
<ol>
<li>避免多次连接，生成多个channel消耗内存</li>
<li>方便其他方法直接获取通道，比如心跳检测</li>
</ol>
<p><strong>可配置怎么做的？</strong></p>
<p>调用不同的实例化方法</p>
<h2 id="请求包"><a href="#请求包" class="headerlink" title="请求包"></a>请求包</h2><p>发送的请求包含哪些信息？</p>
<p>请求序号、接口名、方法名、方法参数、参数类型、是否心跳包</p>
<h2 id="响应包"><a href="#响应包" class="headerlink" title="响应包"></a>响应包</h2><p>对应请求号、状态码、消息、返回数据</p>
<p>跟其他的 RPC 框架有作对比嘛，有哪些区别呢？  </p>
<h2 id="Netty粘包你是怎么解决的？"><a href="#Netty粘包你是怎么解决的？" class="headerlink" title="Netty粘包你是怎么解决的？"></a>Netty粘包你是怎么解决的？</h2><p>本质原因： <strong>TCP 是流式协议，消息无边界</strong></p>
<p>粘包原因？</p>
<ul>
<li>应用层<ul>
<li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
</ul>
</li>
<li>传输层-网络层<ul>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
<p>半包原因？</p>
<ul>
<li>应用层<ul>
<li>接收方 ByteBuf 小于实际发送数据量</li>
</ul>
</li>
<li>传输层-网络层<ul>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li>
</ul>
</li>
<li>数据链路层<ul>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<p><strong>你的RPC如何防止粘包半包？</strong></p>
<ol>
<li><p>客户端服务器端 防止nagle算法延迟发送<br>.childOption(ChannelOption.TCP_NODELAY, true)</p>
</li>
<li><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的，协议中包含数据长度，解码器继承自replayingdecoder，当缓冲区中没有足够的数据时，会抛出某种类型的一个Error。</p>
<p>网络波动呢？check方法</p>
</li>
</ol>
<p><strong>还可以有哪些方法？</strong></p>
<ol>
<li>短连接。<strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></li>
<li>定长解码器。客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong></li>
<li><strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的：行解码器、指定分隔符解码器</li>
</ol>
<h2 id="Rpc和Http的区别"><a href="#Rpc和Http的区别" class="headerlink" title="Rpc和Http的区别"></a>Rpc和Http的区别</h2><ol>
<li><p>http是协议、rpc是方法，rpc也可以基于http</p>
</li>
<li><p>http基于http协议，rpc基于tpc协议，也可以基于http协议</p>
</li>
<li><p>http中所使用的报文中<strong>有效字节数仅仅占约 30%</strong>，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。而rpc仅通过序列化发送有效数据，省去了很多无效的数据，提高传输效率。</p>
<p>http需要可读性强，包括输入、输出，解析等。rpc就像调用方法一样调用，很简单。</p>
</li>
<li><p>良好的rpc调用是<strong>面向服务</strong>的封装，针对服务的<strong>可用性</strong>和<strong>效率</strong>等都做了优化。单纯使用http调用则缺少了这些特性。</p>
<h2 id="自动注册具体是怎么做的？"><a href="#自动注册具体是怎么做的？" class="headerlink" title="自动注册具体是怎么做的？"></a>自动注册具体是怎么做的？</h2><p>自动注册方法在抽象类rpcserver上实现的 （成员变量对本包和其子类可见）</p>
</li>
<li><p>定义注解</p>
<p>service、servicescan</p>
<p>@Service 放在一个类上，标识这个类提供一个服务，@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围。</p>
</li>
<li><p>扫描服务</p>
</li>
</ol>
<p>​    首先调用Throwable.getStackTrace方法获取当前线程运行栈，并依此得到栈底的主方法的全限定类名，通过反射获取主方法class对象，判断是否存在servicescan注解，若存在则截取全限定类名获得包名，获得扫描的包的范围的所有class对象，逐个判断是否有service注解，如果有通过反射创建该对象（用于日志），并调用publishservice入服务名和服务地址进行注册</p>
<p>补充</p>
<ol>
<li><p>Nacos服务注册中心什么时候注册的服务？</p>
<p>服务器端初始化时，在 NettyServer 的构造方法最后，调用 scanServices 方法，即可自动注册所有服务：</p>
</li>
</ol>
<h2 id="自动注销怎么做的？"><a href="#自动注销怎么做的？" class="headerlink" title="自动注销怎么做的？"></a>自动注销怎么做的？</h2><p>用了一个钩子，将注销服务的方法写到关闭系统的钩子方法里</p>
<p>定义一个钩子类，并使用了单例模式创建了一个shutdownhook对象，在 该对象中的addClearAllHook方法 中，Runtime 对象是 JVM 虚拟机的运行时环境，调用其 Runtime.getRuntime.addShutdownHook 方法增加一个钩子函数，在其中创建一个新线程调用 注册中心工具类的clearRegistry 方法，以及关闭线程池中所有线程完成注销工作。这个钩子函数会在 JVM 关闭之前被调用。</p>
<p>最后在rpcserver启动之前注册addclearhook这个钩子</p>
<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="Netty的设计模式"><a href="#Netty的设计模式" class="headerlink" title="Netty的设计模式"></a>Netty的设计模式</h3><p>单例模式：MqtEncoder 保证独一无二</p>
<p>责任链模式：pipeline 一条链上处理各自任务</p>
<p>观察者模式：channel.writeAndFlush 任务完成时通知</p>
<h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><p>Netty默认线程模型是<strong>主从线程模型的改进</strong>，netty中定义了两个线程池：bossGroup和workerGroup（EventLoopGroup，有一个属性children为NioEventLoop[]）。线程池中的所有线程（NioEventLoop）都包含一个<strong>多路复用器</strong>（selector）。bossGroup中的线程用来监听连接建立（accept）的事件，workerGroup中的线程用来监听通道上的读写（read、write）事件。</p>
<p>当boss线程监听到accept事件，接受连接并创建channel，然后将channe<strong>l注册到一个worker线程</strong>中。worker线程不断的监听channel上的读写事件，当有事件发生时，会调用channel上的ChannelHandler进行处理。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><strong>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</strong></p>
<h3 id="Netty为什么选择NIO-NIO的好处-？介绍一下NIO"><a href="#Netty为什么选择NIO-NIO的好处-？介绍一下NIO" class="headerlink" title="Netty为什么选择NIO(NIO的好处)？介绍一下NIO"></a>Netty为什么选择NIO(NIO的好处)？介绍一下NIO</h3><p>三大组件：buffer、channel、selector</p>
<p>NIO的好处：为了处理BIO在等待客户端连接以及等待接收数据时的阻塞,并且不用为每一个客户端去创建线程，而是从线程池中获取线程资源来处理客户端任务，这样可以使用较少的线程来处理业务。</p>
<p><strong>非阻塞</strong>：非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</p>
<p><strong>网络中的非阻塞IO</strong>:  客户端将发送的连接请求注册到server中的selector中， selector会循环去判断哪些客户端发生了读、写事件，然后从线程池中获取资源去处理这些事件，处理完之后将线程放回线程池，等待下一次的读、写事件。</p>
<h3 id="心跳机制？"><a href="#心跳机制？" class="headerlink" title="心跳机制？"></a>心跳机制？</h3><p>Netty 的心跳机制是怎么实现的？   </p>
<ol>
<li>开启tcp底层心跳（.option(<strong>ChannelOption.SO_KEEPALIVE</strong>, true)）,缺点：udp用不了，默认为2小时灵活性不够</li>
<li><strong>应用层</strong>：服务端和客户端</li>
</ol>
<p>//5秒未发生读操作，触发事件IdleState.READ_IDLE</p>
<p>服务器端：pipeline上首先添加了一个<strong>IdleStateHandler</strong>(readerIdleTime(读超时时间):30,writerIdleTime（写超时时间）: 0, allIdleTime（写超时时间）: 0, TimeUnit.SECONDS)</p>
<p>再设置一个自定义handler，重写<strong>userEventTriggered</strong>方法，如果触发了<strong>IdleState.READ_IDLE事件</strong>，断开连接</p>
<p>客户端：pipeline上添加了一个IdleStateHandler(readerIdleTime(读超时时间):0,writerIdleTime（写超时时间）:30, allIdleTime（写超时时间）: 0, TimeUnit.SECONDS)</p>
<p>若5秒未发生写操作，触发事件IdleState.WRITE_IDLE</p>
<p>设置一个handler，重写事件触发方法，如果触发了IdleState.WRITE_IDLE事件，<strong>获取当前连接通道，new一个请求消息，设置消息为心跳包类型，调用channel.writeAndFlush写入通道</strong></p>
<p><strong>如果网络存在波动的话，现在的心跳机制可以解决吗？如果不行有什么优化思路？</strong>  </p>
<p>finally块中，断开连接后，重新调用客户端启动方法，客户端重连</p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>定义一个接口（实例列表，ip（客户端ip））</p>
<p>随机法、轮询法(顺序)、<strong>源地址哈希法</strong></p>
<p>源地址哈希法：</p>
<p>根据客户端ip得到哈希值并与实例列表大小进行取模运算，得到实例序号</p>
<p>优点：<strong>保证相同客户端ip哈希到同一服务器</strong>，可以利用<strong>此特性建立有状态的session会话</strong></p>
<p>缺点：如果服务器频繁上下线，不适合建立session</p>
<h2 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h2><p>组成：魔数、版本号、调用类型、序列化器、数据长度（防止粘包）</p>
<h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>   四种序列化协议的优缺点讲一下，为什么选择这四种序列化协议，依据是什么？</p>
<p>​    为什么使用kryo?</p>
<p>​    一是基于字节的序列化，对空间利用率较高，在网络传输时可以减小体积；二是序列化时记录属性对象的类型信息</p>
<h2 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h2><p>编码器继承自<strong>MessageToByteEncoder</strong>类（假定消息未被规范化）</p>
<p>写到比特缓存区内</p>
<p>自定义协议：魔数、版本号、消息类型（请求、响应）、序列化器类型、消息长度、消息</p>
<p>解码器继承自<strong>ReplayingDecoder</strong> 略慢于bytetomessagedecoder</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>四种序列化器（kryo、json、hessian、protobuf），默认<strong>Kryo</strong>（稳定且最快）</p>
<p>定义了一个序列化接口</p>
<p>（序列化器常量四种0123</p>
<p>根据代码获取序列化实例的方法(静态)</p>
<p>序列化、反序列化方法</p>
<p>获取序列化器代码）</p>
<p><strong>速度对比</strong>： protostuff &gt; kryo &gt; hassian &gt; json</p>
<p>序列化之后的占用空间，kryo略低于protostuff, 两者都远高于json.</p>
<p>protostuff（是protobuf的改良版本） 速度快   不支持无默认构造函数的类</p>
<p>kryo  速度快，序列化后体积小</p>
<p>Hessian 支持跨语言  较慢</p>
<h3 id="kryo"><a href="#kryo" class="headerlink" title="kryo"></a>kryo</h3><p>Kryo序列化机制比默认的Java序列化机制速度要快，序列化后的数据要更小，大概是Java序列化机制的1/10。所以Kryo序列化优化以后，可以让网络传输的数据变少，在集群中耗费的内存资源大大减少。</p>
<p> 缺点:</p>
<p>生成的byte数据中部包含field数据，对<strong>类升级</strong>的兼容性很差！所以，若用kryo序列化对象用于C/S架构的话，两边的Class结构要保持一致。</p>
<p>如果序列化之后，反序列化之前这段时间内，java class增加了字段（这在实际业务中是无法避免的事情），kyro就废了</p>
<p>使用：</p>
<p>使用了一个threadlocal，里面存储了<strong>kryo对象</strong>，threadlocal初始化时对kryo类进行注册，注册请求类的class对象以及响应类的class对象</p>
<p><strong>序列化和反序列化方法从threadlocalmap里取出kyro对象</strong>，并调用读写方法（read/write Object），并在<strong>结束时从threadlocal中移除kryo对象防止内存泄漏</strong></p>
<h3 id="Protostuff"><a href="#Protostuff" class="headerlink" title="Protostuff"></a>Protostuff</h3><p>优点：速度最快，对类升级兼容性较好</p>
<p>protostuff只要保证新字段添加在类的最后，而且用的是sun系列的JDK, 是可以正常使用的。</p>
<p>缺点：序列化后兼容空间略高于kryo</p>
<h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>使用的<strong>jackson</strong>工具包，</p>
<h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><p>Dubbo默认，优势为跨语言</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>注册中心的作用：存放和调度服务，提供服务注册、服务发现、服务删除等功能</p>
<p>nacos、zookeeper、eureka(springcloud使用的)</p>
<p>注册中心需要<strong>高可用</strong></p>
<p><strong>注册中心可配置？</strong></p>
<p>主要利用了多态的特性，定义一个rpc抽象类，在抽象类中定义一些变量以及服务注册类型，在子类构造器中初始化服务注册类</p>
<p><strong>Nacos和zookeeper的区别？</strong></p>
<p>1.zookeeper采用cp模式形式实现注册中心<br>2.Nacos默认采用AP模式，在1.0版本之后采用ap+cp模式混合实现注册中心。</p>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>一致性(Consistency)：多个副本之间的数据一致性</p>
<p>可用性(Availability)：保证每个请求不管成功或者失败都有响应</p>
<p>分区容错性(Partition tolerance)：在分区故障的情况下，仍然可以对外提供正常服务</p>
<p>Zookeeper:cp  (leader宕机后，在选举过程中，整个微服务无法通讯)</p>
<p>Nacos:ap+cp（默认情况下采⽤Ap保证服务可⽤性，CP形式底层采⽤Raft协议保证数据的⼀致性问题。如果选择为Ap模式，注册服务的<strong>实例仅⽀持临时模式</strong>，在⽹络分区的的情况允许注册服务实例。选择CP模式可以⽀持注册服务的实例为持久模式，在⽹络分区的产⽣了抖动情况下不允许注册服务实例。）</p>
<p>临时服务使用的是 Nacos 为服务注册发现场景定制化的私有协议 distro，其一致性模型是 AP；而持久化服务使用的是 raft 协议，其一致性模型是 CP</p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>使用了官方API</p>
<h4 id="nacos怎么知道注册到nacos中的微服务还存活？"><a href="#nacos怎么知道注册到nacos中的微服务还存活？" class="headerlink" title="nacos怎么知道注册到nacos中的微服务还存活？"></a>nacos怎么知道注册到nacos中的微服务还存活？</h4><p>Nacos 在 1.0.0版本 instance级别增加了一个ephemeral字段，该字段表示注册的实例是否是临时实例还是持久化实例。如果是临时实例，则不会在 Nacos 服务端持久化存储，需要通过上报心跳的方式进行保活，如果一段时间内没有上报心跳，则会被 Nacos 服务端摘除。在被摘除后如果又开始上报心跳，则会重新将这个实例注册。持久化实例则会持久化到Nacos 服务端，通过主动探知客户端健康的方式进行检测，此时即使注册实例的客户端进程不在，这个实例也不会从服务端删除，只会将健康状态设为不健康。</p>
<h4 id="Nacos作为注册中心，需要实现哪些功能"><a href="#Nacos作为注册中心，需要实现哪些功能" class="headerlink" title="Nacos作为注册中心，需要实现哪些功能"></a>Nacos作为注册中心，需要实现哪些功能</h4><p>服务注册、服务发现、服务删除</p>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>高可用怎么实现的？<strong>主从复制集群方式，主节点可进行读和写操作，从节只进行读操作。</strong></p>
<p>怎么做的注册中心？</p>
<p>用了一个工具API：ZkClient</p>
<p><strong>Zookeeper中的共识机制是一种改进型的Raft协议。称为ZAB协议。</strong></p>
<h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><p>半数机制（Paxos协议）：集群中只要有半数以上节点（最少3台）存活，Zookeeper集群就能正常服务</p>
<p>myid: 服务器id  zid：事务id, 用来标识一次服务器状态变更。在某一时刻，集群中的每台机器的zxid值不一定完全一致</p>
<p>epoch: 每个leader任期的代号，每投完一次票(当过一次leader)该数据会增加</p>
<p><strong>第一次选举</strong></p>
<p>假设有五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是<strong>最新启动</strong>的，也就是<strong>没有历史数据</strong>，在存放数据量这一点上，都是一样的，并且这些服务器是从1-5依序启动的。</p>
<p>​    1.  服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING；</p>
<ol>
<li>服务器2启动，再发起一次选举。服务器1和2分别投自己一票并<strong>交换选票</strong>信息：此时两台服务器的zxid相同，但是服务器1发现服务器2的myid比自己目前投票推举的（服务器1自己）大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上（3票）结果，选举无法完成，服务器1，2状态保持LOOKING；</li>
<li>服务器3启动，发起一次选举。同理此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</li>
<li>服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，<strong>不会更改选票信息</strong>。<strong>交换选票信息结果</strong>：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING，此时服务器3的票数为4票；</li>
<li>服务器5启动，同服务器4一样没得选择，只能当小弟，只能说生不逢时了。</li>
</ol>
<p><strong>leader故障时</strong></p>
<p>选举规则（交换选票结果时）</p>
<p>epoch&gt;zid&gt;mid</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>InetSocketAddress：封装ip+端口的一个类</p>
<p>实例节点为临时节点（会话失效就删除，下面不能创建子节点），服务名节点为持久节点（即使创建节点的客户端和 Zookeeper 服务端的会话失效(例如断开连接)，节点也不会被删除，只有客户端主动发起删除节点的请求，节点才会被删除。）</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>1.基于唯一节点特性实现;2. 基于顺序节点特性实现。</p>
<p><strong>唯一节点特性</strong></p>
<p>多个应用程序去抢占锁资源时，只需要在指定节点上创建一个 /Lock 节点，由于Zookeeper中节点的唯一性特性，使得只会有一个用户成功创建 /Lock 节点，剩下没有创建成功的用户表示竞争锁失败。</p>
<p>如下图所示，假设有非常多的节点需要等待获得锁，那么等待的方式自然是使用watcher机制来<strong>监听/lock节点的删除事件，</strong>一旦发现该节点被删除说明之前获得锁的节点已经释放了锁，那么此时剩下的B、C、D节点会同时收到删除事件从而去竞争锁，这个过程会产生惊群效应。</p>
<p>什么是“惊群效应”呢？简单来说就是如果存在许多的客户端在等待获取锁，当成功获取到锁的进程释放该节点后，所有处于等待状态的客户端都会被唤醒，这个时候<strong>zookeeper会在短时间内发送大量子节点变更事件给所有待获取锁的客户端，然后实际情况是只会有一个客户端获得锁</strong>。如果在集群规模比较大的情况下，会对zookeeper服务器的<strong>性能产生比较大的影响。</strong></p>
<p><strong>顺序节点特性</strong></p>
<p><strong>每个客户端都往指定的节点下注册一个临时有序节点，越早创建的节点，节点的顺序编号就越小，那么我们可以判断子节点中最小的节点设置为获得锁。</strong>如果自己的节点不是所有子节点中最小的，意味着还没有获得锁。这个的实现和前面单节点实现的差异性在于，<strong>每个节点只需要监听比自己小的节点，当比自己小的节点删除以后，客户端会收到watcher事件，此时再次判断自己的节点是不是所有子节点中最小的，如果是则获得锁</strong>，否则就不断重复这个过程，这样就不会导致羊群效应，因为每个客户端只需要监控一个节点。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">温泉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://ppnostalgia.github.io./c5576490.html">http://ppnostalgia.github.io./c5576490.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://PPnostalgia.github.io." target="_blank">温泉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200713_4526251967369630_5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/blog/configuration/wx.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/blog/configuration/wx.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/blog/configuration/zfb.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/blog/configuration/zfb.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/f828e852.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200713_4526251967369630_7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">读书笔记-置身事内</div></div></a></div><div class="next-post pull-right"><a href="/24598ec1.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200712_4526012039232020.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JAVA内存模型-JMM</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/809659da.html" title="Spring之AOP"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200703_4522715044512713_7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-11</div><div class="title">Spring之AOP</div></div></a></div><div><a href="/8614be8d.html" title="SpringBoot整合Elasticsearch"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200704_4522959068462027_3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-02</div><div class="title">SpringBoot整合Elasticsearch</div></div></a></div><div><a href="/3cd93342.html" title="Elasticsearch入门"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200704_4522959068462027_2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-23</div><div class="title">Elasticsearch入门</div></div></a></div><div><a href="/91a05199.html" title="Model和HttpRequest"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200703_4522715044512713_5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="title">Model和HttpRequest</div></div></a></div><div><a href="/9472c073.html" title="Mybatis常见问题"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200703_4522715044512713_3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-04</div><div class="title">Mybatis常见问题</div></div></a></div><div><a href="/a3b49bc.html" title="Spring之IOC"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200703_4522715044512713_1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-31</div><div class="title">Spring之IOC</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/configuration/avatar01.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">温泉</div><div class="author-info__description">欲买桂花同载酒，终不似，少年游</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://stats.uptimerobot.com/Nj9MXHZPOk"><i class="fa fa-cogs"></i><span>状态监控</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/PPnostalgia" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=fE1MTEtOSUhJT0Q8DQ1SHxMR" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a><a class="social-icon" href="https://PPnostalgia.blog.csdn.net" target="_blank" title="CSDN"><i class="fab fa-cuttlefish flat-btn"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"><span style="display:inline-block;text-indent:2em">愿你也被这个世界温柔以待</span></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%B9%A0%E9%A1%B9%E7%9B%AE"><span class="toc-text">实习项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-text">八股文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-text">场景题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git"><span class="toc-text">Git</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker"><span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-text">Linux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-text">Java基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">并发编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Autowired%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86"><span class="toc-text">Autowired注解自动注入原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-text">SpringBoot自动装配原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%A1%E5%9B%AD%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE"><span class="toc-text">校园论坛项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-text">基本问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9%E6%88%96%E4%BA%AE%E7%82%B9"><span class="toc-text">项目难点或亮点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE"><span class="toc-text">自增主键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-text">登录验证码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E8%B5%9E"><span class="toc-text">点赞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%AE%E7%AE%B1"><span class="toc-text">邮箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP"><span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-1"><span class="toc-text">Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">事务管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="toc-text">缓存设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Elasticserach%E6%90%9C%E7%B4%A2"><span class="toc-text">Elasticserach搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Term-Dictionary"><span class="toc-text">Term Dictionary</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Term-Index"><span class="toc-text">Term Index</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka"><span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%96%E5%AD%90%E5%8A%9F%E8%83%BD"><span class="toc-text">帖子功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD"><span class="toc-text">分页功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E5%8A%9F%E8%83%BD"><span class="toc-text">通知功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD"><span class="toc-text">评论功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD"><span class="toc-text">数据统计功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quartz"><span class="toc-text">Quartz</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Security"><span class="toc-text">Spring Security</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-Session"><span class="toc-text">分布式 Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%9C%BA%E5%88%B6"><span class="toc-text">登录机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E6%95%B0%E6%8D%AE%E5%88%B0%E5%89%8D%E7%AB%AF"><span class="toc-text">后端如何传数据到前端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E9%A1%B9%E7%9B%AE"><span class="toc-text">RPC项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO-NIO"><span class="toc-text">BIO NIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8Channel%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">复用Channel怎么实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8C%85"><span class="toc-text">请求包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%8C%85"><span class="toc-text">响应包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E7%B2%98%E5%8C%85%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-text">Netty粘包你是怎么解决的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rpc%E5%92%8CHttp%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Rpc和Http的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">自动注册具体是怎么做的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%B3%A8%E9%94%80%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84%EF%BC%9F"><span class="toc-text">自动注销怎么做的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty"><span class="toc-text">Netty</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">Netty的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">Netty的线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9NIO-NIO%E7%9A%84%E5%A5%BD%E5%A4%84-%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BNIO"><span class="toc-text">Netty为什么选择NIO(NIO的好处)？介绍一下NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-text">心跳机制？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE"><span class="toc-text">自定义协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-text">序列化方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-text">编解码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kryo"><span class="toc-text">kryo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protostuff"><span class="toc-text">Protostuff</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Json"><span class="toc-text">Json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hessian"><span class="toc-text">Hessian</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP"><span class="toc-text">CAP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nacos"><span class="toc-text">Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nacos%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E6%B3%A8%E5%86%8C%E5%88%B0nacos%E4%B8%AD%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%98%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-text">nacos怎么知道注册到nacos中的微服务还存活？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nacos%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AE%9E%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD"><span class="toc-text">Nacos作为注册中心，需要实现哪些功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zookeeper"><span class="toc-text">Zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-text">选举机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C"><span class="toc-text">注册</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">分布式锁</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/4868604a.html" title="Mysql Explain分析"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200721_4529163728584756_2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql Explain分析"/></a><div class="content"><a class="title" href="/4868604a.html" title="Mysql Explain分析">Mysql Explain分析</a><time datetime="2023-02-02T07:03:48.000Z" title="发表于 2023-02-02 15:03:48">2023-02-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/fa313643.html" title="Mysql查询优化"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200720_4528755479681167_7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql查询优化"/></a><div class="content"><a class="title" href="/fa313643.html" title="Mysql查询优化">Mysql查询优化</a><time datetime="2023-01-31T07:03:48.000Z" title="发表于 2023-01-31 15:03:48">2023-01-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/72b1017b.html" title="ElementUI笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200716_4527416531498087_9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElementUI笔记"/></a><div class="content"><a class="title" href="/72b1017b.html" title="ElementUI笔记">ElementUI笔记</a><time datetime="2022-11-14T06:20:34.000Z" title="发表于 2022-11-14 14:20:34">2022-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/6485e78d.html" title="基于Smartcloud项目学习Springcloud"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200716_4527416531498087_3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Smartcloud项目学习Springcloud"/></a><div class="content"><a class="title" href="/6485e78d.html" title="基于Smartcloud项目学习Springcloud">基于Smartcloud项目学习Springcloud</a><time datetime="2022-11-07T03:42:00.000Z" title="发表于 2022-11-07 11:42:00">2022-11-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/77519cd8.html" title="VO、DTO、PO"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200716_4527416531498087_2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="VO、DTO、PO"/></a><div class="content"><a class="title" href="/77519cd8.html" title="VO、DTO、PO">VO、DTO、PO</a><time datetime="2022-11-04T06:20:34.000Z" title="发表于 2022-11-04 14:20:34">2022-11-04</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/configuration/footer01.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 温泉</div><div class="footer_custom_text"><p><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><img class="icp-icon entered loading"src="/img/icp.png"alt="ICP"data-ll-status="loading">鲁ICP备2021040242号</a></p><p><a style="margin-inline:5px"target="_blank"href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo"title="博客框架为 Hexo"alt="HEXO"></a><a style="margin-inline:5px"target="_blank"href="https://github.com/jerryc127/hexo-theme-butterfly"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender"title="主题采用 Butterfly"alt="Butterfly"></a><a style="margin-inline:5px"target="_blank"href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr"title="本站使用 Jsdelivr 为静态资源提供CDN加速"alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank"href="https://github.com/PPnostalgia/blog-butterfly"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub"title="本站项目由 GitHub 托管"alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris"alt="img"title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web@latest/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web@latest/js/main.js"></script><script defer src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web@latest/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web@latest/js/search/algolia.js"></script><div class="js-pjax"><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'PPnostalgia/blog-comment')
  ele.setAttribute('issue-term', 'title')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  if (document.querySelector('.utterances-frame')) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    const iframe = document.querySelector('.utterances-frame');
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web@latest/js/nav_menu.js"></script><script src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web@latest/js/title.js"></script><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.aplayer',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: true,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', 'G-40VH67TNSM', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item swiper_container_card" style="height: auto;width: 100%"><div id="random"><div id="random-banner"><canvas id="peoplecanvas"></canvas></div><a id="random-hover" style="width:100%;height:auto;" href="javascript:toRandomPost()" rel="external nofollow noreferrer" one-link-mark="yes"><i class="fa fa-paper-plane" style="margin-left:10px"></i><div style="margin-left:10px">随便逛逛<i class="fa-solid fa-arrow-right" style="margin-left:10px"></i></div></a></div><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;4868604a.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/PPnostalgia/cdn_web/img/background/moviebg/20200721_4529163728584756_2.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;4868604a.html&quot;);" href="javascript:void(0);" alt="">Mysql Explain分析</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;4868604a.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper_init.js"></script><script data-pjax src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/gsap/3.9.1/gsap.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/people.min.js"></script><script async src="/anzhiyu/random.js"></script><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":0,"vOffset":0},"mobile":{"show":false},"rect":"opacity:0.9","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>