<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温泉</title>
  
  <subtitle>生活明朗，万物可爱</subtitle>
  <link href="http://ppnostalgia.github.io./atom.xml" rel="self"/>
  
  <link href="http://ppnostalgia.github.io./"/>
  <updated>2023-02-03T08:46:24.513Z</updated>
  <id>http://ppnostalgia.github.io./</id>
  
  <author>
    <name>温泉</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql Explain分析</title>
    <link href="http://ppnostalgia.github.io./4868604a.html"/>
    <id>http://ppnostalgia.github.io./4868604a.html</id>
    <published>2023-02-02T07:03:48.000Z</published>
    <updated>2023-02-03T08:46:24.513Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="查询慢的情形"><a href="#查询慢的情形" class="headerlink" title="查询慢的情形"></a>查询慢的情形</h2><ol><li>count 慢</li><li>order by xxx limit 1000000,10 （取最后页的慢）</li><li>like “%xxx”慢</li><li>没有合理建立索引慢</li><li>自动更新物理试图</li><li>….</li></ol><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖，不需要回表操作</p><p><strong>官方解释</strong></p><p>An <strong>index</strong> that includes all the columns retrieved by a query. Instead of using the index values as pointers to find the full table rows, the query returns values from the index structure, saving disk I/O. <code>InnoDB</code> can apply this optimization technique to more indexes than MyISAM can, because <code>InnoDB</code> <strong>secondary indexes</strong> also include the <strong>primary key</strong> columns. <code>InnoDB</code> cannot apply this technique for queries against tables modified by a transaction, until that transaction ends.</p><p>Any <strong>column index</strong> or <strong>composite index</strong> could act as a covering index, given the right query. Design your indexes and queries to take advantage of this optimization technique wherever possible.</p><p><strong>判断标准</strong><br>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为using index,MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT DISTINCT</span><br><span class="line">CONCAT( &#x27;航线运营&#x27;, DATE_FORMAT( s.CLOSING_MONTH, &#x27;%m&#x27; ), &#x27;月统计表&#x27; ) title,</span><br><span class="line">clc.LINE_NAM,</span><br><span class="line">&#x27;湖南远洋&#x27; AS com,</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">COUNT(DISTINCT sbcf.CNTR_NO ) </span><br><span class="line">FROM</span><br><span class="line">(select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null) sci1</span><br><span class="line">INNER JOIN ship s1 ON sci1.SHIP_ID = s1.SHIP_NO</span><br><span class="line">INNER JOIN ship_bill_cntr sbcf ON sci1.bill_id = sbcf.bill_id </span><br><span class="line">WHERE</span><br><span class="line">s1.LINE_COD = clc.LINE_COD </span><br><span class="line">AND sbcf.CNTR_EF_ID = &#x27;F&#x27; </span><br><span class="line">) 重箱量,</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">COUNT(DISTINCT sbce.CNTR_NO ) </span><br><span class="line">FROM</span><br><span class="line">(select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null) sci2</span><br><span class="line">INNER JOIN ship s2 ON sci2.SHIP_ID = s2.SHIP_NO</span><br><span class="line">INNER JOIN ship_bill_cntr sbce ON sci2.bill_id = sbce.bill_id </span><br><span class="line">WHERE</span><br><span class="line">s2.LINE_COD = clc.LINE_COD </span><br><span class="line">AND sbce.CNTR_EF_ID = &#x27;E&#x27; </span><br><span class="line">) 空箱量,</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">COUNT( DISTINCT s3.voyage_no ) </span><br><span class="line">FROM</span><br><span class="line">(select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null) sci3</span><br><span class="line">INNER JOIN ship s3 ON sci3.SHIP_ID = s3.SHIP_NO</span><br><span class="line">INNER JOIN ship_bill_cntr sbc3 ON sci3.bill_id = sbc3.bill_id </span><br><span class="line">WHERE</span><br><span class="line">s3.LINE_COD = clc.LINE_COD </span><br><span class="line">) 班次,</span><br><span class="line">CONCAT(</span><br><span class="line">round(</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">COUNT(DISTINCT sbc4.CNTR_NO ) </span><br><span class="line">FROM</span><br><span class="line">(select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null) sci4</span><br><span class="line">INNER JOIN ship s4 ON sci4.SHIP_ID = s4.SHIP_NO</span><br><span class="line">INNER JOIN ship_bill_cntr sbc4 ON sci4.bill_id = sbc4.bill_id </span><br><span class="line">WHERE</span><br><span class="line">s4.LINE_COD = clc.LINE_COD </span><br><span class="line">) / (</span><br><span class="line">SELECT</span><br><span class="line">SUM( bb.sum_accom ) </span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">s5.LINE_COD,</span><br><span class="line">s5.sum_accom </span><br><span class="line">FROM</span><br><span class="line">(select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null) sci5</span><br><span class="line">INNER JOIN ship s5 ON sci5.SHIP_ID = s5.SHIP_NO</span><br><span class="line">INNER JOIN ship_bill_cntr sbc5 ON sci5.bill_id = sbc5.bill_id </span><br><span class="line">GROUP BY</span><br><span class="line">s5.SHIP_NO </span><br><span class="line">) bb,</span><br><span class="line">cg_line_code cc </span><br><span class="line">WHERE</span><br><span class="line">bb.LINE_COD = cc.LINE_COD </span><br><span class="line">AND cc.LINE_COD = clc.LINE_COD </span><br><span class="line">)* 100,</span><br><span class="line">2 </span><br><span class="line">),</span><br><span class="line">&#x27;%&#x27; </span><br><span class="line">) 装载率,</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">COUNT(DISTINCT c.CNTR_NO ) </span><br><span class="line">FROM</span><br><span class="line">(select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null) a</span><br><span class="line">INNER JOIN ship b ON a.SHIP_ID = b.SHIP_NO</span><br><span class="line">INNER JOIN ship_bill_cntr c ON a.bill_id = c.bill_id</span><br><span class="line">INNER JOIN ship_bill d ON a.bill_id = d.bill_id </span><br><span class="line">WHERE</span><br><span class="line">b.LINE_COD = clc.LINE_COD </span><br><span class="line">AND d.BUSY_TYP IN ( &#x27;1&#x27;, &#x27;5&#x27;, &#x27;2&#x27;, &#x27;7&#x27; ) </span><br><span class="line">AND c.CNTR_EF_ID = &#x27;F&#x27; </span><br><span class="line">) 外贸,</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">COUNT(DISTINCT c.CNTR_NO ) </span><br><span class="line">FROM</span><br><span class="line">(select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null) a</span><br><span class="line">INNER JOIN ship b ON a.SHIP_ID = b.SHIP_NO</span><br><span class="line">INNER JOIN ship_bill_cntr c ON a.bill_id = c.bill_id</span><br><span class="line">INNER JOIN ship_bill d ON a.bill_id = d.bill_id </span><br><span class="line">WHERE</span><br><span class="line">b.LINE_COD = clc.LINE_COD </span><br><span class="line">AND d.BUSY_TYP IN ( &#x27;3&#x27;, &#x27;4&#x27;, &#x27;6&#x27;, &#x27;8&#x27; ) </span><br><span class="line">AND c.CNTR_EF_ID = &#x27;F&#x27; </span><br><span class="line">) 内贸 </span><br><span class="line">FROM</span><br><span class="line">cg_line_code clc</span><br><span class="line">LEFT JOIN ship s ON s.line_cod = clc.line_cod </span><br><span class="line">WHERE</span><br><span class="line">LINE_TYP = &#x27;0&#x27; </span><br><span class="line">AND s.CLOSING_MONTH= DATE_FORMAT(&#x27;2022-12-01&#x27;,&#x27;%Y-%m-%d&#x27;)</span><br></pre></td></tr></table></figure><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20230202141733346.png" alt="image-20230202141733346"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20230202141822849.png" alt="image-20230202141822849"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20230202141858534.png" alt="image-20230202141858534"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20230202141923014.png" alt="image-20230202141923014"></p><h2 id="结果字段解释"><a href="#结果字段解释" class="headerlink" title="结果字段解释"></a>结果字段解释</h2><p><strong>id</strong></p><p>SQL语句的执行顺序</p><p><strong>select_type(查询类型)</strong> </p><ul><li><p>simple: 最简单的查询，没有union和子查询</p></li><li><p>primary: 最外面的select,在有子查询的语句中，最外面的select查询就是primary</p></li><li><p>dependent subquery: 独立子查询，mysql会先对外层表进行全表扫描，然后根据返回的关联字段（如关联id）逐个进行子查询，在外表较大的情形下表现较糟糕。<strong>尽量改用连接查询</strong></p></li><li><p>derived: 包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含 义）</p><ul><li>```mysql<br>FROM<pre><code>    (select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#39;&#39; and ship_id is not null) a</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**table**</span><br><span class="line"></span><br><span class="line">查询对应的表名</span><br><span class="line"></span><br><span class="line">**partitions**</span><br><span class="line"></span><br><span class="line">基于分区表的话，会显示查询将现实的分区。</span><br><span class="line"></span><br><span class="line">**type**(重要)</span><br><span class="line"></span><br><span class="line">MySQL决定如何查找表中的行。依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all。</span><br><span class="line"></span><br><span class="line">- system、const:mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。system是 const的特例，表里只有一条元素匹配时为system</span><br><span class="line"></span><br><span class="line">- eq_ref:   当连接使用索引的所有部分时, 索引是主键或唯一非 NULL 索引时, 将使用该值。除 了 system 和 const 类型之外, 这是最好的联接类型。</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    SELECT</span><br><span class="line">    s5.LINE_COD,</span><br><span class="line">    s5.sum_accom </span><br><span class="line">    FROM</span><br><span class="line">    (select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null) sci5</span><br><span class="line">    INNER JOIN ship s5 ON sci5.SHIP_ID = s5.SHIP_NO</span><br><span class="line">    INNER JOIN ship_bill_cntr sbc5 ON sci5.bill_id = sbc5.bill_id </span><br><span class="line">    GROUP BY</span><br><span class="line">    s5.SHIP_NO </span><br></pre></td></tr></table></figure></li></ul></li><li><p>ref: 相比 eq_ref，不使用唯一索引，而是使用普通索引;</p><ul><li>```mysql<h3 id="INNER-JOIN-ship-bill-cntr-sbcf-ON-sci1-bill-id-sbcf-bill-id-普通索引"><a href="#INNER-JOIN-ship-bill-cntr-sbcf-ON-sci1-bill-id-sbcf-bill-id-普通索引" class="headerlink" title="INNER JOIN ship_bill_cntr sbcf ON sci1.bill_id = sbcf.bill_id  普通索引"></a>INNER JOIN ship_bill_cntr sbcf ON sci1.bill_id = sbcf.bill_id  普通索引</h3>SELECT<pre><code>    COUNT(DISTINCT sbcf.CNTR_NO ) FROM    (select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#39;&#39; and ship_id is not null) sci1    INNER JOIN ship s1 ON sci1.SHIP_ID = s1.SHIP_NO    INNER JOIN ship_bill_cntr sbcf ON sci1.bill_id = sbcf.bill_id WHERE    s1.LINE_COD = clc.LINE_COD     AND sbcf.CNTR_EF_ID = &#39;F&#39; </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- range:  这个连接类型使用索引返回一个范围中的行，比如使用&gt;或&lt;查找东西时发生的情况</span><br><span class="line"></span><br><span class="line">  - ```mysql</span><br><span class="line">    select distinct bill_id,ship_id from ship_cntr_info where ship_id != &#x27;&#x27; and ship_id is not null</span><br></pre></td></tr></table></figure></li></ul></li><li><p>all :  全表扫描，子查询情况下外表全表扫描</p></li></ul><p><strong>possible keys</strong></p><p>​    显示查询可能使用哪些索引来查找。 explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提 高查询性能，然后用 explain 查看效果。</p><p><strong>key</strong></p><p>显示mysql实际采用哪个索引来优化对该表的访问。 如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。通常在未覆盖索引的情况下使用强制索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from ws_shop a force index(create_time)</span><br><span class="line">where date(create_time-interval 6 hour) &gt; &#x27;2016-10-01 06:00:00&#x27;</span><br></pre></td></tr></table></figure><p><strong>key_len</strong></p><p>mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p><p><strong>ref</strong></p><p>key列对应的字段</p><p><strong>rows</strong></p><p>mysql估计要读取并检测的行数，注意这个不是结果集里的行</p><p><strong>filtered</strong></p><p>返回的结果行数占需要读取行数的比例。Filtered列的值越大越好，Filtered列的值依赖于统计信息。</p><p><strong>Extra</strong></p><ul><li><p>Using index</p><ul><li><p>表示相应的select操作中使用了<strong>覆盖索引(Covering Index)</strong>，避免访问了表的数据行，<strong>效率不错</strong>！</p></li><li><p>如果同时出现using where，表明索引被用来执行索引键值的查找;</p></li><li><p>如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INNER JOIN ship_bill_cntr sbc3 ON sci3.bill_id = sbc3.bill_id </span><br></pre></td></tr></table></figure></li></ul></li><li><p>Using Where</p><ul><li>表明使用了where过滤, 在查找使用索引的情况下，需要回表去查询所需的数据</li></ul></li><li><p>Using temporary</p><p>表示由于排序没有走索引、使用union、子查询连接查询、使用某些视图等原因。因此<strong>创建了一个内部临时表</strong>。注意这里的临时表可能是内存上的临时表，也有可能是硬盘上的临时表，理所当然基于内存的临时表的时间消耗肯定要比基于硬盘的临时表的实际消耗小。</p></li><li><p>Using index condition</p><p>确实命中了索引，但不是所有的列数据都在索引树上，还需要访问实际的行记录。</p></li><li><p>Using join buffer (Block Nested Loop)</p><p>需要进行嵌套循环计算。典型的，两个关联表join，关联字段均未建立索引，就会出现这种情况。常见的优化方案是，在关联字段上添加索引，避免每次嵌套循环计算。</p><ul><li>```mysql<h3 id="ship的line-cod-没有建立索引"><a href="#ship的line-cod-没有建立索引" class="headerlink" title="ship的line_cod 没有建立索引"></a>ship的line_cod 没有建立索引</h3>FROM<pre><code>cg_line_code clcLEFT JOIN ship s ON s.line_cod = clc.line_cod </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Using file_sort</span><br><span class="line"></span><br><span class="line">  Extra为Using filesort说明，得到所需结果集，需要对所有记录进行文件排序。这类SQL语句性能极差，需要进行优化。典型的，在一个没有建立索引的列上进行了order by，就会触发filesort，常见的优化方案是，在order by的列上添加索引，避免每次查询都全量排序。</span><br><span class="line"></span><br><span class="line">  ```mysql</span><br><span class="line">  select * from user order by sex;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Mysql" scheme="http://ppnostalgia.github.io./categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://ppnostalgia.github.io./tags/Mysql/"/>
    
    <category term="索引" scheme="http://ppnostalgia.github.io./tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql查询优化</title>
    <link href="http://ppnostalgia.github.io./fa313643.html"/>
    <id>http://ppnostalgia.github.io./fa313643.html</id>
    <published>2023-01-31T07:03:48.000Z</published>
    <updated>2023-02-02T02:28:08.310Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>2023年1月更新：</p><ol><li><p><strong>提取终止查询</strong>：遇到<strong>全表扫描</strong>的情况（如未命中索引等），如果<strong>只需要一条数据</strong>，可以用limit 1，只要找到了一条对应的记录，就不会继续向下扫描了。分页类似。</p></li><li><p>尽量减少不必要的列查询，减少磁盘读取与网络传输字节</p><ol><li>如使用关联表时，关联表中有很多字段，可以写临时表，只将需要的关联字段写进临时表中，因为mysql是行式存储，一次加载行内所有数据，返回过多的列会给服务器带来额外的I/O、内存和CPU消耗。</li></ol></li><li><p><strong>子查询优化</strong>：mysql子查询的性能非常糟糕(百万级别没问题，如有问题，可能是索引失效或区分度低，强制使用索引或更换关联字段)，能不用尽量不用，MySQL会将相关的外层表压到子查询中，他认为这样可以更高效率的查找数据行，MySQL<strong>先选择对外层表进行全表扫描</strong>，然后<strong>根据返回的关联id逐个执行子查询</strong>。如果外层的表是一个非常大的表，那么这个查询的性能会非常糟糕。<strong>尽可能使用关联查询代替</strong></p></li><li><p><strong>强制使用索引</strong>：如果字段加了索引，而where又破坏了索引，可以强制使用索引,目的是对目标表添加最关键的索引，使其优先使用该索引筛选数据；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from ws_shop a force index(create_time)</span><br><span class="line">where date(create_time-interval 6 hour) &gt; &#x27;2016-10-01 06:00:00&#x27;</span><br></pre></td></tr></table></figure></li><li><p>尽量避免重复查询相同的数据，可以缓存</p></li><li><p>横向：将大查询切分成小查询，每个查询功能完全一样，<strong>只完成一小部分</strong>，每次只返回一部分查询结果。减少加锁的事务。<strong>比如按照不同的创建时间等，依次每段时间内的数据</strong>。</p></li><li><p>优化关联查询：</p><ol><li>纵向：<strong>分解关联查询</strong>，将查询分解后，<strong>执行单个查询</strong>可以减少锁的竞争</li><li>确保on的列上有索引</li><li>确保任何的GROUP BY和ORDER BY中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化这个过程。</li></ol></li><li><p>联合索引中，区分度大 Cardinality 的放左边</p></li><li><p>mysql优化不动了时，上clickhouse</p></li></ol><h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><ol><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li><li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li><li>order by limit 形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建索引的几大原则</li><li>观察结果，不符合预期继续从0分析</li></ol><h1 id="常用优化策略"><a href="#常用优化策略" class="headerlink" title="常用优化策略"></a>常用优化策略</h1><ul><li>尽量避免会使索引失效的操作（如查询需符合<strong>最左匹配</strong>原则，like或函数查询字段会使索引失效）</li><li>在<strong>区分度高</strong>的列上建索引，否则当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</li><li>索引并不是越多越好，<strong>索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，一个表的索引数最好不要超过6个</strong></li><li>避免使用select *，易导致全表扫描</li><li>count(1)或count(列) 代替 count(*)</li><li>创建表时尽量时 varchar 代替 char</li><li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。   </li><li><strong>尽量避免向客户端返回大数据量，若数据量过大</strong>，应该考虑相应需求是否合理。</li><li>表的字段顺序固定长度的字段优先</li><li>组合索引代替多个单列索引（经常使用多个条件查询时）</li><li>尽量使用短索引</li><li>使用连接（JOIN）来代替子查询(Sub-Queries)</li><li>连表时注意条件类型需一致</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Mysql" scheme="http://ppnostalgia.github.io./categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://ppnostalgia.github.io./tags/Mysql/"/>
    
    <category term="索引" scheme="http://ppnostalgia.github.io./tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>ElementUI笔记</title>
    <link href="http://ppnostalgia.github.io./72b1017b.html"/>
    <id>http://ppnostalgia.github.io./72b1017b.html</id>
    <published>2022-11-14T06:20:34.000Z</published>
    <updated>2023-01-31T06:20:38.473Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element-UI"></a>Element-UI</h1><h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><ol><li><p>validate（）时elment-ui封装好的用于对整个表单进行验证<br>validate的参数是一个回调函数。该回调函数在校验结束后被调用，是否校验成功和未通过校验的字段。<br>若不传入回调函数，则会返回以promise<br>参数：Function( callback : Function( boolean,obj ) )</p><p>通常搭配必填项使用</p><p>Form 组件提供了表单验证的功能，只需要通过 <code>rules</code> 属性传入约定的验证规则，并将 Form-Item 的 <code>prop</code> 属性设置为需校验的字段名即可。</p></li><li><p>@click.native.prevent</p></li></ol><p>在 Vue 2.0 中，为<strong>自定义</strong>组件绑定<strong>原生</strong>事件必须使用 <code>.native</code> 修饰符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component @click.native=<span class="string">&quot;handleClick&quot;</span>&gt;Click Me&lt;/my-component&gt;</span><br></pre></td></tr></table></figure><ol><li><p>获取某行数据</p><ol><li><p>当写后台管理页面时，使用element ui里的table表格时，表格中有操作按钮，获取当前行的数据时，我们可以使用 slot-<a href="https://so.csdn.net/so/search?q=scope&amp;spm=1001.2101.3001.7020">scope</a>=”scope”来获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;el-table-column label=&quot;操作&quot; align=&quot;center&quot; prop=&quot;auditStatus&quot; width=&quot;180&quot; fixed=&quot;right&quot;&gt;</span><br><span class="line">      &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">       &lt;el-button type=&quot;text&quot; size=&quot;large&quot; @click=&quot;audit(scope.row)&quot;&gt;审核&lt;/el-button&gt;</span><br><span class="line">       &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果要实现的功能是在表头上了，例如图里的批量审核，那要怎么获取当前前勾选的这一行的数据呢？这时我们可以用表格中提供的@selection-change=”handleSelectionChange” 的multipleSelection来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-table</span><br><span class="line">    ref=&quot;multipleTable&quot;</span><br><span class="line">    :data=&quot;tableData3&quot;</span><br><span class="line">    tooltip-effect=&quot;dark&quot;</span><br><span class="line">    style=&quot;width: 100%&quot;</span><br><span class="line">    @selection-change=&quot;handleSelectionChange&quot;&gt;</span><br><span class="line">    &lt;el-table-column</span><br><span class="line">      type=&quot;selection&quot;</span><br><span class="line">      width=&quot;55&quot;&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;title&quot; label=&quot;作品名称&quot; align=&quot;center&quot; width=&quot;160&quot;&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;count&quot; label=&quot;作品数量&quot; align=&quot;center&quot; min-width=&quot;160&quot;&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">    &lt;el-table-column prop=&quot;price&quot; label=&quot;作品价格&quot; align=&quot;center&quot; min-width=&quot;160&quot;&gt;</span><br><span class="line">    &lt;/el-table-column&gt;</span><br><span class="line">  &lt;/el-table&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    multipleSelection:[]</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">//获取所有选择的项</span><br><span class="line">    handleSelectionChange(val) &#123;</span><br><span class="line">    console.log(val)</span><br><span class="line">      this.multipleSelection = val;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">&lt;el-form-item&gt;</span><br><span class="line">        &lt;el-button type=&quot;primary&quot; @click=&quot;batchTransferTip()&quot;&gt;批量审核&lt;/el-button&gt;</span><br><span class="line">&lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">    //批量审核</span><br><span class="line">    batchTransferTip() &#123;</span><br><span class="line">      if (this.multipleSelection.length == 0) &#123;</span><br><span class="line">        this.common.messageTip(&quot;请选择要审核的作品&quot;, &quot;error&quot;);</span><br><span class="line">        return false;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.editboxName = &quot;verify&quot;;</span><br><span class="line">        let planIdList = [];</span><br><span class="line">    //遍历数据</span><br><span class="line">        for (let item of this.multipleSelection) &#123;</span><br><span class="line">          planIdList.push(item.id);</span><br><span class="line">        &#125;</span><br><span class="line">        this.propData.id = planIdList;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><ol><li><p>动态显示不同文字按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=&quot;text&quot; :style=&#x27;&#123;&quot;width&quot;:&quot;40%&quot;&#125;&#x27;  @click=&quot;isprocess(scope.row.ship_id)&quot; &gt;&#123;&#123;scope.row.isProcess==1?&#x27;取消审核&#x27;:&#x27;审核&#x27;&#125;&#125;</span><br><span class="line">                                        &lt;/el-button&gt;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>居中显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align: -webkit-center&quot;&gt;</span><br><span class="line">  &lt;el-form ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; style=&quot;width: max-content&quot;&gt;</span><br><span class="line">    &lt;el-form-item label-width=&quot;0&quot;&gt;</span><br><span class="line">      &lt;el-button&gt;确认&lt;/el-button&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h1><ol><li><p>vue项目中element-ui两个时间选择器的判断开始时间不大于结束时间</p><ul><li><p>添加:picker-options=”方法名”</p></li><li><p>```js</p><template>  <div>    <el-form ref="form" :model="form" label-width="80px">      <el-form-item label="活动时间">        <el-col :span="11">          <el-date-picker            type="date"            value-format="yyyy-MM-dd"            placeholder="选择日期"            v-model="form.startDate"            :picker-options="pickerOptions"            style="width: 100%;"            @change="changeData(true)"          ></el-date-picker>        </el-col>        <el-col class="line" :span="2">-</el-col>        <el-col :span="11">          <el-date-picker            type="date"            value-format="yyyy-MM-dd"            placeholder="选择日期"            v-model="form.endDate"            :picker-options="pickerOptions"            style="width: 100%;"            @change="changeData(false)"          ></el-date-picker>        </el-col>      </el-form-item>    </el-form>  </div></template><p><script></p><pre><code>export default &#123;  data() &#123;    return &#123;      form: &#123;        startDate: &quot;&quot;, // 开始时间        endDate: &quot;&quot; // 结束时间      &#125;,      pickerOptions: &#123;        disableDate: time =&gt; &#123;          return time.getTime() &gt; Date.now();        &#125;      &#125;    &#125;;  &#125;,  methods: &#123;    changeData(flag) &#123;      if (flag) &#123;        if (this.form.endDate) &#123;          if (this.form.startDate &gt; this.form.endDate) &#123;            this.form.startDate = null;            this.$message.error(&quot;开始时间不能大于结束时间！&quot;);          &#125;        &#125;      &#125; else &#123;        if (this.form.startDate) &#123;          if (this.form.startDate &gt; this.form.endDate) &#123;            this.form.endDate = null;            this.$message.error(&quot;结束时间不能小于开始时间！&quot;);          &#125;        &#125;      &#125;    &#125;  &#125;&#125;;</code></pre><p>&lt;/script&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 文件</span><br><span class="line"></span><br><span class="line">**先验知识**</span><br><span class="line"></span><br><span class="line">XSS攻击：“XSS是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 上传文件</span><br><span class="line"></span><br><span class="line">一般分为三步：上传文件——&gt;数据预览——&gt;导入数据  对应后端三个接口</span><br><span class="line"></span><br><span class="line">```vue</span><br><span class="line">&lt;el-steps :active=&quot;active&quot; align-center&gt;</span><br><span class="line">        &lt;el-step title=&quot;上传文件&quot;&gt;&lt;/el-step&gt;</span><br><span class="line">        &lt;el-step title=&quot;数据预览&quot;&gt;&lt;/el-step&gt;</span><br><span class="line">        &lt;el-step title=&quot;导入数据&quot;&gt;&lt;/el-step&gt;</span><br><span class="line">  &lt;/el-steps&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ImportData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/ShipManage/ship/ImportData&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导入预览</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ImportPreview</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/ShipManage/ship/ImportPreview&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模板下载</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">TemplateDownload</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/ShipManage/ship/TemplateDownload&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><ol><li><p>模板下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;up_right&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;title&quot;&gt;填写导入船舶信息&lt;/p&gt;</span><br><span class="line">            &lt;p class=&quot;tip&quot;&gt;请按照数据模板的格式准备导入数据，模板中的表头名称不可更改，表头行不能删除&lt;/p&gt;</span><br><span class="line">            &lt;el-button type=&quot;text&quot; @click=&quot;templateDownload&quot;&gt;下载模板&lt;/el-button&gt;</span><br><span class="line">          &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取文件地址后点击元素跳转该地址</span></span><br><span class="line"><span class="function"><span class="title">templateDownload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        TemplateDownload().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.jnpf.downloadFile(res.data.url)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">downloadFile</span>(<span class="params">url, name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!url) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> baseUrl = url.indexOf(<span class="string">&#x27;http&#x27;</span>) &gt; -<span class="number">1</span> ? <span class="string">&#x27;&#x27;</span> : define.comUrl</span><br><span class="line">    <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    a.setAttribute(<span class="string">&#x27;download&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> realUrl = baseUrl + url + (name ? <span class="string">&#x27;&amp;name=&#x27;</span> + name : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    a.setAttribute(<span class="string">&#x27;href&#x27;</span>, realUrl)</span><br><span class="line">    <span class="comment">//点击该元素，跳转到指定文件地址即可下载</span></span><br><span class="line">    a.click()</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回下载地址</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/TemplateDownload&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;DownloadVO&gt;  <span class="title">TemplateDownload</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserInfo userInfo=userProvider.get();</span><br><span class="line">        DownloadVO vo=DownloadVO.builder().build();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            vo.setName(<span class="string">&quot;船舶信息.xlsx&quot;</span>);</span><br><span class="line">            <span class="comment">//附件名称处理</span></span><br><span class="line">            vo.setUrl(UploaderUtil.uploaderFile(<span class="string">&quot;/api/Common/DownloadModel?encryption=&quot;</span> ,userInfo.getId()+<span class="string">&quot;#&quot;</span>+<span class="string">&quot;船舶信息.xlsx&quot;</span>+<span class="string">&quot;#&quot;</span>+<span class="string">&quot;Temporary&quot;</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;信息导出Excel错误:&#123;&#125;&quot;</span> ,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ActionResult.success(vo);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@NoDataSourceBind()</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;下载模板文件链接&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/DownloadModel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadModel</span><span class="params">()</span> <span class="keyword">throws</span> DataException </span>&#123;</span><br><span class="line">        HttpServletRequest request = ServletUtil.getRequest();</span><br><span class="line">        String reqJson = request.getParameter(<span class="string">&quot;encryption&quot;</span>);</span><br><span class="line">        String fileNameAll = DesUtil.aesDecode(reqJson);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtil.isEmpty(fileNameAll)) &#123;</span><br><span class="line">            String token = fileNameAll.split(<span class="string">&quot;#&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (redisUtil.exists(token)) &#123;</span><br><span class="line">                String fileName = fileNameAll.split(<span class="string">&quot;#&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">                String filePath = configValueUtil.getTemplateFilePath();</span><br><span class="line">                <span class="comment">//写入输出流</span></span><br><span class="line">                UploadUtil.downFile(configValueUtil.getFileType(), fileName, FileTypeEnum.TEMPLATEFILE, filePath, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downFile</span><span class="params">(String type, String fileName, String bucketName, String filePath, String downName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="comment">//Minio存储</span></span><br><span class="line">            <span class="keyword">case</span> StorageType.MINIO:</span><br><span class="line">                minioUploadUtil.downFile(fileName, bucketName.toLowerCase(), downName);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//本地存储</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (StringUtil.isNotEmpty(filePath)) &#123;</span><br><span class="line">                    DownUtil.dowloadFile(filePath + fileName, fileName, downName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getTemplateFilePath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String folder = StringUtil.isNotEmpty(templateFilePath) ? templateFilePath : ConfigConst.TEMPLATE_FOLDER;</span><br><span class="line">        <span class="keyword">return</span> getXssPath(path + folder + File.separator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下载文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paths    路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 订单信息.pdf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">dowloadFile</span><span class="params">(String paths, String fileName, String downName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isNotEmpty(downName)) &#123;</span><br><span class="line">            fileName = downName;</span><br><span class="line">        &#125;</span><br><span class="line">        String escapeFileName = XSSEscape.escape(fileName);</span><br><span class="line">        HttpServletResponse response = ServletUtil.getResponse();</span><br><span class="line">        HttpServletRequest request = ServletUtil.getRequest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@Cleanup</span> InputStream is = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(XSSEscape.escapePath(paths)));</span><br><span class="line">            <span class="meta">@Cleanup</span> BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br><span class="line">            response.setCharacterEncoding(Constants.UTF_8);</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(escapeFileName.contains(<span class="string">&quot;.svg&quot;</span>))&#123;</span><br><span class="line">                response.setContentType(<span class="string">&quot;image/svg+xml&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//编码的文件名字,关于中文乱码的改造</span></span><br><span class="line">            String codeFileName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            String agent = request.getHeader(<span class="string">&quot;USER-AGENT&quot;</span>).toLowerCase();</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> != agent.indexOf(<span class="string">&quot;msie&quot;</span>) || -<span class="number">1</span> != agent.indexOf(<span class="string">&quot;trident&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//IE</span></span><br><span class="line">                codeFileName = URLEncoder.encode(escapeFileName, Constants.UTF_8);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> != agent.indexOf(<span class="string">&quot;mozilla&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//火狐，谷歌</span></span><br><span class="line">                codeFileName = <span class="keyword">new</span> String(escapeFileName.getBytes(Constants.UTF_8), <span class="string">&quot;iso-8859-1&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                codeFileName = URLEncoder.encode(escapeFileName, Constants.UTF_8);</span><br><span class="line">            &#125;</span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span> + <span class="keyword">new</span> String(codeFileName.getBytes(),<span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">            <span class="meta">@Cleanup</span> OutputStream os = response.getOutputStream();</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">            <span class="keyword">while</span> ((i = bis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff, <span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            os.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">config:</span></span><br><span class="line">  <span class="comment">#===================== 是否开启测试环境 =====================</span></span><br><span class="line">  <span class="attr">TestVersion:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#===================== 文件模板配置 =====================</span></span><br><span class="line">  <span class="attr">fileType:</span> <span class="string">local</span> <span class="comment">#文件存储类型(local-本地存储，minio-网络存储)</span></span><br><span class="line">  <span class="comment"># win</span></span><br><span class="line">  <span class="attr">Path:</span> <span class="string">E:\Work\RealJNPF\jnpf-resources-develop\</span> <span class="comment">#Windows配置（静态资源根目录和代码生成器临时目录）</span></span><br><span class="line">  <span class="comment"># Linux</span></span><br><span class="line">  <span class="comment">#Path: /data/jnpf-resources/ #Linux配置（静态资源根目录和代码生成器临时目录）</span></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">http://192.168.0.147:9000/</span> <span class="comment">#服务端地址</span></span><br><span class="line">    <span class="attr">accessKey:</span> <span class="string">minioadmin</span> <span class="comment">#账号</span></span><br><span class="line">    <span class="attr">secretKey:</span> <span class="string">minioadmin</span> <span class="comment">#密码</span></span><br><span class="line">    <span class="attr">fileHost:</span> <span class="string">http://192.168.0.147:9000/</span> <span class="comment">#地址</span></span><br></pre></td></tr></table></figure><ol><li><p>上传文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;up_right&quot;&gt;</span><br><span class="line">            &lt;p class=&quot;title&quot;&gt;上传船舶信息&lt;/p&gt;</span><br><span class="line">            &lt;p class=&quot;tip&quot;&gt;文件后缀名必须是xls或xlsx，文件大小不超过500KB，最多支持导入1000条数据&lt;/p&gt;</span><br><span class="line">            &lt;el-upload :action=&quot;define.comUrl+&#x27;/api/extend/Employee/Uploader&#x27;&quot;</span><br><span class="line">              :headers=&quot;&#123; Authorization: $store.getters.token&#125;&quot; :on-success=&quot;handleSuccess&quot;</span><br><span class="line">              :on-remove=&quot;handleRemove&quot; :before-remove=&quot;beforeRemove&quot; :on-change=&quot;handleChange&quot;</span><br><span class="line">              :file-list=&quot;fileList&quot; accept=&quot;.xls,.xlsx&quot; :before-upload=&quot;beforeUpload&quot;</span><br><span class="line">              class=&quot;upload-area&quot;&gt;</span><br><span class="line">              &lt;el-button type=&quot;text&quot;&gt;上传文件&lt;/el-button&gt;</span><br><span class="line">            &lt;/el-upload&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h2><p>导出步骤：1. 选择导出字段—&gt; 2. 点击导出，传入字段值，动态添加相应数据转换为map—&gt;3. 写入文件流，临时保存到服务器中—&gt;4. 返回文件名及文件链接—&gt;5. 生成dom元素，并设置元素超链接为文件链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-dialog title=&quot;导出数据&quot; :close-on-click-modal=&quot;false&quot; :visible.sync=&quot;visible&quot;</span><br><span class="line">    class=&quot;JNPF-dialog JNPF-dialog_center&quot; lock-scroll width=&quot;600px&quot;&gt;</span><br><span class="line">    &lt;el-form label-position=&quot;top&quot; label-width=&quot;80px&quot;&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;数据选择&quot;&gt;</span><br><span class="line">        &lt;el-radio-group v-model=&quot;type&quot;&gt;</span><br><span class="line">          &lt;el-radio :label=&quot;0&quot;&gt;当前页面数据&lt;/el-radio&gt;</span><br><span class="line">          &lt;el-radio :label=&quot;1&quot;&gt;全部页面数据&lt;/el-radio&gt;</span><br><span class="line">        &lt;/el-radio-group&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">      &lt;el-form-item label=&quot;导出字段&quot;&gt;</span><br><span class="line">        &lt;el-checkbox :indeterminate=&quot;isIndeterminate&quot; v-model=&quot;checkAll&quot;</span><br><span class="line">          @change=&quot;handleCheckAllChange&quot;&gt;全选&lt;/el-checkbox&gt;</span><br><span class="line">        &lt;el-checkbox-group v-model=&quot;columns&quot; @change=&quot;handleCheckedChange&quot;&gt;</span><br><span class="line">          &lt;el-checkbox v-for=&quot;item in columnList&quot; :label=&quot;item.prop&quot; :key=&quot;item.prop&quot;&gt;</span><br><span class="line">            &#123;&#123;item.label&#125;&#125;</span><br><span class="line">          &lt;/el-checkbox&gt;</span><br><span class="line">        &lt;/el-checkbox-group&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line">    &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt;</span><br><span class="line">      &lt;el-button @click=&quot;visible=false&quot;&gt;取 消&lt;/el-button&gt;</span><br><span class="line">      &lt;el-button type=&quot;primary&quot; @click=&quot;downLoad&quot;&gt;导 出&lt;/el-button&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &lt;/el-dialog&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      visible: false,</span><br><span class="line">      btnLoading: false,</span><br><span class="line">      type: 0,</span><br><span class="line">      columns: [],</span><br><span class="line">      checkAll: true,</span><br><span class="line">      isIndeterminate: false,</span><br><span class="line">      columnList: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    init(columnList) &#123;</span><br><span class="line">      this.visible = true</span><br><span class="line">      this.checkAll = true</span><br><span class="line">      this.isIndeterminate = false</span><br><span class="line">      this.columnList = columnList</span><br><span class="line">      this.columns = columnList.map(o =&gt; o.prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleCheckAllChange(val) &#123;</span><br><span class="line">      this.columns = val ? this.columnList.map(o =&gt; o.prop) : [];</span><br><span class="line">      this.isIndeterminate = false;</span><br><span class="line">    &#125;,</span><br><span class="line">    handleCheckedChange(value) &#123;</span><br><span class="line">      let checkedCount = value.length;</span><br><span class="line">      this.checkAll = checkedCount === this.columnList.length;</span><br><span class="line">      this.isIndeterminate = checkedCount &gt; 0 &amp;&amp; checkedCount &lt; this.columnList.length;</span><br><span class="line">    &#125;,</span><br><span class="line">    downLoad() &#123;</span><br><span class="line">      /*download(data) &#123;</span><br><span class="line">                let query = &#123;...data, ...this.listQuery, ...this.query,menuId:this.menuId&#125;</span><br><span class="line">                request(&#123;</span><br><span class="line">                    url: `/api/ShipManage/ship/Actions/Export`,</span><br><span class="line">                    method: &#x27;GET&#x27;,</span><br><span class="line">                    data: query</span><br><span class="line">                &#125;).then(res =&gt; &#123;</span><br><span class="line">                    if (!res.data.url) return</span><br><span class="line">                    this.jnpf.downloadFile(res.data.url)</span><br><span class="line">                    this.$refs.ExportBox.visible = false</span><br><span class="line">                    this.exportBoxVisible = false</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,*/</span><br><span class="line">      this.$emit(&#x27;download&#x27;, &#123; dataType: this.type, selectKey: this.columns.join(&#x27;,&#x27;) &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="vue" scheme="http://ppnostalgia.github.io./categories/vue/"/>
    
    
    <category term="Vue" scheme="http://ppnostalgia.github.io./tags/Vue/"/>
    
    <category term="ElementUI" scheme="http://ppnostalgia.github.io./tags/ElementUI/"/>
    
  </entry>
  
  <entry>
    <title>基于Smartcloud项目学习Springcloud</title>
    <link href="http://ppnostalgia.github.io./6485e78d.html"/>
    <id>http://ppnostalgia.github.io./6485e78d.html</id>
    <published>2022-11-07T03:42:00.000Z</published>
    <updated>2023-01-31T06:20:38.475Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>smart-registry模块</strong></p><p>-bin 存放nacos源文件及运行指令 </p><p>-conf </p><pre><code>- application.properties- nacos-logback.xml nacos日志记录配置- nacos-mysql.sql、schema.sql  nacos配置数据库</code></pre><p><strong>application.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#*************** Spring Boot Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### Default web context path:</span></span><br><span class="line"><span class="meta">server.servlet.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="comment">### Default web server port:</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">30099</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#*************** Network Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If prefer hostname over ip for Nacos server addresses in cluster.conf:</span></span><br><span class="line"><span class="comment"># nacos.inetutils.prefer-hostname-over-ip=false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Specify local server&#x27;s IP:</span></span><br><span class="line"><span class="comment"># nacos.inetutils.ip-address=</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#*************** Config Module Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If use MySQL as datasource:</span></span><br><span class="line"><span class="meta">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Count of DB:</span></span><br><span class="line"><span class="meta">db.num</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">db.url.0</span>=<span class="string">jdbc:mysql://localhost:3306/jnpf_nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">db.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#*************** Naming Module Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### Data dispatch task execution period in milliseconds:</span></span><br><span class="line"><span class="comment"># nacos.naming.distro.taskDispatchPeriod=200</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Data count of batch sync task:</span></span><br><span class="line"><span class="comment"># nacos.naming.distro.batchSyncKeyCount=1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Retry delay in milliseconds if sync task failed:</span></span><br><span class="line"><span class="comment"># nacos.naming.distro.syncRetryDelay=5000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### If enable data warmup. If set to false, the server would accept request without local data preparation:</span></span><br><span class="line"><span class="comment"># nacos.naming.data.warmup=true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### If enable the instance auto expiration, kind like of health check of instance:</span></span><br><span class="line"><span class="comment"># nacos.naming.expireInstance=true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">nacos.naming.empty-service.auto-clean</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">nacos.naming.empty-service.clean.initial-delay-ms</span>=<span class="string">50000</span></span><br><span class="line"><span class="meta">nacos.naming.empty-service.clean.period-time-ms</span>=<span class="string">30000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#*************** Metrics Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### Metrics for prometheus</span></span><br><span class="line"><span class="comment">#management.endpoints.web.exposure.include=*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Metrics for elastic search</span></span><br><span class="line"><span class="meta">management.metrics.export.elastic.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#management.metrics.export.elastic.host=http://localhost:9200</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Metrics for influx</span></span><br><span class="line"><span class="meta">management.metrics.export.influx.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#*************** Access Log Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If turn on the access log:</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### The access log pattern:</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.pattern</span>=<span class="string">%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;i %&#123;Request-Source&#125;i</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### The directory of access log:</span></span><br><span class="line"><span class="meta">server.tomcat.basedir</span>=<span class="string"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#*************** Access Control Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If enable spring security, this option is deprecated in 1.2.0:</span></span><br><span class="line"><span class="comment">#spring.security.enabled=false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### The ignore urls of auth, is deprecated in 1.2.0:</span></span><br><span class="line"><span class="meta">nacos.security.ignore.urls</span>=<span class="string">/,/error,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/**,/v1/console/health/**,/actuator/**,/v1/console/server/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### The auth system to use, currently only &#x27;nacos&#x27; is supported:</span></span><br><span class="line"><span class="meta">nacos.core.auth.system.type</span>=<span class="string">nacos</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### If turn on auth system:</span></span><br><span class="line"><span class="meta">nacos.core.auth.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### The token expiration in seconds:</span></span><br><span class="line"><span class="meta">nacos.core.auth.default.token.expire.seconds</span>=<span class="string">18000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### The default token:</span></span><br><span class="line"><span class="meta">nacos.core.auth.default.token.secret.key</span>=<span class="string">SecretKey012345678901234567890123456789012345678901234567890123456789</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Turn on/off caching of auth information. By turning on this switch, the update of auth information would have a 15 seconds delay.</span></span><br><span class="line"><span class="meta">nacos.core.auth.caching.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#*************** Istio Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If turn on the MCP server:</span></span><br><span class="line"><span class="meta">nacos.istio.mcp.server.enabled</span>=<span class="string">false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SpringCloud" scheme="http://ppnostalgia.github.io./categories/SpringCloud/"/>
    
    
    <category term="Nacos" scheme="http://ppnostalgia.github.io./tags/Nacos/"/>
    
    <category term="Seata" scheme="http://ppnostalgia.github.io./tags/Seata/"/>
    
    <category term="Sentinel" scheme="http://ppnostalgia.github.io./tags/Sentinel/"/>
    
    <category term="Skywalking" scheme="http://ppnostalgia.github.io./tags/Skywalking/"/>
    
  </entry>
  
  <entry>
    <title>VO、DTO、PO</title>
    <link href="http://ppnostalgia.github.io./77519cd8.html"/>
    <id>http://ppnostalgia.github.io./77519cd8.html</id>
    <published>2022-11-04T06:20:34.000Z</published>
    <updated>2023-01-31T06:20:38.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>PO（持久对象）</strong>: 包含持久层所用到的字段，数据库表中所有对应的字段</p><p><strong>VO（视图对象）</strong>：包含视图层所用到的字段，需要展示给用户的字段</p><p><strong>DTO（数据传输对象）</strong>：泛指用于展示层与服务层之间的数据传输对象。接受展示层传的性别男，返回展示层性别男。</p><p><strong>VO和DTO的区别：</strong></p><ol><li><strong>在一个DTO对应多个VO时，DTO≠VO</strong>：</li></ol><p>一个是字段不一样，VO根据需要会删减一些字段<br>另一个是值不一样，VO会根据需要对DTO中的值进行展示业务的解释</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DTO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;男&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;age&quot;</span>:<span class="number">35</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//VO</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="attr">&quot;gender&quot;</span>:<span class="string">&quot;公子&quot;</span> ,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>:<span class="string">&quot;30-39&quot;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ol><li>在一个DTO对应一个VO时，DTO和VO的属性值是一致的，<strong>VO可以直接省略掉，直接用DTO代替</strong>。前端传输给后端的是dto,后端返回给前端的是vo,或者直接返回不封装的dto</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Web开发" scheme="http://ppnostalgia.github.io./categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Spring" scheme="http://ppnostalgia.github.io./tags/Spring/"/>
    
    <category term="Vue" scheme="http://ppnostalgia.github.io./tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="http://ppnostalgia.github.io./a9b3efe1.html"/>
    <id>http://ppnostalgia.github.io./a9b3efe1.html</id>
    <published>2022-10-31T06:40:34.000Z</published>
    <updated>2023-01-31T06:20:38.478Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>传统登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、用户向服务器发送用户名和密码。</span><br><span class="line"></span><br><span class="line">2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</span><br><span class="line"></span><br><span class="line">3、服务器向用户返回一个 session_id，写入用户的 Cookie。</span><br><span class="line"></span><br><span class="line">4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</span><br><span class="line"></span><br><span class="line">5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</span><br></pre></td></tr></table></figure><p>缺点：</p><p>不适合于分布式或者跨域等需要数据共享的场景。解决：1. session数据持久化，工程量大 2. 服务器不保存session</p><h2 id="JWT请求流程"><a href="#JWT请求流程" class="headerlink" title="JWT请求流程"></a>JWT请求流程</h2><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/900b3e81f832b2f08c2e8aabb540536a.png" alt="img"></p><p><strong>1. 用户使用账号和面发出post请求；</strong><br><strong>2. 服务器使用私钥创建一个jwt（本质是字符串）；</strong><br><strong>3. 服务器返回这个jwt给浏览器；</strong><br><strong>4. 浏览器将该jwt串在请求头中（Authorization字段中，方便跨域。或者post请求的数据体里）向服务器发送请求；</strong><br><strong>5. 服务器验证该jwt；</strong><br><strong>6. 返回响应的资源给浏览器。</strong></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><strong>Header 头部(标题包含了令牌的元数据，并且包含签名和/或加密算法的类型)</strong></p><p>是一个json对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>, <span class="comment">//签名算法</span></span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Payload 负载</strong> </p><p>Payload 部分也是一个 JSON 对象，用来<strong>存放实际需要传递的数据</strong>。JWT 规定了7个官方字段，供选用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure><p><strong>Signature 签名/签证</strong></p><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要<strong>指定一个密钥（secret）</strong>。这个密钥只有服务器才知道，不能泄露给用户，一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><p><strong>Signature 签名中的密钥 secret</strong></p><p>通过使用如下命令，生成公私钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -alias testKey -keyalg RSA -keypass testPwd -keystore testkey.jks -storepass testStoreKey</span><br></pre></td></tr></table></figure><p>-alias：密钥的别名<br>-keyalg：使用的hash算法<br>-keypass：密钥的访问密码<br>-keystore：密钥库文件名<br>-storepass：密钥库的访问密码<br>在testkey.jks文件中获取公钥public.jks文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -alias testKey -keystore testkey.jks -file public.jks</span><br></pre></td></tr></table></figure><h2 id="Oauth2-0"><a href="#Oauth2-0" class="headerlink" title="Oauth2.0"></a>Oauth2.0</h2><p><strong>OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p><p>角色如下：</p><ul><li>资源拥有者：指拥有共享数据的人或应用。通常指用户</li><li>资源服务器：托管资源的服务器。用户数据存储的地方</li><li>客户端应用：请求访问存储在资源服务器的资源的应用。资源被资源拥有者所拥有。客户端应用可以是一个请求访问用户Facebook账号的第三方游戏。</li><li>授权服务器：授权服务器是指授权客户端应用能够访问资源拥有者所拥有的资源。<strong>授权服务器和资源服务器可以是同一个服务器，但不是必须的。</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">授权码（authorization-code）(最常用):第三方应用先申请一个授权码，然后再用该码获取令牌。</span><br><span class="line">隐藏式（implicit）:允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）&quot;隐藏式&quot;（implicit）。</span><br><span class="line">密码式（password）：允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌。可以通过JWT实现</span><br><span class="line">客户端凭证（client credentials）:适用于没有前端的命令行应用，即在命令行下请求令牌。</span><br></pre></td></tr></table></figure><h2 id="Spring-Security-oauth2"><a href="#Spring-Security-oauth2" class="headerlink" title="Spring Security oauth2"></a>Spring Security oauth2</h2><p>核心：<strong>配置类AuthorizationServerConfigurerAdapter</strong></p><p>在配置Oauth2授权服务时，需要配置，一般是自定义子类，实现AuthorizationServerConfigurerAdapter接口，重写三个configure方法</p><ul><li>AuthorizationServerSecurityConfigurer：用来配置令牌端点(Token Endpoint)的安全约束.</li><li>ClientDetailsServiceConfigurer：用来配置客户端详情服务（ClientDetailsService），客户端详情信息在这里进行初始化，你能够把客户端详情信息写死在这里或者是通过数据库来存储调取详情信息。</li><li>AuthorizationServerEndpointsConfigurer：用来配置授权（authorization）以及令牌（token）的访问端点和令牌服务(token services)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userDetailsService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenEnhancer jwtTokenEnhancer;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ClientDetailsServiceConfigurer 主要是注入ClientDetailsService实例对象(AuthorizationServerConfigurer 的一个回调配置项，唯一配置注入) ，能够使用内存或者JDBC来实现客户端详情服务（ClientDetailsService），系统提供的两个ClientDetailsService实现类：JdbcClientDetailsService、InMemoryClientDetailsService。</span></span><br><span class="line">    <span class="comment">//配置授权服务器的客户端详情</span></span><br><span class="line">    <span class="comment">//clients.inMemory() 从内存中读取令牌</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//从数据库中读取令牌</span></span><br><span class="line">        JdbcClientDetailsService jdbcClientDetailsService = <span class="keyword">new</span> JdbcClientDetailsServiceImpl(dataSource);</span><br><span class="line">        <span class="comment">//这个地方指的是从jdbc查出数据来存储</span></span><br><span class="line">        clients.withClientDetails(jdbcClientDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 允许表单验证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> security</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置授权服务器的安全性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> security 安全功能配置器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        security.allowFormAuthenticationForClients();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义认证异常响应数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationEntryPoint <span class="title">authenticationEntryPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (request, response, e) -&gt; &#123;</span><br><span class="line">            response.setStatus(HttpStatus.HTTP_OK);</span><br><span class="line">            response.setHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_UTF8_VALUE);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">            response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">            ActionResult result = ActionResult.fail(<span class="string">&quot;客户端认证失败&quot;</span>);</span><br><span class="line">            response.getWriter().print(JSONUtil.toJsonStr(result));</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*授权服务器端点配置</span></span><br><span class="line"><span class="comment">    //AuthorizationServerEndpointsConfigurer其实是一个装载类，装载Endpoints所有相关的类配置（AuthorizationServer、TokenServices、TokenStore、ClientDetailsService、UserDetailsService）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">也就是说进行密码验证的一些工具类或服务类，均在这个地方进行注入，例如UserDetailsService，我们知道UserDetailsService是负责从数据库读取用户数据的，用户数据包含密码信息，这样，框架就可以判断前端传入的用户名和密码是否正确。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果启用token校验的话，就需要注入TokenServices，TokenStore是对token的额外补充，用来确定token存储的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因此，不是所有的参数都是必须的，需要根据实际场景来确定使用的参数。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置授权服务器端点的非安全功能，如令牌存储、令牌定制、用户批准和授权类型。默认情况下你不需要做任何事情，除非你需要密码授权（密码模式），在这种情况下你需要配置一个AuthenticationManager。</span></span><br><span class="line"><span class="comment">     * 参数：端点配置器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将增强的token设置到增强链中</span></span><br><span class="line">        TokenEnhancerChain tokenEnhancerChain = <span class="keyword">new</span> TokenEnhancerChain();</span><br><span class="line">        List&lt;TokenEnhancer&gt; tokenEnhancer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//配置Jwt内容填充器</span></span><br><span class="line">        tokenEnhancer.add(jwtTokenEnhancer);</span><br><span class="line">        tokenEnhancer.add(jwtAccessTokenConverter());</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(tokenEnhancer);</span><br><span class="line">        <span class="comment">//AuthenticationManager是一个用来处理认证（Authentication）请求的接口。在其中只定义了一个方法authenticate()，该方法只接收一个代表认证请求的Authentication对象作为参数，如果认证成功，则会返回一个封装了当前用户权限等信息的Authentication对象进行返回。</span></span><br><span class="line">        endpoints.authenticationManager(authenticationManager)</span><br><span class="line">            <span class="comment">//根据用户名可以查到用户并返回的方法。</span></span><br><span class="line">                .userDetailsService(userDetailsService)</span><br><span class="line">                .accessTokenConverter(jwtAccessTokenConverter())</span><br><span class="line">                .tokenEnhancer(tokenEnhancerChain)</span><br><span class="line">                .pathMapping(<span class="string">&quot;/oauth/token&quot;</span>,<span class="string">&quot;/api/oauth/Login&quot;</span>)</span><br><span class="line">                <span class="comment">//不可重复使用</span></span><br><span class="line">                .reuseRefreshTokens(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JwtAccessTokenConverter jwtAccessTokenConverter = <span class="keyword">new</span> JwtAccessTokenConverter();</span><br><span class="line">        jwtAccessTokenConverter.setKeyPair(keyPair());</span><br><span class="line">        <span class="keyword">return</span> jwtAccessTokenConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取resource下的jwt.jks文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeyPair <span class="title">keyPair</span><span class="params">()</span></span>&#123;</span><br><span class="line">        KeyStoreKeyFactory keyStoreKeyFactory = <span class="keyword">new</span> KeyStoreKeyFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;jnpf.jks&quot;</span>),<span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">        <span class="keyword">return</span> keyStoreKeyFactory.getKeyPair(<span class="string">&quot;jnpf&quot;</span>,<span class="string">&quot;123456&quot;</span>.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置令牌-管理-jwtAccessTokenConverter"><a href="#配置令牌-管理-jwtAccessTokenConverter" class="headerlink" title="配置令牌 管理 (jwtAccessTokenConverter)"></a>配置令牌 管理 (jwtAccessTokenConverter)</h2><p>JwtAccessTokenConverter是用来生成token的转换器，而token令牌默认是有签名的，且资源服务器需要验证这个签名。此处的加密及验签包括两种方式：</p><ul><li>对称加密</li><li>非对称加密（公钥密钥）</li></ul><p>对称加密需要授权服务器和资源服务器存储同一key值，而非对称加密可使用密钥加密，暴露公钥给资源服务器验签，本文中使用非对称加密方式，配置于AuthorizationServerConfigurerAdapter如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> </span>&#123;</span><br><span class="line">    endpoints.authenticationManager(authenticationManager)</span><br><span class="line">            <span class="comment">// 配置JwtAccessToken转换器</span></span><br><span class="line">            .accessTokenConverter(jwtAccessTokenConverter())</span><br><span class="line">            <span class="comment">// refresh_token需要userDetailsService</span></span><br><span class="line">            .reuseRefreshTokens(<span class="keyword">false</span>).userDetailsService(userDetailsService);</span><br><span class="line">            <span class="comment">//.tokenStore(getJdbcTokenStore());</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用非对称加密算法来对Token进行签名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JwtAccessTokenConverter <span class="title">jwtAccessTokenConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">final</span> JwtAccessTokenConverter converter = <span class="keyword">new</span> MyJwtAccessTokenConverter ();</span><br><span class="line">    <span class="comment">// 导入证书</span></span><br><span class="line">    KeyStoreKeyFactory keyStoreKeyFactory =</span><br><span class="line">            <span class="keyword">new</span> KeyStoreKeyFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;keystore.jks&quot;</span>), <span class="string">&quot;mypass&quot;</span>.toCharArray());</span><br><span class="line">    converter.setKeyPair(keyStoreKeyFactory.getKeyPair(<span class="string">&quot;mytest&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> converter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 JDK 工具生成 JKS 证书文件，并将 keystore.jks 放入resource目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -alias mytest -keyalg RSA -keypass mypass -keystore keystore.jks -storepass mypass</span><br></pre></td></tr></table></figure><p>此处我们自定义JwtAccessToken用于添加额外用户信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来向jwt的json中添加额外信息的</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtTokenEnhancer</span> <span class="keyword">implements</span> <span class="title">TokenEnhancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserProvider userProvider;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OAuth2AccessToken <span class="title">enhance</span><span class="params">(OAuth2AccessToken oAuth2AccessToken, OAuth2Authentication oAuth2Authentication)</span> </span>&#123;</span><br><span class="line">        UserEntity userEntity=userService.getUserEntity(oAuth2Authentication.getName());</span><br><span class="line">        UserInfo userInfo=userProvider.get(userEntity.getId(), DataSourceContextHolder.getDatasourceId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建map，将需要增加的内容放置到map中</span></span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//移除在线</span></span><br><span class="line">        userProvider.removeWebSocket(userInfo);</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,userInfo.getId());</span><br><span class="line">        <span class="comment">//写入日志</span></span><br><span class="line">        logService.writeLogAsync(userInfo.getUserId(),userInfo.getUserName()+<span class="string">&quot;/&quot;</span>+userInfo.getUserAccount(),<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        ((DefaultOAuth2AccessToken)oAuth2AccessToken).setAdditionalInformation(map);</span><br><span class="line">        <span class="keyword">return</span> oAuth2AccessToken;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="前端（Vue）"><a href="#前端（Vue）" class="headerlink" title="前端（Vue）"></a>前端（Vue）</h3><p>/utils/request.js request拦截器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an axios instance</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: process.env.VUE_APP_BASE_API, <span class="comment">// url = base url + request url</span></span><br><span class="line">  <span class="attr">withCredentials</span>: <span class="literal">false</span>, <span class="comment">// send cookies when cross-domain requests</span></span><br><span class="line">  <span class="attr">timeout</span>: define.timeout, <span class="comment">// request timeout</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// request interceptor 如果store中token为true,则放到request体中的Authorization字段中</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 部分接口timeout时间单独处理</span></span><br><span class="line">    <span class="keyword">if</span> (config.url.indexOf(<span class="string">&#x27;Synchronization&#x27;</span>) &gt; -<span class="number">1</span> || config.url.indexOf(<span class="string">&#x27;extend/Email/Receive&#x27;</span>) &gt; -<span class="number">1</span> ||</span><br><span class="line">      config.url.indexOf(<span class="string">&#x27;Permission/Authority/Data&#x27;</span>) &gt; -<span class="number">1</span> || config.url.indexOf(<span class="string">&#x27;DataSync/Actions/Execute&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      config.timeout = <span class="number">100000</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something before request is sent</span></span><br><span class="line">    <span class="comment">/*export function getToken() &#123;</span></span><br><span class="line"><span class="comment">  return jnpf.storageGet(&#x27;token&#x27;)</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    <span class="keyword">if</span> (store.getters.token) &#123;</span><br><span class="line">      config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = getToken()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.method == <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">      config.params = config.data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> timestamp = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()) / <span class="number">1000</span></span><br><span class="line">    <span class="keyword">if</span> (config.url.indexOf(<span class="string">&#x27;?&#x27;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      config.url += <span class="string">`&amp;n=<span class="subst">$&#123;timestamp&#125;</span>`</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      config.url += <span class="string">`?n=<span class="subst">$&#123;timestamp&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something with request error</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(error) <span class="comment">// for debug</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>点击按钮，触发事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleLogin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.loading) <span class="keyword">return</span></span><br><span class="line">      <span class="built_in">this</span>.$refs.loginForm.validate(<span class="function"><span class="params">valid</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">          <span class="built_in">this</span>.loading = <span class="literal">true</span></span><br><span class="line">          <span class="comment">/*SET_LOGIN_LOADING: (state, loginLoading) =&gt; &#123;</span></span><br><span class="line"><span class="comment">    state.loginLoading = loginLoading</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line">          <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;user/SET_LOGIN_LOADING&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">          <span class="built_in">this</span>.$store</span><br><span class="line">            .dispatch(<span class="string">&#x27;user/login&#x27;</span>, <span class="built_in">this</span>.loginForm)</span><br><span class="line">            .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="built_in">this</span>.redirect || <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">                <span class="attr">query</span>: <span class="built_in">this</span>.otherQuery</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;user/SET_LOGIN_LOADING&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>@/store/modules/user.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user login</span></span><br><span class="line">  <span class="function"><span class="title">login</span>(<span class="params">&#123; commit &#125;, userInfo</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; account, password &#125; = userInfo</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      login(&#123; <span class="attr">account</span>: account.trim(), <span class="attr">password</span>: md5(password) &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line">        <span class="keyword">const</span> layoutList = [<span class="string">&#x27;classic&#x27;</span>, <span class="string">&#x27;functional&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>]</span><br><span class="line">        <span class="keyword">let</span> layoutType = data.theme &amp;&amp; layoutList.indexOf(data.theme) &gt; -<span class="number">1</span> ? data.theme : <span class="string">&#x27;classic&#x27;</span></span><br><span class="line">        <span class="comment">//接收到服务器端发送来的token，则设置store中token为true，可以在request请求时通过拦截器携带此token</span></span><br><span class="line">        <span class="comment">/*SET_TOKEN: (state, token) =&gt; &#123;</span></span><br><span class="line"><span class="comment">    state.token = token</span></span><br><span class="line"><span class="comment">  &#125;,*/</span></span><br><span class="line">        commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, data.token)</span><br><span class="line">        commit(<span class="string">&#x27;settings/CHANGE_SETTING&#x27;</span>, &#123; <span class="attr">key</span>: <span class="string">&quot;layoutType&quot;</span>, <span class="attr">value</span>: layoutType &#125;, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        <span class="comment">//放入token值</span></span><br><span class="line">        <span class="comment">/*export function setToken(token) &#123;</span></span><br><span class="line"><span class="comment">  return jnpf.storageSet(&#123; token &#125;)</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        setToken(data.token)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>@api/user.js  请求体</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/api/oauth/Login&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ol><li><p>@/common/filter  拦截器  查询前端传过来的jwt token的有效性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        String path = request.getServletPath();</span><br><span class="line">        System.out.println(<span class="string">&quot;请求路径:&quot;</span> + path);</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;OPTIONS&quot;</span>.equals(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取前端request中的authorize的token信息</span></span><br><span class="line">        String token = UserProvider.getToken();</span><br><span class="line">        <span class="comment">//根据该token获取用户详细信息</span></span><br><span class="line">        UserInfo userInfo = userProvider.get();</span><br><span class="line">        <span class="comment">//解析token，获取token具体信息</span></span><br><span class="line">        String realToken = JwtUtil.getRealToken(token);</span><br><span class="line">        <span class="comment">//测试版本可以关闭验证</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;false&quot;</span>.equals(configValueUtil.getTestVersion())) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//redis缓存中是否存在该token</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtil.isEmpty(realToken) || !redisUtil.exists(realToken)) &#123;</span><br><span class="line">                ActionResult result = ActionResult.fail(ActionResultCode.SessionOverdue.getCode(), ActionResultCode.SessionOverdue.getMessage());</span><br><span class="line">                ServletUtil.renderString(response, JsonUtil.getObjectToString(result));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否过期</span></span><br><span class="line"><span class="comment">//            Date exp = JwtUtil.getExp(token);</span></span><br><span class="line"><span class="comment">//            if (exp.getTime() &lt; System.currentTimeMillis()) &#123;</span></span><br><span class="line"><span class="comment">//                ActionResult result = ActionResult.fail(ActionResultCode.SessionOverdue.getCode(), ActionResultCode.SessionOverdue.getMessage());</span></span><br><span class="line"><span class="comment">//                ServletUtil.renderString(response, JsonUtil.getObjectToString(result));</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            是否在线</span></span><br><span class="line">            <span class="keyword">if</span> (!userProvider.isOnLine()) &#123;</span><br><span class="line">                ActionResult result = ActionResult.fail(ActionResultCode.SessionOffLine.getCode(), ActionResultCode.SessionOffLine.getMessage());</span><br><span class="line">                redisUtil.remove(realToken);</span><br><span class="line">                ServletUtil.renderString(response, JsonUtil.getObjectToString(result));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加在线过期时间</span></span><br><span class="line">            tokenTimeout(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure></li><li><p>@/utils/JwtUtil.java  jwt解码工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jnpf.util.jwt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nimbus-jose-jwt解码包</span></span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jwt.JWTClaimsSet;</span><br><span class="line"><span class="keyword">import</span> com.nimbusds.jwt.SignedJWT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JNPF开发平台组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V3.1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@copyright</span> 引迈信息技术有限公司</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/16 8:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取jwt中的携带的Redis的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRealToken</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        String realToken;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SignedJWT sjwt = SignedJWT.parse(token.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">            JWTClaimsSet claims = sjwt.getJWTClaimsSet();</span><br><span class="line">            realToken =  String.valueOf(claims.getClaim(<span class="string">&quot;token&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> realToken;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取jwt中的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">getExp</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        Date date;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SignedJWT sjwt = SignedJWT.parse(token.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">            JWTClaimsSet claims = sjwt.getJWTClaimsSet();</span><br><span class="line">            date = (Date)claims.getClaim(<span class="string">&quot;exp&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> date = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//authorization字段的值，Bearer代表Authorization头定义的schema</span></span><br><span class="line">        String test = getRealToken(<span class="string">&quot;Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiIxNDEwMDEiLCJzY29wZSI6WyJhbGwiXSwiZXhwIjoxNjA5MDA5NDQxLCJhdXRob3JpdGllcyI6WyJhYSJdLCJqdGkiOiIxYWNkYTI4MS0yYTUxLTRmZGYtYmRlYy03OWFkNmI5NzZmODEiLCJjbGllbnRfaWQiOiJhZG1pbiIsInRva2VuIjoibG9naW5fdG9rZW5fMDNhNDEyNTgwOGU5NGVhYjhlY2I3MzM4OTQ2ZjJhMzgifQ.b1LJ5dWQeI0it7JPP0vAm56Ns-2l-zpi768Z2KhdAODLWyfO640jIz02dNixfnw0_2hgBwqj9Y-1NIMVEZmRPMoRhIOwh6qw4p8b05k8Y3M2KXhdYaQTaw9ZkpR-TFRuVf8_v2bUaUjmnulXRffV3iVAYmcZcXHBrv0938_oJJEIKHmjtlbbOCaKIf6IEPCwmFci8gLCnld6FnVIytg9rMD85AsagwLHs_dNaNavEg3-s5Fi9jov7L2_h940aHPvtwBiCNpPkFIA-hmYb7-ChETmx8yFN3TnJbNX4-wpQ_dJlaNnHTtbt8ztNr-ugXbKGqfkZzWPxn-anqeSjyBUAA&quot;</span>);</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserProvider.java 根据token获取缓存中的用户信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String toke = getAuthorize();</span><br><span class="line">        <span class="keyword">return</span> toke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">get</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        token = JwtUtil.getRealToken(token);</span><br><span class="line">        String tokens = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tokens = token;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tokens = UserProvider.getToken();</span><br><span class="line">            tokens = JwtUtil.getRealToken(tokens);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tokens != <span class="keyword">null</span>) &#123;</span><br><span class="line">            userInfo = JsonUtil.getJsonToBean(String.valueOf(redisUtil.getString(tokens)), UserInfo.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (userInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String token = UserProvider.getToken();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.get(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过上下文的租户查redis来获取token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">get</span><span class="params">(String userId, String tenantId)</span> </span>&#123;</span><br><span class="line">        UserInfo userInfo;</span><br><span class="line">        tenantId = <span class="string">&quot;null&quot;</span>.equals(String.valueOf(tenantId)) ? <span class="string">&quot;&quot;</span> : tenantId;</span><br><span class="line">        String token = tenantId + <span class="string">&quot;login_online_&quot;</span> + userId;</span><br><span class="line">        <span class="keyword">if</span> (ServletUtil.getIsMobileDevice()) &#123;</span><br><span class="line">            token = tenantId + <span class="string">&quot;login_online_mobile_&quot;</span> + userId;</span><br><span class="line">        &#125;</span><br><span class="line">        String OnlineInfo = String.valueOf(redisUtil.getString(token));</span><br><span class="line">        userInfo = JsonUtil.getJsonToBean(String.valueOf(redisUtil.getString(OnlineInfo)), UserInfo.class);</span><br><span class="line">        <span class="keyword">return</span> userInfo == <span class="keyword">null</span> ? <span class="keyword">new</span> UserInfo() : userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Authorize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getAuthorize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String authorize = ServletUtil.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> authorize;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>LoginController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;登陆&quot;)</span></span><br><span class="line">    <span class="comment">//consumes锁定post的数据类型</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/Login&quot;, consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ActionResult&lt;LoginVO&gt; <span class="title">login</span><span class="params">(Principal principal, <span class="meta">@RequestParam</span> Map&lt;String, String&gt; parameters)</span> <span class="keyword">throws</span> LoginException </span>&#123;</span><br><span class="line">        UserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line">        LoginForm loginForm = JsonUtil.getJsonToBean(parameters, LoginForm.class);</span><br><span class="line">        <span class="keyword">if</span> (Boolean.parseBoolean(configValueUtil.getMultiTenancy())) &#123;</span><br><span class="line">            userInfo = loginService.checkTenant(loginForm);</span><br><span class="line">            <span class="comment">//设置租户</span></span><br><span class="line">            DataSourceContextHolder.setDatasource(userInfo.getTenantId(), userInfo.getTenantDbConnectionString());</span><br><span class="line">        &#125;</span><br><span class="line">        loginService.isExistUser(loginForm.getAccount().trim());</span><br><span class="line">        UserEntity entity = userService.getUserEntity(loginForm.getAccount());</span><br><span class="line">        userInfo = loginService.userInfo(userInfo, entity);</span><br><span class="line">        <span class="comment">//写入会话</span></span><br><span class="line">        userProvider.add(userInfo);</span><br><span class="line">        <span class="comment">//验证账号密码</span></span><br><span class="line">        parameters.put(<span class="string">&quot;username&quot;</span>, loginForm.getAccount());</span><br><span class="line">        OAuth2AccessToken oAuth2AccessToken;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oAuth2AccessToken = tokenEndpoint.postAccessToken(principal, parameters).getBody();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HttpRequestMethodNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LoginException(<span class="string">&quot;账号密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改前一次登陆时间等信息</span></span><br><span class="line">        entity.setPrevLogIp(IpUtil.getIpAddr());</span><br><span class="line">        entity.setPrevLogTime(DateUtil.getNowDate());</span><br><span class="line">        entity.setLastLogIp(IpUtil.getIpAddr());</span><br><span class="line">        entity.setLastLogTime(DateUtil.getNowDate());</span><br><span class="line">        entity.setLogSuccessCount(entity.getLogSuccessCount() != <span class="keyword">null</span> ? entity.getLogSuccessCount() + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">        userService.update(entity.getId(), entity);</span><br><span class="line">        <span class="comment">//登陆日志记录在JwtTokenEnhancer类中</span></span><br><span class="line">        <span class="comment">//获取主题</span></span><br><span class="line">        LoginVO loginVO = <span class="keyword">new</span> LoginVO();</span><br><span class="line">        loginVO.setToken(oAuth2AccessToken.getTokenType() + <span class="string">&quot; &quot;</span> + oAuth2AccessToken.getValue());</span><br><span class="line">        loginVO.setTheme(entity.getTheme() == <span class="keyword">null</span> ? <span class="string">&quot;classic&quot;</span> : entity.getTheme());</span><br><span class="line">        <span class="keyword">return</span> ActionResult.success(loginVO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>​        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Web开发" scheme="http://ppnostalgia.github.io./categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Spring" scheme="http://ppnostalgia.github.io./tags/Spring/"/>
    
    <category term="Vue" scheme="http://ppnostalgia.github.io./tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>开发问题</title>
    <link href="http://ppnostalgia.github.io./907d88c6.html"/>
    <id>http://ppnostalgia.github.io./907d88c6.html</id>
    <published>2022-10-20T07:39:34.000Z</published>
    <updated>2022-11-04T06:23:23.834Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Npm"><a href="#Npm" class="headerlink" title="Npm"></a>Npm</h1><p>npm install 无法访问github而报错的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save node-sass --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/dist --sass-binary-site=http://npm.taobao.org/mirrors/node-sass</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Web开发" scheme="http://ppnostalgia.github.io./categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="笔记" scheme="http://ppnostalgia.github.io./tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue笔记</title>
    <link href="http://ppnostalgia.github.io./adf5c49.html"/>
    <id>http://ppnostalgia.github.io./adf5c49.html</id>
    <published>2022-10-09T07:39:34.000Z</published>
    <updated>2023-01-31T06:50:17.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初期"><a href="#初期" class="headerlink" title="初期"></a>初期</h1><h2 id="Es语法"><a href="#Es语法" class="headerlink" title="Es语法"></a>Es语法</h2><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> fun = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span> !`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span> !`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义箭头函在数语法上要比普通函数简洁得多。箭头函数省去了<code>function</code>关键字，采用箭头<code>=&gt;</code>来定义函数。<strong>函数的参数放在<code>=&gt;</code>前面的括号中，函数体跟在<code>=&gt;</code>后的花括号中。</strong></p><p>关于箭头函数的参数：</p><p>① 如果箭头函数没有参数，直接写一个空括号即可。</p><p>② 如果箭头函数的参数只有一个，也可以省去包裹参数的括号。</p><p>③ 如果箭头函数有多个参数，将参数依次用逗号(,)分隔，包裹在括号中即可。</p><h3 id="then"><a href="#then" class="headerlink" title="then"></a>then</h3><ol><li>then()方法是异步执行。</li><li>意思是：就是当.then()前的方法执行完后再执行then()内部的程序，这样就避免了，数据没获取到等的问题。</li><li>.then里的<strong>参数为then()前的方法返回的值</strong></li></ol><h2 id="Vue定义"><a href="#Vue定义" class="headerlink" title="Vue定义"></a>Vue定义</h2><p>vue是一个单页面应用，即只有一个html文件</p><p>public/index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>&lt;%= webpackConfig.name %&gt;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main.js</p><p>vue-cli首先是帮我们引入了vue和App组件，通过new Vue建立了一个Vue的实例对象，然后就通过$mount方法将这个Vue实例挂载到了一个 id 名为 app 的标签上，然后通过render函数将App组件插入到了这个标签内。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import enLang from &#x27;element-ui/lib/locale/lang/en&#x27;// 如果使用中文语言包请默认支持，无需额外引入，请删除该依赖</span><br><span class="line"></span><br><span class="line">import &#x27;@/styles/index.scss&#x27; // global css</span><br><span class="line"></span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"></span><br><span class="line">import &#x27;./icons&#x27; // icon</span><br><span class="line">import &#x27;./permission&#x27; // permission control</span><br><span class="line">import &#x27;./utils/error-log&#x27; // error log</span><br><span class="line"></span><br><span class="line">import * as filters from &#x27;./filters&#x27; // global filters</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * If you don&#x27;t want to use mock-server</span><br><span class="line"> * you want to use MockJs for mock api</span><br><span class="line"> * you can execute: mockXHR()</span><br><span class="line"> *</span><br><span class="line"> * Currently MockJs will be used in the production environment,</span><br><span class="line"> * please remove it before going online ! ! !</span><br><span class="line"> */</span><br><span class="line">if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;</span><br><span class="line">  const &#123; mockXHR &#125; = require(&#x27;../mock&#x27;)</span><br><span class="line">  mockXHR()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.use(Element, &#123;</span><br><span class="line">  size: Cookies.get(&#x27;size&#x27;) || &#x27;medium&#x27;, // set element-ui default size</span><br><span class="line">  locale: enLang // 如果使用中文，无需设置，请删除</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// register global utility filters</span><br><span class="line">Object.keys(filters).forEach(key =&gt; &#123;</span><br><span class="line">  Vue.filter(key, filters[key])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">├── build                      // 构建相关  </span><br><span class="line">├── config                     // 配置相关</span><br><span class="line">├── src                        // 源代码</span><br><span class="line">│   ├── api                    // 所有请求</span><br><span class="line">│   ├── assets                 // 主题 字体等静态资源</span><br><span class="line">│   ├── components             // 全局公用组件</span><br><span class="line">│   ├── directive              // 全局指令:除了v-bind这样的自定义指令v-demo</span><br><span class="line">│   ├── filtres                // 全局 filter,用于常见的文本格式化</span><br><span class="line">│   ├── icons                  // 项目所有 svg icons</span><br><span class="line">│   ├── lang                   // 国际化 language</span><br><span class="line">│   ├── mock                   // 项目mock 模拟数据 需安装mockjs</span><br><span class="line">│   ├── router                 // 路由</span><br><span class="line">│   ├── store                  // 全局 store管理</span><br><span class="line">│   ├── styles                 // 全局样式</span><br><span class="line">│   ├── utils                  // 全局公用方法</span><br><span class="line">│   ├── vendor                 // 公用vendor</span><br><span class="line">│   ├── views                   // view，每个页面或者模块特定的业务组件则会写在当前 views 下面。如：@/views/article/components/xxx.vue。这样拆分大大减轻了维护成本。</span><br><span class="line">│   ├── App.vue                // 入口页面</span><br><span class="line">│   ├── main.js                // 入口 加载组件 初始化等</span><br><span class="line">│   └── permission.js          // 权限管理:全局路由守卫+登录判断</span><br><span class="line">├── static                     // 第三方不打包资源</span><br><span class="line">│   └── Tinymce                // 富文本</span><br><span class="line">├── .babelrc                   // babel-loader 配置</span><br><span class="line">├── eslintrc.js                // eslint 配置项</span><br><span class="line">├── .gitignore                 // git 忽略项</span><br><span class="line">├── favicon.ico                // favicon图标</span><br><span class="line">├── index.html                 // html模板</span><br><span class="line">└── package.json               // package.json</span><br></pre></td></tr></table></figure><h2 id="Vue-prototype"><a href="#Vue-prototype" class="headerlink" title="Vue.prototype"></a>Vue.prototype</h2><p>通过在原型上定义它们使其在每个 Vue 的实例中可用，不污染全局作用域</p><p>main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//$为防止被组件中相同变量覆盖</span></span><br><span class="line">Vue.prototype.$appName = <span class="string">&#x27;My App&#x27;</span></span><br></pre></td></tr></table></figure><p>可以在所有vue实例中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">beforeCreate</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$appName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例</p><ol><li><p>导入axios</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插件——异步请求 axios</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./axios.js&#x27;</span> </span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure></li></ol><h3 id="Vue-use和Vue-prototype的区别"><a href="#Vue-use和Vue-prototype的区别" class="headerlink" title="Vue.use和Vue.prototype的区别"></a>Vue.use和Vue.prototype的区别</h3><p><strong>相同点</strong>：<code>都是注册插件的方式，没有本质区别，都是在vue.prototype上添加了一个方法</code><br><strong>不同点</strong>：<code>vue.use适用于注册vue生态内的插件，vue.prototype适用于注册生态外的插件</code></p><h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>常和axios结合在一起使用</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/521e7ab063401c59c6d1aa8b10198af1.png" alt="img"></p><p>通过打印可以看出Promise是一个构造函数，有all、reject、resolve、then、catch等方法。这样用Promise new出来的对象肯定就有then、catch等方法。 </p><p>用<strong>Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数</strong>，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.testPromise()</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">methods</span>: &#123;</span><br><span class="line">   <span class="function"><span class="title">testPromise</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">       <span class="comment">//做一些异步操作</span></span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">&#x27;Promise执行&#x27;</span>);</span><br><span class="line">         resolve(<span class="string">&#x27;这是Promise返回的数据&#x27;</span>);</span><br><span class="line">       &#125;, <span class="number">2000</span>);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="comment">//相当于 var p = new Promise(()=&gt;&#123;&#125;)</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        api</span><br><span class="line">          .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//你的逻辑</span></span><br><span class="line">            resolve();</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//返回错误</span></span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resolve和reject：Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。</p><p>1、resolve：作用是把resolve的状态置为resolved，在resolve中返回Promise的数据。相当于普通函数的return。如果不需要返回数据，则resolve();即可。</p><p>2、reject：作用就是把Promise的状态置为rejected，这样在then中就能捕捉到，然后执行“失败”情况的回调。</p><p>Promise构造函数的参数是一个函数，函数里面的代码是异步的，即Promise里面的操作，和Promise()外面的操作时异步”同时”进行的。此外，只要在<strong>函数前面加上async 关键字，也可以指明函数是异步的。</strong></p><p>async关键字实际是通过Promise实现，如果async 函数中有返回一个值 ,当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回，但如果timeout 函数内部抛出错误，那么就会调用Promise.reject() 返回一个promise 对象。若某函数调用一个异步函数（比如内部含有promise），该函数应用async修饰。</p><p><strong>await表示“等待”，修饰返回promise 对象的表达式。注意await 关键字只能放到async 函数里面。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doubleAfter2seconds</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="number">2</span> * num)</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125; )</span><br><span class="line">&#125;<span class="comment">//写一个async 函数，从而可以使用await 关键字， await 后面放置的就是返回promise对象的一个表达式，所以它后面可以写上 doubleAfter2seconds 函数的调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testResult</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> doubleAfter2seconds(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="async和await的用法"><a href="#async和await的用法" class="headerlink" title="async和await的用法"></a>async和await的用法</h2><p>async 表示函数里有异步操作，</p><p>await 表示紧跟在后面的表达式需要等待结果。</p><p>同 Generator 函数一样，<strong>async</strong> 函数返回一个 <strong>Promise</strong> 对象，可以使用 <strong>then</strong> 方法添加回调函数。当函数执行的时候，<strong>一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</strong>（非阻塞）</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>1）表明程序里面可能有<strong>异步过程</strong>： async关键字表明程序里面可能有异步过程，里面可以有await关键字；当然全部是同步代码也没关系，但是这样async关键字就显得多余了；</p><p>2）非阻塞： async函数里面如果有异步过程会等待，但是async函数本身会马上返回，不会阻塞当前线程，可以简单认为，async函数工作在主线程，同步执行，不会阻塞界面渲染，async函数内部由await关键字修饰的异步过程，工作在相应的协程上，会阻塞等待异步任务的完成再返回；</p><p>3）<strong>async函数返回类型为Promise对象</strong>： 这是和普通函数本质上不同的地方，也是使用时重点注意的地方；<br>（1）return newPromise();这个符合async函数本意；<br>（2）return data;这个是同步函数的写法，这里是要特别注意的，这个时候，其实就相当于Promise.resolve(data);还是一个Promise对象，但是在调用async函数的地方通过简单的=是拿不到这个data的，因为返回值是一个Promise对象，所以需要用.then(data =&gt; { })函数才可以拿到这个data；<br>（3）如果没有返回值，相当于返回了Promise.resolve(undefined);</p><p>4）无等待 联想到Promise的特点，<strong>在没有await的情况下执行async函数，它会立即执行，返回一个Promise对象，并且绝对不会阻塞后面的语句</strong>，这和普通返回Promise对象的函数并无二致；</p><p>5）await不处理异步error： await是不管异步过程的reject(error)消息的，async函数返回的这个Promise对象的catch函数负责统一抓取内部所有异步过程的错误；async函数内部只要有一个异步过程发生错误，整个执行过程就中断，这个返回的Promise对象的catch就能抓取到这个错误；</p><p>5）async函数的执行： async函数执行和普通函数一样，函数名带个()就可以了，参数个数随意，没有限制，也需要有async关键字；只是返回值是一个Promise对象，可以用then函数得到返回值，用catch抓整个流程中发生的错误；</p><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>1）await只能在async函数内部使用：不能放在普通函数里面，否则会报错；</p><p>2）await关键字后面跟Promise对象：在Pending状态时，相应的协程会交出控制权，进入等待状态，这是协程的本质；</p><p>3）await是async wait的意思： wait的是resolve(data)的消息，并把数据data返回，比如下面代码中，当Promise对象由Pending变为Resolved的时候，变量a就等于data，然后再顺序执行下面的语句console.log(a)，这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// async process ...</span></span><br><span class="line">    <span class="keyword">return</span> resolve(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p><strong>4）await后面也可以跟同步代码：</strong> 不过系统会自动将其转化成一个Promsie对象，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">await</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 跟同步代码是一样的，还不如省事点，直接去掉await关键字</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;hello world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>5）await对于失败消息的处理： await只关心异步过程成功的消息resolve(data)，拿到相应的数据data，至于失败消息reject(error)，不关心不处理；对于错误的处理有以下几种方法供选择：<br>（1）让await后面的Promise对象自己catch；<br>（2）也可以让外面的async函数返回的Promise对象统一catch；<br>（3）像同步代码一样，放在一个try…catch结构中；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123; <span class="comment">// 这是React Native的回调函数，加个async关键字，没有任何影响，但是可以用await关键字</span></span><br><span class="line">    <span class="comment">// 将异步和同步的代码放在一个try..catch中，异常都能抓到</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> array = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">await</span> asyncFunction();  <span class="comment">// 这里用await关键字，就能拿到结果值；否则，没有await的话，只能拿到Promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>) &#123;  <span class="comment">// 这里会抛出异常，下面的catch也能抓到</span></span><br><span class="line">            array.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        alert(<span class="built_in">JSON</span>.stringify(error))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>6）await对于结果的处理： await是个运算符，用于组成表达式，await表达式的运算结果取决于它等的东西，如果它等到的不是一个Promise对象，那么await表达式的运算结果就是它等到的东西；如果它等到的是一个Promise对象，await就忙起来了，它会阻塞其后面的代码，等着Promise对象resolve，然后得到resolve的值，作为await表达式的运算结果；虽然是阻塞，但async函数调用并不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行，这也正是await必须用在async函数中的原因；</p><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>简介：ajax的升级版</p><p>Axios 是一个基于 <strong>Promise</strong> 的 HTTP 库，可以用在浏览器和 node.js 中；是请求资源的模块；通过promise对ajax的封装。<br>简单理解为：封装好的、基于promise的发送请求的方法，因此<strong>不用设置回调函数，直接去调用then方法。</strong></p><p>axios是通过Promise实现对ajax技术的一种封装，就像jquery对ajax的封装一样，axios回来的数据是promise，ajax回来的数据是回调，axios比ajax更好用更安全。</p><p>简单来说就是ajax技术实现了局部数据的刷新，axios实现了对ajax的封装；axios有的ajax都有，ajax有的axios不一定有。</p><p>总结一句话就是<strong>axios是ajax，ajax不止axios。</strong></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p><strong>create创建实例</strong>  默认get</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line">instance.get(<span class="string">&#x27;user/profile&#x27;</span>)</span><br><span class="line">axios#request(config)</span><br><span class="line">axios#get(url[, config])</span><br><span class="line">axios#<span class="keyword">delete</span>(url[, config])</span><br><span class="line">axios#head(url[, config])</span><br><span class="line">axios#options(url[, config])</span><br><span class="line">axios#post(url[, data[, config]])</span><br><span class="line">axios#put(url[, data[, config]])</span><br><span class="line">axios#patch(url[, data[, config]])</span><br><span class="line">axios#getUri([config])</span><br></pre></td></tr></table></figure><p><strong>Get</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为给定 ID 的 user 创建请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  <span class="comment">//处理成功地情况 简化写法 axios.get().then(response=&gt;&#123;&#125;)</span></span><br><span class="line">  <span class="comment">//response为成功返回的数据</span></span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//处理错误的情况</span></span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//根据参数不同，为不同处理情况</span></span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可选地，上面的请求可以这样做</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doEdiLogin</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.get(<span class="string">&quot;webresources/login/fileUreportList/loginEdiSystem&quot;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.data.code === <span class="string">&#x27;-1&#x27;</span>) &#123;</span><br><span class="line">        ElementUI.Message(&#123;</span><br><span class="line">          <span class="attr">message</span>: response.data.message,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> reject()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Post</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$http.post(<span class="string">&#x27;/webresources/login/activity/FileUreportResource/ureportExportUrl&#x27;</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;urlParam&#x27;</span>: urlParam,</span><br><span class="line">      <span class="string">&#x27;vuePath&#x27;</span>: vuePath</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.data.code === <span class="string">&#x27;-1&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">          <span class="attr">message</span>: response.data.message</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">window</span>.open(response.data, <span class="string">&#x27;_target&#x27;</span>)</span><br><span class="line">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在请求或响应被 <code>then</code> 或 <code>catch</code> 处理前拦截它们。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="易混语法"><a href="#易混语法" class="headerlink" title="易混语法"></a>易混语法</h3><ul><li><p><strong>axios(config)=axios.request(config)</strong>  通用/最本质的发任意类型请求的方式 默认get请求</p></li><li><p><strong>axios.create(config)</strong></p></li></ul><ol><li>根据指定配置创建一个新的 axios ,也就是每个axios 都有自己的配置</li><li>新的 axios 只是没有 取消请求 和 批量请求 的方法，其它所有语法都是一致的</li><li>为什么要这种语法？<ol><li>需求，项目中有部分接口需要的配置与另一部分接口的配置不太一样</li><li>解决：创建2个新的 axios ，每个都有自己的配置，分别对应不同要求的接口请求中</li></ol></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">   <span class="attr">baseURL</span>:<span class="string">&quot;http://localhost:3000&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用instance发请求</span></span><br><span class="line">instance(&#123;</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;/posts&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">instance.get(<span class="string">&quot;/posts&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>以vue-admin为例</p><ol><li><p>@/utils/reuqest.js  创建一个axios实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; MessageBox, Message &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create an axios instance</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: process.env.VUE_APP_BASE_API, <span class="comment">// url = base url + request url</span></span><br><span class="line">  <span class="comment">// withCredentials: true, // send cookies when cross-domain requests</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span> <span class="comment">// request timeout</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// request interceptor</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something before request is sent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (store.getters.token) &#123;</span><br><span class="line">      <span class="comment">// let each request carry token</span></span><br><span class="line">      <span class="comment">// [&#x27;X-Token&#x27;] is a custom headers key</span></span><br><span class="line">      <span class="comment">// please modify it according to the actual situation</span></span><br><span class="line">      config.headers[<span class="string">&#x27;X-Token&#x27;</span>] = getToken()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do something with request error</span></span><br><span class="line">    <span class="built_in">console</span>.log(error) <span class="comment">// for debug</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// response interceptor</span></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * If you want to get http information such as headers or status</span></span><br><span class="line"><span class="comment">   * Please return  response =&gt; response</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Determine the request status by custom code</span></span><br><span class="line"><span class="comment">   * Here is just an example</span></span><br><span class="line"><span class="comment">   * You can also judge the status by HTTP Status Code</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = response.data</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the custom code is not 20000, it is judged as an error.</span></span><br><span class="line">    <span class="keyword">if</span> (res.code !== <span class="number">20000</span>) &#123;</span><br><span class="line">      Message(&#123;</span><br><span class="line">        <span class="attr">message</span>: res.message || <span class="string">&#x27;Error&#x27;</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">        <span class="attr">duration</span>: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 50008: Illegal token; 50012: Other clients logged in; 50014: Token expired;</span></span><br><span class="line">      <span class="keyword">if</span> (res.code === <span class="number">50008</span> || res.code === <span class="number">50012</span> || res.code === <span class="number">50014</span>) &#123;</span><br><span class="line">        <span class="comment">// to re-login</span></span><br><span class="line">        MessageBox.confirm(<span class="string">&#x27;You have been logged out, you can cancel to stay on this page, or log in again&#x27;</span>, <span class="string">&#x27;Confirm logout&#x27;</span>, &#123;</span><br><span class="line">          <span class="attr">confirmButtonText</span>: <span class="string">&#x27;Re-Login&#x27;</span>,</span><br><span class="line">          <span class="attr">cancelButtonText</span>: <span class="string">&#x27;Cancel&#x27;</span>,</span><br><span class="line">          <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">        &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          store.dispatch(<span class="string">&#x27;user/resetToken&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            location.reload()</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(res.message || <span class="string">&#x27;Error&#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span> + error) <span class="comment">// for debug</span></span><br><span class="line">    Message(&#123;</span><br><span class="line">      <span class="attr">message</span>: error.message,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">      <span class="attr">duration</span>: <span class="number">5</span> * <span class="number">1000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></table></figure></li><li><p>@/api/user.js (具体用户请求实例)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/vue-element-admin/user/login&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/vue-element-admin/user/info&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123; token &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">logout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;/vue-element-admin/user/logout&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@/store/modules/user.js (管理用户的状态)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; login, logout, getInfo &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, removeToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router, &#123; resetRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>: getToken(),</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">avatar</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">introduction</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">roles</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步操作</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="attr">SET_TOKEN</span>: <span class="function">(<span class="params">state, token</span>) =&gt;</span> &#123;</span><br><span class="line">    state.token = token</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">SET_INTRODUCTION</span>: <span class="function">(<span class="params">state, introduction</span>) =&gt;</span> &#123;</span><br><span class="line">    state.introduction = introduction</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">SET_NAME</span>: <span class="function">(<span class="params">state, name</span>) =&gt;</span> &#123;</span><br><span class="line">    state.name = name</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">SET_AVATAR</span>: <span class="function">(<span class="params">state, avatar</span>) =&gt;</span> &#123;</span><br><span class="line">    state.avatar = avatar</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">SET_ROLES</span>: <span class="function">(<span class="params">state, roles</span>) =&gt;</span> &#123;</span><br><span class="line">    state.roles = roles</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步操作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// user login</span></span><br><span class="line">  <span class="function"><span class="title">login</span>(<span class="params">&#123; commit &#125;, userInfo</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = userInfo</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//相当于request.get(&#x27;/vue-element-admin/user/login&#x27;,&#123;username,password&#125;)</span></span><br><span class="line">      <span class="comment">//若成功，返回的值为reponse响应值</span></span><br><span class="line">      login(&#123; <span class="attr">username</span>: username.trim(), <span class="attr">password</span>: password &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//const data = reponse.data</span></span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line">        <span class="comment">//保存状态变量</span></span><br><span class="line">        commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, data.token)</span><br><span class="line">        setToken(data.token)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get user info</span></span><br><span class="line">  <span class="function"><span class="title">getInfo</span>(<span class="params">&#123; commit, state &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      getInfo(state.token).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">          reject(<span class="string">&#x27;Verification failed, please Login again.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; roles, name, avatar, introduction &#125; = data</span><br><span class="line"></span><br><span class="line">        <span class="comment">// roles must be a non-empty array</span></span><br><span class="line">        <span class="keyword">if</span> (!roles || roles.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          reject(<span class="string">&#x27;getInfo: roles must be a non-null array!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        commit(<span class="string">&#x27;SET_ROLES&#x27;</span>, roles)</span><br><span class="line">        commit(<span class="string">&#x27;SET_NAME&#x27;</span>, name)</span><br><span class="line">        commit(<span class="string">&#x27;SET_AVATAR&#x27;</span>, avatar)</span><br><span class="line">        commit(<span class="string">&#x27;SET_INTRODUCTION&#x27;</span>, introduction)</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// user logout</span></span><br><span class="line">  <span class="function"><span class="title">logout</span>(<span class="params">&#123; commit, state, dispatch &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      logout(state.token).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        commit(<span class="string">&#x27;SET_ROLES&#x27;</span>, [])</span><br><span class="line">        removeToken()</span><br><span class="line">        resetRouter()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reset visited views and cached views</span></span><br><span class="line">        <span class="comment">// to fixed https://github.com/PanJiaChen/vue-element-admin/issues/2485</span></span><br><span class="line">        dispatch(<span class="string">&#x27;tagsView/delAllViews&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove token</span></span><br><span class="line">  <span class="function"><span class="title">resetToken</span>(<span class="params">&#123; commit &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      commit(<span class="string">&#x27;SET_ROLES&#x27;</span>, [])</span><br><span class="line">      removeToken()</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dynamically modify permissions</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">changeRoles</span>(<span class="params">&#123; commit, dispatch &#125;, role</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> token = role + <span class="string">&#x27;-token&#x27;</span></span><br><span class="line"></span><br><span class="line">    commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, token)</span><br><span class="line">    setToken(token)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; roles &#125; = <span class="keyword">await</span> dispatch(<span class="string">&#x27;getInfo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    resetRouter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate accessible routes map based on roles</span></span><br><span class="line">    <span class="keyword">const</span> accessRoutes = <span class="keyword">await</span> dispatch(<span class="string">&#x27;permission/generateRoutes&#x27;</span>, roles, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">// dynamically add accessible routes</span></span><br><span class="line">    router.addRoutes(accessRoutes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset visited views and cached views</span></span><br><span class="line">    dispatch(<span class="string">&#x27;tagsView/delAllViews&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@/views/login/index.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;login-container&quot;&gt;</span><br><span class="line">    &lt;el-form ref=&quot;loginForm&quot; :model=&quot;loginForm&quot; :rules=&quot;loginRules&quot; class=&quot;login-form&quot; autocomplete=&quot;on&quot; label-position=&quot;left&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class=&quot;title-container&quot;&gt;</span><br><span class="line">        &lt;h3 class=&quot;title&quot;&gt;Login Form&lt;/h3&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-form-item prop=&quot;username&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;svg-container&quot;&gt;</span><br><span class="line">          &lt;svg-icon icon-class=&quot;user&quot; /&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;el-input</span><br><span class="line">          ref=&quot;username&quot;</span><br><span class="line">          v-model=&quot;loginForm.username&quot;</span><br><span class="line">          placeholder=&quot;Username&quot;</span><br><span class="line">          name=&quot;username&quot;</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          tabindex=&quot;1&quot;</span><br><span class="line">          autocomplete=&quot;on&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-tooltip v-model=&quot;capsTooltip&quot; content=&quot;Caps lock is On&quot; placement=&quot;right&quot; manual&gt;</span><br><span class="line">        &lt;el-form-item prop=&quot;password&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;svg-container&quot;&gt;</span><br><span class="line">            &lt;svg-icon icon-class=&quot;password&quot; /&gt;</span><br><span class="line">          &lt;/span&gt;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            :key=&quot;passwordType&quot;</span><br><span class="line">            ref=&quot;password&quot;</span><br><span class="line">            v-model=&quot;loginForm.password&quot;</span><br><span class="line">            :type=&quot;passwordType&quot;</span><br><span class="line">            placeholder=&quot;Password&quot;</span><br><span class="line">            name=&quot;password&quot;</span><br><span class="line">            tabindex=&quot;2&quot;</span><br><span class="line">            autocomplete=&quot;on&quot;</span><br><span class="line">            @keyup.native=&quot;checkCapslock&quot;</span><br><span class="line">            @blur=&quot;capsTooltip = false&quot;</span><br><span class="line">            @keyup.enter.native=&quot;handleLogin&quot;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;span class=&quot;show-pwd&quot; @click=&quot;showPwd&quot;&gt;</span><br><span class="line">            &lt;svg-icon :icon-class=&quot;passwordType === &#x27;password&#x27; ? &#x27;eye&#x27; : &#x27;eye-open&#x27;&quot; /&gt;</span><br><span class="line">          &lt;/span&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">      &lt;/el-tooltip&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-button :loading=&quot;loading&quot; type=&quot;primary&quot; style=&quot;width:100%;margin-bottom:30px;&quot; @click.native.prevent=&quot;handleLogin&quot;&gt;Login&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div style=&quot;position:relative&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;tips&quot;&gt;</span><br><span class="line">          &lt;span&gt;Username : admin&lt;/span&gt;</span><br><span class="line">          &lt;span&gt;Password : any&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;tips&quot;&gt;</span><br><span class="line">          &lt;span style=&quot;margin-right:18px;&quot;&gt;Username : editor&lt;/span&gt;</span><br><span class="line">          &lt;span&gt;Password : any&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;el-button class=&quot;thirdparty-button&quot; type=&quot;primary&quot; @click=&quot;showDialog=true&quot;&gt;</span><br><span class="line">          Or connect with</span><br><span class="line">        &lt;/el-button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog title=&quot;Or connect with&quot; :visible.sync=&quot;showDialog&quot;&gt;</span><br><span class="line">      Can not be simulated on local, so please combine you own business simulation! ! !</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;social-sign /&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; validUsername &#125; from &#x27;@/utils/validate&#x27;</span><br><span class="line">import SocialSign from &#x27;./components/SocialSignin&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Login&#x27;,</span><br><span class="line">  components: &#123; SocialSign &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    const validateUsername = (rule, value, callback) =&gt; &#123;</span><br><span class="line">      if (!validUsername(value)) &#123;</span><br><span class="line">        callback(new Error(&#x27;Please enter the correct user name&#x27;))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const validatePassword = (rule, value, callback) =&gt; &#123;</span><br><span class="line">      if (value.length &lt; 6) &#123;</span><br><span class="line">        callback(new Error(&#x27;The password can not be less than 6 digits&#x27;))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      loginForm: &#123;</span><br><span class="line">        username: &#x27;admin&#x27;,</span><br><span class="line">        password: &#x27;111111&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      loginRules: &#123;</span><br><span class="line">        username: [&#123; required: true, trigger: &#x27;blur&#x27;, validator: validateUsername &#125;],</span><br><span class="line">        password: [&#123; required: true, trigger: &#x27;blur&#x27;, validator: validatePassword &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      passwordType: &#x27;password&#x27;,</span><br><span class="line">      capsTooltip: false,</span><br><span class="line">      loading: false,</span><br><span class="line">      showDialog: false,</span><br><span class="line">      redirect: undefined,</span><br><span class="line">      otherQuery: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    $route: &#123;</span><br><span class="line">      handler: function(route) &#123;</span><br><span class="line">        const query = route.query</span><br><span class="line">        if (query) &#123;</span><br><span class="line">          this.redirect = query.redirect</span><br><span class="line">          this.otherQuery = this.getOtherQuery(query)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    // window.addEventListener(&#x27;storage&#x27;, this.afterQRScan)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    if (this.loginForm.username === &#x27;&#x27;) &#123;</span><br><span class="line">      this.$refs.username.focus()</span><br><span class="line">    &#125; else if (this.loginForm.password === &#x27;&#x27;) &#123;</span><br><span class="line">      this.$refs.password.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    // window.removeEventListener(&#x27;storage&#x27;, this.afterQRScan)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    checkCapslock(e) &#123;</span><br><span class="line">      const &#123; key &#125; = e</span><br><span class="line">      this.capsTooltip = key &amp;&amp; key.length === 1 &amp;&amp; (key &gt;= &#x27;A&#x27; &amp;&amp; key &lt;= &#x27;Z&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    showPwd() &#123;</span><br><span class="line">      if (this.passwordType === &#x27;password&#x27;) &#123;</span><br><span class="line">        this.passwordType = &#x27;&#x27;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.passwordType = &#x27;password&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.$refs.password.focus()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleLogin() &#123;</span><br><span class="line">      this.$refs.loginForm.validate(valid =&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          this.loading = true</span><br><span class="line">          //调用@/store/modules/user.js里的action:login</span><br><span class="line">          this.$store.dispatch(&#x27;user/login&#x27;, this.loginForm)</span><br><span class="line">            .then(() =&gt; &#123;</span><br><span class="line">              //成功则跳转路由</span><br><span class="line">              this.$router.push(&#123; path: this.redirect || &#x27;/&#x27;, query: this.otherQuery &#125;)</span><br><span class="line">              this.loading = false</span><br><span class="line">            &#125;)</span><br><span class="line">            //失败则状态为false</span><br><span class="line">            .catch(() =&gt; &#123;</span><br><span class="line">              this.loading = false</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&#x27;error submit!!&#x27;)</span><br><span class="line">          return false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getOtherQuery(query) &#123;</span><br><span class="line">      return Object.keys(query).reduce((acc, cur) =&gt; &#123;</span><br><span class="line">        if (cur !== &#x27;redirect&#x27;) &#123;</span><br><span class="line">          acc[cur] = query[cur]</span><br><span class="line">        &#125;</span><br><span class="line">        return acc</span><br><span class="line">      &#125;, &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // afterQRScan() &#123;</span><br><span class="line">    //   if (e.key === &#x27;x-admin-oauth-code&#x27;) &#123;</span><br><span class="line">    //     const code = getQueryObject(e.newValue)</span><br><span class="line">    //     const codeMap = &#123;</span><br><span class="line">    //       wechat: &#x27;code&#x27;,</span><br><span class="line">    //       tencent: &#x27;code&#x27;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     const type = codeMap[this.auth_type]</span><br><span class="line">    //     const codeName = code[type]</span><br><span class="line">    //     if (codeName) &#123;</span><br><span class="line">    //       this.$store.dispatch(&#x27;LoginByThirdparty&#x27;, codeName).then(() =&gt; &#123;</span><br><span class="line">    //         this.$router.push(&#123; path: this.redirect || &#x27;/&#x27; &#125;)</span><br><span class="line">    //       &#125;)</span><br><span class="line">    //     &#125; else &#123;</span><br><span class="line">    //       alert(&#x27;第三方登录失败&#x27;)</span><br><span class="line">    //     &#125;</span><br><span class="line">    //   &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue router"></a>Vue router</h2><p>作用：</p><p>Vue Router路由常常用于对组件进行映射与跳转。如此更方便我们实现不同页面组件的切换而实现传统网页a链接跳转的相似功能，也支持我们对子组件进行管理、放置。</p><ol><li>普通路由</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./components/home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routers = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Home</span><br><span class="line">  &#125;，  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Home</span><br><span class="line">  &#125;，</span><br><span class="line">]<span class="keyword">export</span> <span class="keyword">default</span> routers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> routers <span class="keyword">from</span> <span class="string">&#x27;./routers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: routers</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li><p>动态路由</p></li><li><p>嵌套路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./components/home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> First <span class="keyword">from</span> <span class="string">&#x27;./components/children/first.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;./components/children/login.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routers = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Home,　　 <span class="attr">children</span>: [ 　　　&#123; 　　　　<span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,  　　　 <span class="attr">component</span>: Login 　　  &#125;　　]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Home,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: Login</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;first&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: First</span><br><span class="line">      &#125; </span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> routers</span><br></pre></td></tr></table></figure></li></ol><ol><li>编程式导航</li></ol><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20221010112101651.png" alt="image-20221010112101651"></p><p>​        this.$router.push(…)实现路由跳转</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: 不带参数</span><br><span class="line">  <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/home&#x27;</span>);</span><br><span class="line">  <span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>&#125;);</span><br><span class="line">  <span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>: query 携带参数</span><br><span class="line">   <span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">query</span>: &#123;<span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>&#125;);</span><br><span class="line">   <span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">query</span>: &#123;<span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>&#125;);</span><br><span class="line">   取参数: $router.query.id</span><br><span class="line">   取参数: <span class="built_in">this</span>.$router.query.id</span><br><span class="line">   </span><br><span class="line"><span class="number">3</span>： 传递参数: 传参</span><br><span class="line">    <span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">params</span>: &#123;<span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>&#125;&#125;);</span><br><span class="line">    路由配置参数: path： <span class="string">&quot;/home/:id&quot;</span>  或者 path: <span class="string">&quot;/home:id&quot;</span></span><br><span class="line">    不配置path:  刷新页面id可能会消失。</span><br><span class="line">    html 取 $router.params.id</span><br><span class="line">    <span class="attr">script</span>: 脚本取参: $this.$router.params.id;</span><br><span class="line"> </span><br><span class="line"><span class="number">4</span>: query 和 params 的区别：</span><br><span class="line">   query 类似于get, 跳转页面之后, ur了参数后边会拼接参数, 类似: id=<span class="number">1</span>; 非常重要性这样可以传下去, 密码之类还是用params 刷新页面id 还是存在到但是 params 类似post 请求, 跳转页面之后, url不会拼接参数, 但是刷新页面id 会消失。</span><br></pre></td></tr></table></figure><h3 id="路由元信息-meta"><a href="#路由元信息-meta" class="headerlink" title="路由元信息 meta"></a>路由元信息 meta</h3><p>路由定义中meta字段的作用：可以将任意信息附加到路由上，如过渡名称、谁可以访问路由（权限）等。这些事情都可以通过接收属性对象的meta属性来实现，并且它可以在路由地址和导航守卫上都被访问到。</p><h3 id="按需加载组件"><a href="#按需加载组件" class="headerlink" title="按需加载组件"></a>按需加载组件</h3><p>像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后，一般情况下，会放在一个单独的js文件中。但是，如果很多的页面都放在同一个js文件中，必然会造成这个页面非常大，造成进入首页时，需要加载的内容过多，时间过长，会出现长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。<br>路由懒加载有着诸如：“只有第一次会加载页面，以后的每次页面切换，只需要进行组件替换。减少了请求体积，加快页面的响应速度，降低了对服务器的压力”等等优点。<br>为了解决上面的问题，我们需要对Vue实现组件<strong>懒加载（按需加载）</strong>。<br>前端开发使用Vue框架 路由这一块默认是这样的这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWord <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWord&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;@/components/Login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">&#x27;@/components/Index&#x27;</span></span><br></pre></td></tr></table></figure><p>这样做的结果就是<a href="https://so.csdn.net/so/search?q=webpack&amp;spm=1001.2101.3001.7020">webpack</a>在npm run build的时候会打包成一个整个的js文件，如果页面一多，会导致这个文件非常大，加载缓慢，为了解决这个问题，需要将他分成多个小文件，而且还要实现异步按需加载，即用到了再加载，而不用一股脑全部加载，最常用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> Login=<span class="function">()=&gt;</span><span class="function"><span class="title">import</span>(<span class="params"><span class="string">&#x27;../component/login/login&#x27;</span></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">path</span>:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;Login&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>:Login</span><br><span class="line">  &#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/guide&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: Layout,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/guide/index&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/guide/index&#x27;</span>),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Guide&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123; <span class="attr">title</span>: <span class="string">&#x27;Guide&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;guide&#x27;</span>, <span class="attr">noCache</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>1.作用：对<strong>路由</strong>进行<strong>权限控制</strong></p><p>2.分类：全局路由守卫，独享路由守卫，组件内路由守卫</p><p>以vue-admin-ui为例：</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/7647e0e64d1d1e92b846cb712a01ad93_1898x1270.png" alt="img"></p><p>全局守卫  @/permission.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Message &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> NProgress <span class="keyword">from</span> <span class="string">&#x27;nprogress&#x27;</span> <span class="comment">// progress bar</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;nprogress/nprogress.css&#x27;</span> <span class="comment">// progress bar style</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span> <span class="comment">// get token from cookie</span></span><br><span class="line"><span class="keyword">import</span> getPageTitle <span class="keyword">from</span> <span class="string">&#x27;@/utils/get-page-title&#x27;</span></span><br><span class="line"></span><br><span class="line">NProgress.configure(&#123; <span class="attr">showSpinner</span>: <span class="literal">false</span> &#125;) <span class="comment">// NProgress Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&#x27;/login&#x27;</span>, <span class="string">&#x27;/auth-redirect&#x27;</span>] <span class="comment">// no redirect whitelist</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局前置路由守卫：初始化时执行、每一次路由切换之前调用</span></span><br><span class="line"><span class="comment">//to和from都是路由对象</span></span><br><span class="line"><span class="comment">// next()  //没有next所有的路由跳转都无效</span></span><br><span class="line">router.beforeEach(<span class="keyword">async</span>(to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// start progress bar</span></span><br><span class="line">  NProgress.start()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set page title</span></span><br><span class="line">  <span class="built_in">document</span>.title = getPageTitle(to.meta.title)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// determine whether the user has logged in</span></span><br><span class="line">  <span class="comment">//从cookie获取token</span></span><br><span class="line">  <span class="keyword">const</span> hasToken = getToken()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasToken) &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.path === <span class="string">&#x27;/login&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// if is logged in, redirect to the home page</span></span><br><span class="line">      next(&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">      NProgress.done() <span class="comment">// hack: https://github.com/PanJiaChen/vue-element-admin/pull/2939</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// determine whether the user has obtained his permission roles through getInfo</span></span><br><span class="line">      <span class="keyword">const</span> hasRoles = store.getters.roles &amp;&amp; store.getters.roles.length &gt; <span class="number">0</span></span><br><span class="line">      <span class="comment">//判断用户角色是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (hasRoles) &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// get user info</span></span><br><span class="line">          <span class="comment">// note: roles must be a object array! such as: [&#x27;admin&#x27;] or ,[&#x27;developer&#x27;,&#x27;editor&#x27;]</span></span><br><span class="line">           <span class="comment">//异步获取用户角色</span></span><br><span class="line">          <span class="keyword">const</span> &#123; roles &#125; = <span class="keyword">await</span> store.dispatch(<span class="string">&#x27;user/getInfo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// generate accessible routes map based on roles</span></span><br><span class="line">          <span class="comment">//根据用户角色，动态生成路由</span></span><br><span class="line">          <span class="keyword">const</span> accessRoutes = <span class="keyword">await</span> store.dispatch(<span class="string">&#x27;permission/generateRoutes&#x27;</span>, roles)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// dynamically add accessible routes</span></span><br><span class="line">          <span class="comment">//rooter.addRoutes:Dynamically add more routes to the router. The argument must be an Array using the same route config format with the routes constructor option.</span></span><br><span class="line">          router.addRoutes(accessRoutes)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// hack method to ensure that addRoutes is complete</span></span><br><span class="line">          <span class="comment">// set the replace: true, so the navigation will not leave a history record</span></span><br><span class="line">          next(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// remove token and go to login page to re-login</span></span><br><span class="line">          <span class="keyword">await</span> store.dispatch(<span class="string">&#x27;user/resetToken&#x27;</span>)</span><br><span class="line">          Message.error(error || <span class="string">&#x27;Has Error&#x27;</span>)</span><br><span class="line">          next(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">          NProgress.done()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* has no token*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (whiteList.indexOf(to.path) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// in the free login whitelist, go directly</span></span><br><span class="line">      next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// other pages that do not have permission to access are redirected to the login page.</span></span><br><span class="line">      next(<span class="string">`/login?redirect=<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">      NProgress.done()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置路由守卫</span></span><br><span class="line">router.afterEach(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// finish progress bar</span></span><br><span class="line">  NProgress.done()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。</p></li><li><p>当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。</p></li><li><p>调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</p></li><li><p>使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。</p></li></ol><p><strong>独享路由守卫</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/test&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Test.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">meta</span>:&#123;</span><br><span class="line">    <span class="attr">isAuth</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">title</span>:<span class="string">&#x27;测试&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//独享路由守卫（注意：没有独享后置路由守卫，他可以配合全局后置路由守卫）</span></span><br><span class="line">  <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(to.meta.isAuth)&#123;  <span class="comment">//判断是否需要鉴权</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>)===<span class="string">&#x27;atguigu&#x27;</span>)&#123;  <span class="comment">//权限控制的具体规则</span></span><br><span class="line">        next()</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        alert(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>组件内路由守卫</strong></p><p>组件内路由守卫和全局前置后置守卫还不一样，组件内守卫包括进入组件之前调用beforeRouteEnter和离开组件时调用beforeRouteLeave,这里的离开组件时并不是全局后置路由守卫，而是指，当前组件被切换到其他组件时。</p><p>router=&gt;index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/void&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;void&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Void.vue&#x27;</span>),</span><br><span class="line">  <span class="attr">meta</span>:&#123;</span><br><span class="line">    <span class="attr">isAuth</span>:ture,  <span class="comment">//是否需要权限校验</span></span><br><span class="line">    <span class="attr">title</span>:<span class="string">&#x27;新闻&#x27;</span>,  <span class="comment">//用于修改网页标题</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>views=&gt;Void.vue</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Category <span class="keyword">from</span> <span class="string">&#x27;@/components/Category.vue&#x27;</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Void&#x27;</span>,</span><br><span class="line">    <span class="attr">components</span>:&#123; Category&#125;,</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//通过路由规则，进入改组件时被调用</span></span><br><span class="line">    <span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;beforeRouteEnter&#x27;</span>,to,<span class="keyword">from</span>);<span class="comment">//to一定是本组件的路由</span></span><br><span class="line">      <span class="keyword">if</span>(to.meta.isAuth)&#123;  <span class="comment">//判断是否需要鉴权，就不用to.path === &#x27;/home/news&#x27; || to.path === &#x27;/home/msg&#x27;</span></span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;school&#x27;</span>)===<span class="string">&#x27;atguigu&#x27;</span>)&#123;  <span class="comment">//权限控制的具体规则</span></span><br><span class="line">            next()</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          next()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//通过路由规则，离开该组件时被调用</span></span><br><span class="line">    <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;beforeRouteLeave&#x27;</span>,to,<span class="keyword">from</span>); <span class="comment">//from一定是本组件的路由</span></span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>注释：什么时通过路由规则：通过切换地址栏中的路径，而不是直接挂载到APP中首次加载时。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>这里我个人建议不要为了用 vuex 而用 vuex。就拿我司的后台项目来说，它虽然比较庞大，几十个业务模块，几十种权限，但业务之间的耦合度是很低的，文章模块和评论模块几乎是俩个独立的东西，所以根本没有必要使用 vuex 来存储data，<strong>每个页面里存放自己的 data 就行</strong>。当然有些数据还是需要用 vuex 来<strong>统一管理的，如登录token,用户信息，或者是一些全局个人偏好设置等</strong>，还是用vuex管理更加的方便，具体当然还是要结合自己的业务场景的。总之还是那句话，不要为了用vuex而用vuex！</p><p>定义：<strong>vuex是一个专为vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</strong></p><p>类似于threadlocal里的共享变量</p><p>在vue中，store用于<strong>管理状态、共享数据</strong>以及在<strong>各个组件之间管理外部状态</strong>，store是vuex应用的核心，也就是一个容器，包含着应用中大部分的状态，更改store中的状态唯一方法是提交mutation。</p><p>vuex中一共有五个状态 <strong>State Getter Mutation  Action  Module</strong></p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>提供唯一的公共数据源，所有共享的数据统一放到store的state进行储存，相似与data</p><p> 在vuex中state中定义数据，可以在任何组件中进行调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://webpack.js.org/guides/dependency-management/#requirecontext</span></span><br><span class="line"><span class="keyword">const</span> modulesFiles = <span class="built_in">require</span>.context(<span class="string">&#x27;./modules&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.js$/</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// you do not need `import app from &#x27;./modules/app&#x27;`</span></span><br><span class="line"><span class="comment">// it will auto require all vuex module from modules file</span></span><br><span class="line"><span class="keyword">const</span> modules = modulesFiles.keys().reduce(<span class="function">(<span class="params">modules, modulePath</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// set &#x27;./app.js&#x27; =&gt; &#x27;app&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> moduleName = modulePath.replace(<span class="regexp">/^\.\/(.*)\.\w+$/</span>, <span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> value = modulesFiles(modulePath)</span><br><span class="line">  modules[moduleName] = value.default</span><br><span class="line">  <span class="keyword">return</span> modules</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules,</span><br><span class="line">  getters</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p><strong>调用：</strong></p><p>方法一：</p><p>在标签中直接使用</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/c08338e0919843ab9a219e176848b0e6.png" alt="img"></p><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.state.全局数据名称</span><br></pre></td></tr></table></figure><p>方法三：</p><p>从vuex中按需导入mapstate函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapState &#125; from &quot;vuex&quot;;</span><br></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><p>其中<strong>参数state参数是必须的，也可以自己传递一个参数</strong></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/3bbcbd67e9bf4c839f7a4b450342345b.png" alt="img"></p><p><strong>在组件中使用：</strong></p><p> 定义两个按钮进行加减操作</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/0aa47bfe5bd4432a91b1de33c24a8fb1.png" alt="img"></p><p>方法一：</p><p>注意：使用commit触发Mutation操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line"><span class="comment">//加法</span></span><br><span class="line"><span class="function"><span class="title">btn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&quot;addcount&quot;</span>,<span class="number">10</span>)     <span class="comment">//每次加十</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function"><span class="title">btn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&quot;reduce&quot;</span>) </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action和Mutation相似，Mutation 不能进行异步操作，若要进行异步操作，就得使用Action</p><p><strong>在vuex中定义：</strong></p><p><strong>将上面的减法操作改为异步操作</strong></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/27f7cb4d481f492fb57ed7c126fcb908.png" alt="img"></p><p><strong>在组件中使用：</strong></p><p>方法一：</p><p>直接使用 <strong>dispatch触发Action函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;reduce&quot;</span>)</span><br></pre></td></tr></table></figure><p>方法二：使用辅助函数</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/b1aa7e935a9e4029a83ab369f9e959f9.png" alt="img"></p><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>类似于vue中的computed，进行缓存，对于Store中的数据进行加工处理形成新的数据</p><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>当遇见大型项目时，数据量大，store就会显得很臃肿</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><h3 id="vue-element-admin实战分析"><a href="#vue-element-admin实战分析" class="headerlink" title="vue-element-admin实战分析"></a>vue-element-admin实战分析</h3><p>@/store文件夹组成：</p><p>modules文件夹(模块化开发，每个模块拥有自己的state等)、getter.js（<em>这里是get方法,并且每次打开浏览器优先执行该方法，获取所有的状态</em> ）、index.js</p><p>modules: app.js、errorLog.js、permission.js、setting.js、tagView.js、user.js</p><p>以user.js为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; login, logout, getInfo &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, removeToken &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils/auth&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router, &#123; resetRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理用户的各个状态信息，如token、name、avatar等</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">token</span>: getToken(),</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">avatar</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">introduction</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">roles</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改用户的状态信息，同步方法,通过this.$store.commit(&quot;SET_TOKEN&quot;,token)调用</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="comment">//state:必须的第一个参数，token根据用户传入</span></span><br><span class="line">  <span class="attr">SET_TOKEN</span>: <span class="function">(<span class="params">state, token</span>) =&gt;</span> &#123;</span><br><span class="line">    state.token = token</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">SET_INTRODUCTION</span>: <span class="function">(<span class="params">state, introduction</span>) =&gt;</span> &#123;</span><br><span class="line">    state.introduction = introduction</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">SET_NAME</span>: <span class="function">(<span class="params">state, name</span>) =&gt;</span> &#123;</span><br><span class="line">    state.name = name</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">SET_AVATAR</span>: <span class="function">(<span class="params">state, avatar</span>) =&gt;</span> &#123;</span><br><span class="line">    state.avatar = avatar</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">SET_ROLES</span>: <span class="function">(<span class="params">state, roles</span>) =&gt;</span> &#123;</span><br><span class="line">    state.roles = roles</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步方法，通过this.$store.dispatch(&quot;login&quot;)调用</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">// user login</span></span><br><span class="line">  <span class="function"><span class="title">login</span>(<span class="params">&#123; commit &#125;, userInfo</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = userInfo</span><br><span class="line">    <span class="comment">//异步返回对象Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//调用api.user中的login方法，axios请求地址，返回response对象</span></span><br><span class="line">      login(&#123; <span class="attr">username</span>: username.trim(), <span class="attr">password</span>: password &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//es6简化写法，原为 const data = response.data</span></span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line">        <span class="comment">//调用mutation里的set_token方法，赋予token</span></span><br><span class="line">        commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, data.token)</span><br><span class="line">        <span class="comment">//调用认证模块里的setToken方法</span></span><br><span class="line">        setToken(data.token)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// get user info</span></span><br><span class="line">  <span class="function"><span class="title">getInfo</span>(<span class="params">&#123; commit, state &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      getInfo(state.token).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = response</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">          reject(<span class="string">&#x27;Verification failed, please Login again.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; roles, name, avatar, introduction &#125; = data</span><br><span class="line"></span><br><span class="line">        <span class="comment">// roles must be a non-empty array</span></span><br><span class="line">        <span class="keyword">if</span> (!roles || roles.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          reject(<span class="string">&#x27;getInfo: roles must be a non-null array!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        commit(<span class="string">&#x27;SET_ROLES&#x27;</span>, roles)</span><br><span class="line">        commit(<span class="string">&#x27;SET_NAME&#x27;</span>, name)</span><br><span class="line">        commit(<span class="string">&#x27;SET_AVATAR&#x27;</span>, avatar)</span><br><span class="line">        commit(<span class="string">&#x27;SET_INTRODUCTION&#x27;</span>, introduction)</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// user logout</span></span><br><span class="line">  <span class="function"><span class="title">logout</span>(<span class="params">&#123; commit, state, dispatch &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      logout(state.token).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        commit(<span class="string">&#x27;SET_ROLES&#x27;</span>, [])</span><br><span class="line">        removeToken()</span><br><span class="line">        resetRouter()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reset visited views and cached views</span></span><br><span class="line">        <span class="comment">// to fixed https://github.com/PanJiaChen/vue-element-admin/issues/2485</span></span><br><span class="line">        dispatch(<span class="string">&#x27;tagsView/delAllViews&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">        resolve()</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// remove token</span></span><br><span class="line">  <span class="function"><span class="title">resetToken</span>(<span class="params">&#123; commit &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      commit(<span class="string">&#x27;SET_ROLES&#x27;</span>, [])</span><br><span class="line">      removeToken()</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dynamically modify permissions</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">changeRoles</span>(<span class="params">&#123; commit, dispatch &#125;, role</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> token = role + <span class="string">&#x27;-token&#x27;</span></span><br><span class="line"></span><br><span class="line">    commit(<span class="string">&#x27;SET_TOKEN&#x27;</span>, token)</span><br><span class="line">    setToken(token)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; roles &#125; = <span class="keyword">await</span> dispatch(<span class="string">&#x27;getInfo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    resetRouter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate accessible routes map based on roles</span></span><br><span class="line">    <span class="keyword">const</span> accessRoutes = <span class="keyword">await</span> dispatch(<span class="string">&#x27;permission/generateRoutes&#x27;</span>, roles, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="comment">// dynamically add accessible routes</span></span><br><span class="line">    router.addRoutes(accessRoutes)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset visited views and cached views</span></span><br><span class="line">    dispatch(<span class="string">&#x27;tagsView/delAllViews&#x27;</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getter.js(存放操作变量的键值对)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getters = &#123;<span class="comment">//getters的作用只是简化写法,不要用了,直接 state.user.orgnId就行,wxl</span></span><br><span class="line">  <span class="attr">sidebar</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.app.sidebar,</span><br><span class="line">  <span class="attr">language</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.app.language,</span><br><span class="line">  <span class="attr">visitedViews</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.app.visitedViews,</span><br><span class="line">  <span class="attr">cachedViews</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.app.cachedViews,</span><br><span class="line">  <span class="attr">selectedView</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.app.selectedView,</span><br><span class="line">  <span class="attr">token</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.token,</span><br><span class="line">  <span class="attr">avatar</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.avatar,</span><br><span class="line">  <span class="attr">name</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.name,</span><br><span class="line">  <span class="attr">skin</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.skin,</span><br><span class="line">  <span class="attr">introduction</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.introduction,</span><br><span class="line">  <span class="attr">status</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.status,</span><br><span class="line">  <span class="attr">roles</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.roles,</span><br><span class="line">  <span class="attr">setting</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.setting,</span><br><span class="line">  <span class="attr">permission_routers</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.permission.routers,</span><br><span class="line">  <span class="attr">hdMenu</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.permission.hdMenu,</span><br><span class="line">  <span class="attr">addRouters</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.permission.addRouters,</span><br><span class="line">  <span class="attr">companyId</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.companyId</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br></pre></td></tr></table></figure><p>index.js（配置并创建vuex.store）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://webpack.js.org/guides/dependency-management/#requirecontext</span></span><br><span class="line"><span class="keyword">const</span> modulesFiles = <span class="built_in">require</span>.context(<span class="string">&#x27;./modules&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.js$/</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// you do not need `import app from &#x27;./modules/app&#x27;`</span></span><br><span class="line"><span class="comment">// it will auto require all vuex module from modules file</span></span><br><span class="line"><span class="keyword">const</span> modules = modulesFiles.keys().reduce(<span class="function">(<span class="params">modules, modulePath</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// set &#x27;./app.js&#x27; =&gt; &#x27;app&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> moduleName = modulePath.replace(<span class="regexp">/^\.\/(.*)\.\w+$/</span>, <span class="string">&#x27;$1&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> value = modulesFiles(modulePath)</span><br><span class="line">  modules[moduleName] = value.default</span><br><span class="line">  <span class="keyword">return</span> modules</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules,</span><br><span class="line">  getters</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>/views/login/index.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;login-container&quot;&gt;</span><br><span class="line">    &lt;el-form ref=&quot;loginForm&quot; :model=&quot;loginForm&quot; :rules=&quot;loginRules&quot; class=&quot;login-form&quot; autocomplete=&quot;on&quot; label-position=&quot;left&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div class=&quot;title-container&quot;&gt;</span><br><span class="line">        &lt;h3 class=&quot;title&quot;&gt;Login Form&lt;/h3&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-form-item prop=&quot;username&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;svg-container&quot;&gt;</span><br><span class="line">          &lt;svg-icon icon-class=&quot;user&quot; /&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">        &lt;el-input</span><br><span class="line">          ref=&quot;username&quot;</span><br><span class="line">          v-model=&quot;loginForm.username&quot;</span><br><span class="line">          placeholder=&quot;Username&quot;</span><br><span class="line">          name=&quot;username&quot;</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          tabindex=&quot;1&quot;</span><br><span class="line">          autocomplete=&quot;on&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/el-form-item&gt;</span><br><span class="line"></span><br><span class="line">      &lt;el-tooltip v-model=&quot;capsTooltip&quot; content=&quot;Caps lock is On&quot; placement=&quot;right&quot; manual&gt;</span><br><span class="line">        &lt;el-form-item prop=&quot;password&quot;&gt;</span><br><span class="line">          &lt;span class=&quot;svg-container&quot;&gt;</span><br><span class="line">            &lt;svg-icon icon-class=&quot;password&quot; /&gt;</span><br><span class="line">          &lt;/span&gt;</span><br><span class="line">          &lt;el-input</span><br><span class="line">            :key=&quot;passwordType&quot;</span><br><span class="line">            ref=&quot;password&quot;</span><br><span class="line">            v-model=&quot;loginForm.password&quot;</span><br><span class="line">            :type=&quot;passwordType&quot;</span><br><span class="line">            placeholder=&quot;Password&quot;</span><br><span class="line">            name=&quot;password&quot;</span><br><span class="line">            tabindex=&quot;2&quot;</span><br><span class="line">            autocomplete=&quot;on&quot;</span><br><span class="line">            @keyup.native=&quot;checkCapslock&quot;</span><br><span class="line">            @blur=&quot;capsTooltip = false&quot;</span><br><span class="line">            @keyup.enter.native=&quot;handleLogin&quot;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;span class=&quot;show-pwd&quot; @click=&quot;showPwd&quot;&gt;</span><br><span class="line">            &lt;svg-icon :icon-class=&quot;passwordType === &#x27;password&#x27; ? &#x27;eye&#x27; : &#x27;eye-open&#x27;&quot; /&gt;</span><br><span class="line">          &lt;/span&gt;</span><br><span class="line">        &lt;/el-form-item&gt;</span><br><span class="line">      &lt;/el-tooltip&gt;</span><br><span class="line">        </span><br><span class="line">// 点击按钮，触发handleLogin方法</span><br><span class="line">      &lt;el-button :loading=&quot;loading&quot; type=&quot;primary&quot; style=&quot;width:100%;margin-bottom:30px;&quot; @click.native.prevent=&quot;handleLogin&quot;&gt;Login&lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div style=&quot;position:relative&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;tips&quot;&gt;</span><br><span class="line">          &lt;span&gt;Username : admin&lt;/span&gt;</span><br><span class="line">          &lt;span&gt;Password : any&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;tips&quot;&gt;</span><br><span class="line">          &lt;span style=&quot;margin-right:18px;&quot;&gt;Username : editor&lt;/span&gt;</span><br><span class="line">          &lt;span&gt;Password : any&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        &lt;el-button class=&quot;thirdparty-button&quot; type=&quot;primary&quot; @click=&quot;showDialog=true&quot;&gt;</span><br><span class="line">          Or connect with</span><br><span class="line">        &lt;/el-button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/el-form&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-dialog title=&quot;Or connect with&quot; :visible.sync=&quot;showDialog&quot;&gt;</span><br><span class="line">      Can not be simulated on local, so please combine you own business simulation! ! !</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;br&gt;</span><br><span class="line">      &lt;social-sign /&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; validUsername &#125; from &#x27;@/utils/validate&#x27;</span><br><span class="line">import SocialSign from &#x27;./components/SocialSignin&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Login&#x27;,</span><br><span class="line">  components: &#123; SocialSign &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    const validateUsername = (rule, value, callback) =&gt; &#123;</span><br><span class="line">      if (!validUsername(value)) &#123;</span><br><span class="line">        callback(new Error(&#x27;Please enter the correct user name&#x27;))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const validatePassword = (rule, value, callback) =&gt; &#123;</span><br><span class="line">      if (value.length &lt; 6) &#123;</span><br><span class="line">        callback(new Error(&#x27;The password can not be less than 6 digits&#x27;))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      loginForm: &#123;</span><br><span class="line">        username: &#x27;admin&#x27;,</span><br><span class="line">        password: &#x27;111111&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      loginRules: &#123;</span><br><span class="line">        username: [&#123; required: true, trigger: &#x27;blur&#x27;, validator: validateUsername &#125;],</span><br><span class="line">        password: [&#123; required: true, trigger: &#x27;blur&#x27;, validator: validatePassword &#125;]</span><br><span class="line">      &#125;,</span><br><span class="line">      passwordType: &#x27;password&#x27;,</span><br><span class="line">      capsTooltip: false,</span><br><span class="line">      loading: false,</span><br><span class="line">      showDialog: false,</span><br><span class="line">      redirect: undefined,</span><br><span class="line">      otherQuery: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    $route: &#123;</span><br><span class="line">      handler: function(route) &#123;</span><br><span class="line">        const query = route.query</span><br><span class="line">        if (query) &#123;</span><br><span class="line">          this.redirect = query.redirect</span><br><span class="line">          this.otherQuery = this.getOtherQuery(query)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    // window.addEventListener(&#x27;storage&#x27;, this.afterQRScan)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    if (this.loginForm.username === &#x27;&#x27;) &#123;</span><br><span class="line">      this.$refs.username.focus()</span><br><span class="line">    &#125; else if (this.loginForm.password === &#x27;&#x27;) &#123;</span><br><span class="line">      this.$refs.password.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    // window.removeEventListener(&#x27;storage&#x27;, this.afterQRScan)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    checkCapslock(e) &#123;</span><br><span class="line">      const &#123; key &#125; = e</span><br><span class="line">      this.capsTooltip = key &amp;&amp; key.length === 1 &amp;&amp; (key &gt;= &#x27;A&#x27; &amp;&amp; key &lt;= &#x27;Z&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    showPwd() &#123;</span><br><span class="line">      if (this.passwordType === &#x27;password&#x27;) &#123;</span><br><span class="line">        this.passwordType = &#x27;&#x27;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.passwordType = &#x27;password&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">      this.$nextTick(() =&gt; &#123;</span><br><span class="line">        this.$refs.password.focus()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleLogin() &#123;</span><br><span class="line">      this.$refs.loginForm.validate(valid =&gt; &#123;</span><br><span class="line">        if (valid) &#123;</span><br><span class="line">          this.loading = true</span><br><span class="line">          //如果验证成功，调用user.js里的actions中的login方法，并传入用户登录信息</span><br><span class="line">          this.$store.dispatch(&#x27;user/login&#x27;, this.loginForm)</span><br><span class="line">            .then(() =&gt; &#123;</span><br><span class="line">              this.$router.push(&#123; path: this.redirect || &#x27;/&#x27;, query: this.otherQuery &#125;)</span><br><span class="line">              this.loading = false</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(() =&gt; &#123;</span><br><span class="line">              this.loading = false</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          console.log(&#x27;error submit!!&#x27;)</span><br><span class="line">          return false</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getOtherQuery(query) &#123;</span><br><span class="line">      return Object.keys(query).reduce((acc, cur) =&gt; &#123;</span><br><span class="line">        if (cur !== &#x27;redirect&#x27;) &#123;</span><br><span class="line">          acc[cur] = query[cur]</span><br><span class="line">        &#125;</span><br><span class="line">        return acc</span><br><span class="line">      &#125;, &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    // afterQRScan() &#123;</span><br><span class="line">    //   if (e.key === &#x27;x-admin-oauth-code&#x27;) &#123;</span><br><span class="line">    //     const code = getQueryObject(e.newValue)</span><br><span class="line">    //     const codeMap = &#123;</span><br><span class="line">    //       wechat: &#x27;code&#x27;,</span><br><span class="line">    //       tencent: &#x27;code&#x27;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     const type = codeMap[this.auth_type]</span><br><span class="line">    //     const codeName = code[type]</span><br><span class="line">    //     if (codeName) &#123;</span><br><span class="line">    //       this.$store.dispatch(&#x27;LoginByThirdparty&#x27;, codeName).then(() =&gt; &#123;</span><br><span class="line">    //         this.$router.push(&#123; path: this.redirect || &#x27;/&#x27; &#125;)</span><br><span class="line">    //       &#125;)</span><br><span class="line">    //     &#125; else &#123;</span><br><span class="line">    //       alert(&#x27;第三方登录失败&#x27;)</span><br><span class="line">    //     &#125;</span><br><span class="line">    //   &#125;</span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>store的执行顺序：</strong><br>打开浏览器 → getters → 组件调用actions中的方法 → mutations（设置state的值） → getters（更新数据）</p><h2 id="refs"><a href="#refs" class="headerlink" title="$refs"></a>$refs</h2><ol><li>ref 加在普通的元素上，用this.$refs.（ref值） 获取到的是dom元素</li><li>ref加在子组件上，用this.$refs（ref值 ） 获 取 到 的 是 组 件 实 例 ， 可 以 使 用 组 件 的 所 有 方 法 。 在 使 用 方 法 的 时 候 直 接this.$refs.（ref值）获取到的是组件实例，可以使用组件的所有方法。在使用方法的时候直接this.refs.（ref值）获取到的是组件实例，可以使用组件的所有方法。在使用方法的时候直接this.refs.（ref值）.方法（） 就可以使用了</li><li>如何利用v-for 和 ref 获取一组数组或者dom 节点</li></ol><p>ref 需要在dom渲染完成后才会有，在使用的时候确保dom已经渲染完成。比如在生命周期 mounted(){} 钩子中调用，或者在 this.$nextTick(()=&gt;{}) 中调用。</p><h2 id="install"><a href="#install" class="headerlink" title="install"></a>install</h2><p>通常用于自定义插件和注册全局注册组件</p><p>自定义组件使用</p><p><strong>全局注册</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import ... from ...</span><br><span class="line">export default &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    Vue.component(&#x27;PageTools&#x27;, PageTools)</span><br><span class="line">    Vue.component(&#x27;update&#x27;, update)</span><br><span class="line">    Vue.component(&#x27;ImageUpload&#x27;, ImageUpload)</span><br><span class="line">    Vue.component(&#x27;ScreenFull&#x27;, ScreenFull)</span><br><span class="line">    Vue.component(&#x27;ThemePicker&#x27;, ThemePicker)</span><br><span class="line">    Vue.component(&#x27;TagsView&#x27;, TagsView)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部组件使用</p><p>src/main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vueEsign <span class="keyword">from</span> <span class="string">&#x27;vue-esign&#x27;</span></span><br><span class="line">Vue.component(<span class="string">&#x27;vueEsign&#x27;</span>, vueEsign)</span><br></pre></td></tr></table></figure><h2 id="data和props的区别"><a href="#data和props的区别" class="headerlink" title="data和props的区别"></a>data和props的区别</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>当前组件对象操作的数据，是每个组件的<strong>私有内存</strong>,是存储数据和希望跟踪的任何其他变量的地方。</p><p>如果我们正在构建一个计数器应用程序，我们将需要跟踪计数，因此我们将向我们的data添加一个count:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">    &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Counter&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // Initialized to zero to begin</span><br><span class="line">      count: 0,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    increment() &#123;</span><br><span class="line">      this.count += 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement() &#123;</span><br><span class="line">      this.count -= 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的data是私有的，仅供组件本身使用，其他组件不能访问它。</p><p>如果需要向组件传递数据，可以使用props向下传递数据(传递给子组件)，或者使用事件向上传递数据(传递给父组件)。</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>可供父组件操作的属性。<code>props</code> 可以是<strong>数组或对象，用于接收来自父组件的数据</strong>。<code>props</code> 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;my-component color-prop=&quot;hello world&quot;&gt;&lt;/my-component&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>然而，当我们从组件内部访问props时，我们并不拥有它们，所以我们不能更改它们</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>1、data不需要用户（开发者）传值，自身维护；而<strong>props需要用户（开发者）传值。</strong></p><p>2、data上的数据都是可读可写的；而<strong>props上的数据只可以读的，无法重新赋值。</strong></p><h2 id="Watch-amp-Computed"><a href="#Watch-amp-Computed" class="headerlink" title="Watch&amp;Computed"></a>Watch&amp;Computed</h2><ul><li>watch中监听<strong>props中的数据或data中的数据</strong></li><li>computed中计算<strong>props或者data中的数据</strong></li><li>data中使用props中的数据进行拷贝，如需响应数据变化则在watch中监听props的变化，在赋值给data</li><li>不要直接赋值给computed的属性，如果需要赋值，computed需要定义get与set函数</li></ul><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>computed的<strong>使用场景</strong>：适用于<strong>一些重复使用数据或复杂及费时的运算</strong>。我们可以把它放入computed中进行计算， 然后会在computed中<strong>缓存</strong>起来，下次就可以直接获取了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      姓：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 调用两次fullName --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>姓名：&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>姓名：&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">firstName</span>: <span class="string">&quot;张&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="attr">lastName</span>: <span class="string">&quot;三&quot;</span>,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="attr">computed</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">fullName</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="built_in">console</span>.log(<span class="string">&quot;这是fullName&quot;</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="built_in">this</span>.lastName;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>watch用来<strong>监听数据</strong>。它会<strong>对data的数据监听回调</strong>，当依赖的data的数据变化时，会执行回调。在回调中会传入newVal和oldVal两个参数。</p><p>watch的<strong>使用场景</strong>是：当在data中的某个数据发生变化时，我们需要做一些操作， 或者当需要在数据变化时<strong>执行异步</strong>或<strong>开销较大的操作</strong>时，我们就可以使用watch来进行监听。</p><h2 id="require-和-import"><a href="#require-和-import" class="headerlink" title="require 和 import"></a>require 和 import</h2><p>require: CommonJS语法。用于导入模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Clipboard = <span class="built_in">require</span>(<span class="string">&#x27;clipboard&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (!Clipboard) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;you shold npm install `clipboard` --save at first &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h2><p>用于一些<strong>常见的文本格式化</strong>。也许后端返回的数据格式并不是最终想要展示出来的，通过过滤器可以进行处理成自己想要展示出来的格式。由“管道”符号指示。</p><p>在调取接口的返回数据的时候，我们经常能够得到各种Number类型的数据。</p><p>这种格式的数据，很多时候都是表明对应的类型。</p><p>如果直接返回到页面上展示，对于操作人员来讲，没有任何意义。</p><p>所以，一般的情况下，我们需要把格式对应类型的中文名称显示出来。</p><h2 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h2><p>vue.directive的作用</p><p>vue.directive是我们<strong>除了内置的指令（如v-model和v-show）</strong>之外的<strong>自定义指令</strong>（v-自定义）。自定义指令是对普通DOM元素进行的底层操作，它是一种有效的的补充和扩展，不仅可以用于定义任何的dom操作，并且是可以复用的，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div id=&quot;app&quot;&gt;&lt;input v-focus /&gt;&lt;/div&gt;</span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;p style=&quot;width:200px;height:200px&quot; v-pin=&#x27;colors&#x27;&gt;trying&lt;/p&gt; </span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;div id=&quot;app&quot; v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Vue from &quot;vue&quot;; </span><br><span class="line"> </span><br><span class="line">// 1、输入框聚焦</span><br><span class="line">Vue.directive(&quot;focus&quot;, &#123;</span><br><span class="line">  // 当被绑定的元素插入到 DOM 中时……</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">// 2、绑定背景颜色</span><br><span class="line">Vue.directive(&#x27;pin&#x27;, function(el, binding) &#123; //背景颜色</span><br><span class="line">    el.style.background = binding.value</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">// 3、文字显示</span><br><span class="line">Vue.directive(&#x27;demo&#x27;, &#123;</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    var s = JSON.stringify</span><br><span class="line">    el.innerHTML =</span><br><span class="line">      &#x27;name: &#x27;       + s(binding.name) + &#x27;&lt;br&gt;&#x27; +</span><br><span class="line">      &#x27;value: &#x27;      + s(binding.value) + &#x27;&lt;br&gt;&#x27; +</span><br><span class="line">      &#x27;expression: &#x27; + s(binding.expression) + &#x27;&lt;br&gt;&#x27; +</span><br><span class="line">      &#x27;argument: &#x27;   + s(binding.arg) + &#x27;&lt;br&gt;&#x27; +</span><br><span class="line">      &#x27;modifiers: &#x27;  + s(binding.modifiers) + &#x27;&lt;br&gt;&#x27; +</span><br><span class="line">      &#x27;vnode keys: &#x27; + Object.keys(vnode).join(&#x27;, &#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;directive&quot;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            colors:&quot;&quot;,//定义变量接收</span><br><span class="line">            message:&#x27;left&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        this.colors=&quot;pink&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>钩子函数</strong></p><p>vue.directive有5种钩子函数，分别是：<strong>bind, inserted ,update, componentUpdated, unbind</strong></p><ul><li>bind：只调用一次，指令第一次绑定到元素时调用，在这里可以进行一次性的初始化设置</li><li>inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定被插入文档中）</li><li>update:所在组件的vnode更新时调用，但是可能发生在其子vnode更新之前，指令的值可能发生了变化，也可能没有</li><li>componentUpdate：指令所在组件的vnode及其子vnode全部更新后调用</li><li>unbind：只调用一次，指令与元素解绑时调用</li></ul><p><strong>参数</strong></p><p>el，binding（name,value,oldValue,expression,arg,modifiers）， vnode，oldvnode </p><h2 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h2><ol><li><p>模拟请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">ts</span>: &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span>: <span class="number">999</span>,</span><br><span class="line">    <span class="string">&quot;rows&quot;</span>: [&#123;</span><br><span class="line">      <span class="string">&quot;recNam&quot;</span>: <span class="string">&quot;LiQiang&quot;</span>,</span><br><span class="line">      <span class="string">&quot;recTim&quot;</span>: <span class="string">&quot;2018-07-10 22:12&quot;</span>,</span><br><span class="line">      <span class="string">&quot;updNam&quot;</span>: <span class="string">&quot;LiQiang&quot;</span>,</span><br><span class="line">      <span class="string">&quot;updTim&quot;</span>: <span class="string">&quot;2018-07-10 22:12&quot;</span>,</span><br><span class="line">      <span class="string">&quot;idevVersionUse&quot;</span>: <span class="number">1531231938000</span>,</span><br><span class="line">      <span class="string">&quot;_obj&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&quot;_map&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="string">&quot;fieldId&quot;</span>: <span class="string">&quot;87e8dcf411da4f409d19bf138f28fca4&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fieldName&quot;</span>: <span class="string">&quot;单证记账类型&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fieldCod&quot;</span>: <span class="string">&quot;LEDGER_CODE&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sorter&quot;</span>: <span class="string">&quot;102&quot;</span>,</span><br><span class="line">      <span class="string">&quot;teamOrgnId&quot;</span>: <span class="string">&quot;9eb40a53de0e44429c15687bfada4a04&quot;</span>,</span><br><span class="line">      <span class="string">&quot;teamOrgnIdStr&quot;</span>: <span class="string">&quot;二公司&quot;</span>,</span><br><span class="line">      <span class="string">&quot;orgnId&quot;</span>: <span class="string">&quot;5f2f498bd5924734b9432ba71e35b8c7&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;,  &#123;</span><br><span class="line">      <span class="string">&quot;recNam&quot;</span>: <span class="string">&quot;shisg&quot;</span>,</span><br><span class="line">      <span class="string">&quot;recTim&quot;</span>: <span class="string">&quot;2018-04-23 13:04&quot;</span>,</span><br><span class="line">      <span class="string">&quot;updNam&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">      <span class="string">&quot;updTim&quot;</span>: <span class="string">&quot;2018-06-22 10:52&quot;</span>,</span><br><span class="line">      <span class="string">&quot;idevVersionUse&quot;</span>: <span class="number">1529635967125</span>,</span><br><span class="line">      <span class="string">&quot;_obj&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&quot;_map&quot;</span>: &#123;&#125;,</span><br><span class="line">      <span class="string">&quot;fieldId&quot;</span>: <span class="string">&quot;6A7BB06E97391CEBE0530101007F3CE8&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fieldName&quot;</span>: <span class="string">&quot;货物记账项&quot;</span>,</span><br><span class="line">      <span class="string">&quot;fieldCod&quot;</span>: <span class="string">&quot;CARGO_ITEM&quot;</span>,</span><br><span class="line">      <span class="string">&quot;sorter&quot;</span>: <span class="string">&quot;9&quot;</span>,</span><br><span class="line">      <span class="string">&quot;teamOrgnId&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="string">&quot;teamOrgnIdStr&quot;</span>: <span class="string">&quot;招商局集团&quot;</span>,</span><br><span class="line">      <span class="string">&quot;orgnId&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">      <span class="string">&quot;description&quot;</span>: <span class="literal">null</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">&quot;footer&quot;</span>: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>mock</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">&#x27;mockjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> loginAPI <span class="keyword">from</span> <span class="string">&#x27;./login&#x27;</span></span><br><span class="line"><span class="comment">// Mock.setup(&#123;</span></span><br><span class="line"><span class="comment">//   timeout: &#x27;350-600&#x27;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录相关</span></span><br><span class="line">Mock.mock(<span class="string">&#x27;/webresources/login/privilege/SysField/find&#x27;</span>, <span class="string">&#x27;post&#x27;</span>, loginAPI.ts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Mock</span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="中期"><a href="#中期" class="headerlink" title="中期"></a>中期</h1><h2 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a>按钮权限</h2><p>自定义指令 实现动态全局按钮权限控制</p><ol><li><p>自定义指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//directive/permission/permission.js</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params">el, binding, vnode</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = binding</span><br><span class="line">    <span class="keyword">const</span> permissionList = store.getters &amp;&amp; store.getters.permissionList</span><br><span class="line">    <span class="keyword">if</span> (!value) <span class="keyword">return</span> el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">    <span class="keyword">const</span> modelId = vnode.context._routerRoot._route.meta.modelId || <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (!modelId) <span class="keyword">return</span> el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">    <span class="keyword">const</span> list = permissionList.filter(<span class="function"><span class="params">o</span> =&gt;</span> o.modelId === modelId)</span><br><span class="line">    <span class="keyword">if</span> (!list.length) <span class="keyword">return</span> el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">    <span class="keyword">const</span> btnList = list[<span class="number">0</span>] &amp;&amp; list[<span class="number">0</span>].button ? list[<span class="number">0</span>].button : []</span><br><span class="line">    <span class="keyword">if</span> (!btnList.length) &#123;</span><br><span class="line">      el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> hasPermission = btnList.some(<span class="function"><span class="params">btn</span> =&gt;</span> btn.enCode === value)</span><br><span class="line">      <span class="keyword">if</span> (!hasPermission) &#123;</span><br><span class="line">        el.parentNode &amp;&amp; el.parentNode.removeChild(el)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//directive/permission/index.js</span></span><br><span class="line"><span class="keyword">import</span> permission <span class="keyword">from</span> <span class="string">&#x27;./permission&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.directive(<span class="string">&#x27;has&#x27;</span>, permission)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  <span class="built_in">window</span>[<span class="string">&#x27;has&#x27;</span>] = permission</span><br><span class="line">  Vue.use(install); <span class="comment">// eslint-disable-line</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">permission.install = install</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> permission</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> permission <span class="keyword">from</span> <span class="string">&quot;@/directive/permission&quot;</span>;</span><br><span class="line">Vue.use(permission)</span><br></pre></td></tr></table></figure></li><li><p>前端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button v-has=&quot;btn_process&quot; type=&quot;text&quot; :style=&#x27;&#123;&quot;width&quot;:&quot;40%&quot;&#125;&#x27;</span><br><span class="line">                                                   @click=&quot;isprocess(scope.row.ship_id)&quot; :disabled=&quot;(scope.row.isProcess)==1?true:false&quot;&gt;审核</span><br></pre></td></tr></table></figure></li></ol><h2 id="常见开发问题："><a href="#常见开发问题：" class="headerlink" title="常见开发问题："></a>常见开发问题：</h2><ol><li><p>vue中不能在标签中使用插值表达式了</p><p>Interpolation inside attributes has been removed. Use v-bind or the colon shorthand instead.</p><p>解决：改用前面加上冒号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-tag :type=&quot;scope.row.isProcess | dynamicText(processOptions) == &#x27;已审核&#x27; ? &#x27;success&#x27; : &#x27;danger&#x27;&quot; disable-transitions&gt;</span><br><span class="line">                                            &#123;&#123; scope.row.isProcess | dynamicText(processOptions) &#125;&#125;</span><br><span class="line">&lt;/el-tag&gt;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>管道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#125;&#125;为取值符号， | 为过滤器</span><br></pre></td></tr></table></figure><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。过滤器可以用在两个地方：<strong>双花括号插值和 <code>v-bind</code> 表达式</strong> (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 `v-bind` 中 --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Vue" scheme="http://ppnostalgia.github.io./categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://ppnostalgia.github.io./tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>关于共同警备区的神神叨叨</title>
    <link href="http://ppnostalgia.github.io./50685d27.html"/>
    <id>http://ppnostalgia.github.io./50685d27.html</id>
    <published>2022-09-16T14:40:34.000Z</published>
    <updated>2022-10-27T08:24:33.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220916224935786.png" alt="image-20220916224935786"></p><p>​        近期刚找到工作还未入职，闲来无事，趁机重拾起看电影的兴致。思来想去，决定先从朴赞郁导演的电影开始看起。第一次知道朴赞郁是在中队长同志解说的老男孩<a href="https://www.bilibili.com/video/BV1ez4y1975U?spm_id_from=333.999.0.0&amp;vd_source=15347fa03ede8c26e51dbb4c8d3f35af">视频</a>中了解到的，该系列解说可以说是让我这个只会看剧情的肤浅人类第一次全面见识到了镜头语言的魅力，也让我认识了朴赞郁这个喜欢肮脏故事的老头子。</p><p>​        最近刚看完共同警备区，这部电影相比老爷子导演的其他电影，可能镜头语言是相对较少的（依然够我摸索一阵…），但可能是最能贴近和预言我们将来所要面临的情境…….提前趁记忆清晰记录一下，看十年后的自己是否依然能保持清醒，不被战争和极端民族主义所裹挟。</p><h1 id="共同警备区"><a href="#共同警备区" class="headerlink" title="共同警备区"></a>共同警备区</h1><h2 id="地点"><a href="#地点" class="headerlink" title="地点"></a>地点</h2><p>​    首先来看一下本片故事发生的背景地点—共同警备区也就是板门店。百度百科如下：</p><p>​    板门店（판문점）位于<a href="https://baike.baidu.com/item/朝鲜半岛/2149811?fromModule=lemma_inlink">朝鲜半岛</a>中西部、北纬38°线以南5公里处，以前这里是一个名不见经传的小地方。1953年7月27日，<a href="https://baike.baidu.com/item/朝鲜停战协定/8413356?fromModule=lemma_inlink">朝鲜停战协定</a>在这里签字，板门店扬名于世。 [1] </p><p>​    <a href="https://baike.baidu.com/item/抗日战争/128498?fromModule=lemma_inlink">抗日战争</a>胜利后，南北朝鲜的<a href="https://baike.baidu.com/item/分界线/79262?fromModule=lemma_inlink">分界线</a>在北纬38度的<a href="https://baike.baidu.com/item/三八线/1158147?fromModule=lemma_inlink">三八线</a>。朝鲜战争之后，<a href="https://baike.baidu.com/item/中国人民志愿军/3455348?fromModule=lemma_inlink">中国人民志愿军</a>和<a href="https://baike.baidu.com/item/朝鲜人民军/7147491?fromModule=lemma_inlink">朝鲜人民军</a>才把分界线向南推进到了今天的板门店位置。板门店是<a href="https://baike.baidu.com/item/朝鲜战争/5310?fromModule=lemma_inlink">朝鲜战争</a>和朝鲜半岛分裂的见证，也是当今朝韩双方最为敏感的前线阵地。</p><p>2012年7月22日，<strong>板门店被曝光地雷埋设密度居世界第一</strong>（故事的起因之一）。</p><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>​    20世纪70年代美国在政治、经济上面临了深刻的危机。美国为了找一条出路摆脱这个危机，在朝鲜半岛比任何时候都加紧进行了侵略战争活动。1974年和1975年，美国在空中、地面和海上分别制造了23800多起和28150多起军事挑衅事件。美国仅在1976年1月至7月间，在板门店共同警卫区对朝鲜进行了400多起敌对行为。</p><p>​    1976年8月18日发生在板门店的“砍树事件”，被朝鲜方面称之为“<a href="https://baike.baidu.com/item/板门店事件/8650182?fromModule=lemma_inlink">板门店事件</a>”，韩国称为“板门店虐杀事件”。朝鲜方面认为这是美帝国主义在板门店共同警卫区有计划地制造了板门店事件。</p><p>​    故事发生的时间在70年代左右，该年代最为人知的就是上面所说的板门店事件。影片开头瑞士军官所说的一句话：”干燥的森林，只要有星星之火，整个森林便可能付之一炬。“似乎也隐喻了板门店事件。</p><p>​    本片的叙述方式采用了倒叙的手法，开头发生的故事已经是剧情中期了。近期看过的采用这类手法就是JoJo福音了，其次是最广为人知的碎片管理大师诺兰了。</p><p>​    不得不说，倒叙手法真的很适合悬疑类故事，很容易调动观众的思维，到后期颇有种一起破案的感觉。</p><h2 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h2><h3 id="中期"><a href="#中期" class="headerlink" title="中期"></a>中期</h3><p>​    我一开始以为苏菲是以一种旁观者的身份登场的，后来发现其实导演对于旁观者的身份另有安排，苏菲从一开始的想以中立国的身份调查事件，到后面事件逐渐水落石出，开始以同一民族的身份来审视事件，完成角色身份的转变。影片中的苏菲不同阶段对于相框的处理，可能就是导演给我们的暗示。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917101024259.png" alt="image-20220917101024259"></p><p>​    <img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917101128609.png" alt="image-20220917101128609"></p><p>​    苏菲的父亲是一个流亡瑞典的北韩战俘，苏菲一开始故意将父亲的部分隐藏去，以中立国的身份参与调查，到后面重新审视起民族。导演对于像瑞士瑞典这样的中立国也进行了一波讽刺，所谓的中立国并不在乎真相，他们对于维持和平的手段就是剧中所说的掩饰真相。导演为什么特意选苏菲这样一名女性来作为中立代表呢？个人觉得对比成分更多一些，开头说苏菲是从1953年以来首位来到板门店的女性，在这样一个剑拔弩张的环境下，导演让我们通过苏菲的视角以一种温柔的方式逐渐撕开残忍的真相。</p><p>​    最早苏菲拜访冲突中幸存的两人时，两人对于真相都是闭口不言，只能通过两人所签署的陈述书了解经过。其中，两位幸存者在面对苏菲的询问时充分的体现了两人的人物特征。北韩方面的吴军士在应对问询时更为冷静，体现了一股老兵油子气质，而李秀赫害怕出错选择装睡。</p><p>​    苏菲在调查时发现，事件中的种种迹象都透露出真相没有那么简单。反常迹象主要有以下几点：</p><ol><li>从其他军士口中李秀赫前后形象的不一致</li><li>北韩士兵尸体弹孔（11发）和弹匣数量（10发）不一致，李秀赫用枪习惯不一致</li><li>李秀赫的女朋友</li></ol><p>​    当逐渐接近事情真相，苏菲根据血液检测推断出李秀赫的枪并非其本人，而是南成植，他也在案发现场时。在上一层的南成植害怕测谎仪导致真相暴露，选择了跳楼自杀。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917154355945.png" alt="image-20220917154355945"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917154432261.png" alt="image-20220917154432261"></p><p>这个跳楼瞬间的特写，导演采用了反转的方式，表现出了南成植内心之中的内疚与挣扎。这一跳终究是被自己内心的压力所压垮。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917154503485.png" alt="image-20220917154503485"></p><p>​    此时情节开始回溯，时间拨到较早时候，事实的真相逐渐展开。</p><h3 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h3><p>这里导演插入了一个并不是故事最开始的阶段，一群美国旅行团在导游的带领下参观板门店，一个人的帽子被吹到了三八线北方的朝鲜方。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917155733178.png" alt="image-20220917155733178"></p><p>这里有几处反差的现象：</p><ol><li>背景广播里倡导民主的南韩一直在说军人禁止与北韩做任何交流，否则可能会因此判死刑</li><li>宋康昊所饰演的吴敬必捡到帽子后面带友好表情的还给了美国人</li></ol><p>前文中所提到的旁观者角色个人认为更像是这里的美国人，前文在时间部分提到：20世纪70年代美国在政治、经济上面临了深刻的危机。美国为了找一条出路摆脱这个危机，在朝鲜半岛比任何时候都加紧进行了侵略战争活动。1974年和1975年，美国在空中、地面和海上分别制造了23800多起和28150多起军事挑衅事件。美国仅在1976年1月至7月间，在板门店共同警卫区对朝鲜进行了400多起敌对行为。</p><p>导演这里用了一个俯视镜头，似乎也在暗示这种关系。美国人拿着相机不停朝北韩方拍摄，南韩将其拦截了回去。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917160623465.png" alt="image-20220917160623465"></p><p>而捡帽子这一幕，在影片的结尾部分又出现了一次，更像是一种回忆，事件的主人公都在拍摄的这幅照片里。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220916224935786.png" alt="image-20220916224935786"></p><p>时间拨到更早时候，南韩军人在一次演练中迷路了，误闯入北韩地区，李秀赫在小便过程中与大部队走散，又踩在了地雷上。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917161344793.png" alt="image-20220917161344793"></p><p>这一幕镜头有一瞬间让我联想到1917里士兵在布满花瓣的河里漂流的场景。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917161615037.png" alt="image-20220917161615037"></p><p>一开始感觉李秀赫突然踩到地雷有些突兀，后来得知板门店地区的被曝光地雷埋设密度居世界第一时倒也合理了…</p><p>后面李秀赫在纠结的过程中，遇到了北韩的吴敬必和郑友珍，从一开始的让对方滚开到后面凶狠中又带着求饶的说出救救我，颇有些搞笑与可爱。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917161935327.png" alt="image-20220917161935327"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917163334816.png" alt="image-20220917163334816"></p><p>后面吴敬必帮李秀赫解除了地雷，云淡风轻地抽了支烟，朝着李吹了个口哨，走了。这个口哨影片中一共吹了三次，个人愚钝，没能弄懂，自行体会。</p><p>进一步地，在后面两方军队相遇，吴军士出来与南韩军官互抽了支烟，并将兔子归还给南韩。瞥见李也在对面，又吹了一次，李听到在憋笑。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917162548701.png" alt="image-20220917162548701"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917163248778.png" alt="image-20220917163248778"></p><p>从这可以看出，两方似乎并没有想象的那么紧张。</p><p>后面两人熟络起来，在不归桥的两端互相扔信进行通信。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917163654649.png" alt="image-20220917163654649"></p><p>直到后面郑友珍搞怪编造了一封信，李秀赫这个愣头青竟然真的去了对面。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917163955311.png" alt="image-20220917163955311"></p><p>郑友珍真的要李留下了…</p><p>此后三个人开始了在地窖互相吹牛逼的生活。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917164403442.png" alt="image-20220917164403442"></p><p>其中，吴说了一句：”在实战中，拔枪速度并不重要，重要的是谁更冷静。“ 为后面埋下了伏笔</p><p>接着，南告诉李要是李退役了，会很孤独，然后李就把他介绍给了对面。吴南第一次见面时，吴问了一句暖和吗，南紧张的没有回应，并在后面问李这样会不会违法。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917164543849.png" alt="image-20220917164543849"></p><p>到后面白天吴通过镜子反光，将光线折射到南眼睛上，南彻底了放下了防备，感受到了同族的温暖，对面的人并没有他想象的那么寒冷。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917164953185.png" alt="image-20220917164953185"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917165106910.png" alt="image-20220917165106910"></p><p>于是变成了四人的快乐地窖生活开始了。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917165328646.png" alt="image-20220917165328646"></p><p>四人用子弹玩抓石子游戏</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917165525657.png" alt="image-20220917165525657"></p><p>互相介绍自己的女友</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917165604380.png" alt="image-20220917165604380"></p><p>站岗时互相朝对方吐痰</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917165656464.png" alt="image-20220917165656464"></p><p>其中有一段，李想拉吴加入南韩，吴将给的口中的巧克力派吐了出来，眼神瞬间发生变化并警告了李。吴这个人是个很复杂的人，他既保有对国家的高度忠诚，又不完全为其洗脑思想所影响，可能也是他唯一善终的原因之一吧。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917165910940.png" alt="image-20220917165910940"></p><p>几人之间的友谊一直在尽量避免其他因素的影响，从南拍照时对于后面墙上北韩领导人的表情，并让几人尽量凑一起挡住画像就可以看出。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917170410843.png" alt="image-20220917170410843"></p><p>然而在当时那个年代的紧张情势下，几人真的能一直维持现状吗？</p><p>直到郑秀珍生日这天，一切都发生了改变……</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917174716057.png" alt="image-20220917174716057"></p><p>南给了郑了个生日礼物，郑搞怪放了个屁作为回礼，南开门透气时，吴的长官崔站在了门口……</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917174903038.png" alt="image-20220917174903038"></p><h3 id="后期"><a href="#后期" class="headerlink" title="后期"></a>后期</h3><p>时间又回到南跳楼自杀的那一刻，导演以南在死前的眼神切回到现在，前面的一切似乎都是南临终时刻的走马灯，他在最后完成了内心的解放。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917175320367.png" alt="image-20220917175320367"></p><p>在后面的审问上，李吴两人相遇</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917175542813.png" alt="image-20220917175542813"></p><p>此时的吴还未知道南已跳楼自杀，依然坚称是李一人射杀了另外两人，此时苏菲将南跳楼的视频放给吴，开始问是否认识他，吴低了一下头回答：南韩的傀儡罢了，后面南跳楼可以看到吴的表情：</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917175916954.png" alt="image-20220917175916954"></p><p>十分克制的说了一句：这是干什么。（宋康昊的演技确实无敌）</p><p>李在苏菲步步说出真相，两方长官对于苏菲的大声质疑下，逐渐趋于崩溃，想要说出实情</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917180347333.png" alt="image-20220917180347333"></p><p>吴作为一个哥哥，逐渐意识到问题，刻意制造了混乱，将其打倒在地，避免三人之前的努力白费，导致真相暴露</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917180432288.png" alt="image-20220917180432288"></p><p>后面苏菲被停职（因为父亲是流亡到瑞士的前北韩军官），瑞士军官的一句话也暗示了吴这么做的原因：在这里维持和平的最好方法就是掩饰真相。</p><p>李来找到苏菲，一是道歉，二是知道了苏菲父亲的身份，对她说了句：很亲切。</p><p>最后，苏菲和李达成了交易，李说出真相，苏菲保全吴的安全。</p><h3 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h3><p>时间回到郑友珍生日那天，吴的长官崔看到南韩人立马拔出枪，李也在第一时间拔出枪。双方属于一触即发的状态。</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917182418421.png" alt="image-20220917182418421"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917182438259.png" alt="image-20220917182438259"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917182521816.png" alt="image-20220917182521816"></p><p>吴作为场中唯一一个上过战场的人，保持了充分的冷静，劝说双方都渐渐地放下了枪，然而正如开头瑞士军官所说的那样：在战场中任何一点火花都可能燃烧整个森林。此时录音机中放的歌曲突然达到高潮</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917182822126.png" alt="image-20220917182822126"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917182933926.png" alt="image-20220917182933926"></p><p>屋内响起电吉他的声音，一切人性在这电光火石间丧失。崔欲掏手枪被南率先出枪击中，郑颤抖着想要开枪，被南和李开了两枪倒地，李随即转头向吴开枪，连续按了两次，然而手枪卡壳了，李此时的表情可以认为是从本能的开枪逐渐清醒，并不可思议</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917184748863.png" alt="image-20220917184748863"></p><p>郑被击中后逼着开了一枪打中了李的腿，南从一开始的闭眼怯懦呻吟，看到李倒地，他又变成了一个士兵，一个杀人机器，眼神变成了麻木与充满杀意</p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917185255615.png" alt="image-20220917185255615"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917185153577.png" alt="image-20220917185153577"></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220917185326786.png" alt="image-20220917185326786"></p><p> 郑身体上的8枪都是他一枪一枪补的，后面枪口依次转向吴和李，最后冲李微微一笑陷入麻木，这一笑不知道是麻木的笑还是杀人后的畅快的笑。</p><p>吴此时从手上拿过了他的枪，作为目前场内唯一还能战斗的人，吴如果按照立场本有机会立即杀掉这两人，但是就像他之前的所说的那样，战争中最重要的是冷静，而不是拔枪速度。冷静和拔枪其实也寓意着和平与战争，赢的不是先开枪的那方，而是先能克制的那方。如果你被人举枪连开了两枪，第一行动也会是反击。而吴作为经历过战争的人明白，战场中最重要的是克制，双方你来我往的还击永远都不会有结果。作为老大哥，他伪造了故事开头陈述书所描写的那样，最后在双方士兵的火舌中目送着李被救走。</p><p>最后苏菲在医院拜访吴时，知道了郑其实是被李开出的第一个致命一枪，李从一开始就尽量选择性遗忘，避免自己被那罪恶感所吞噬，如今苏菲重新唤醒了他那尘封的记忆，最终也抵不过内疚含枪自杀。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>导演在影片里留了很多令人玩味的地方如</p><ol><li>故事中，北韩的吴是一个稳重的老大哥形象，南韩的李和南都是未经过磨砺的新兵蛋子形象</li><li>郑为了不让自己的狗被吃掉，让其在不归桥上向南韩跑去，并说南韩才有很多吃的</li><li>郑一开始让李留在哨所的话和后来李邀请南说的话</li><li>吴在李邀请进入南韩后两次吃吐巧克力派的行为</li></ol><p>不知道我们将来在面对对岸的同胞时是否依然能保持冷静，三八线是否依然存在。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="电影" scheme="http://ppnostalgia.github.io./categories/%E7%94%B5%E5%BD%B1/"/>
    
    
    <category term="电影" scheme="http://ppnostalgia.github.io./tags/%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>读书笔记-置身事内</title>
    <link href="http://ppnostalgia.github.io./f828e852.html"/>
    <id>http://ppnostalgia.github.io./f828e852.html</id>
    <published>2022-08-31T14:02:34.000Z</published>
    <updated>2022-09-19T10:31:16.438Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>不能脱离政府来谈经济，是理解中国经济的基本出发点。</p><h2 id="事权划分"><a href="#事权划分" class="headerlink" title="事权划分"></a>事权划分</h2><p>事权划分的三大原则：<strong>公共服务的规模经济、信息复杂性、激励相容。</strong></p><ul><li>所谓权力，实质就是在说不清楚的情况下由谁来拍板决策的问题。如果这种说不清的情况很多，权力就一定会向个人集中，这也是各地区、各部门“一把手负责制”的根源之一，这种权力的自然集中可能会造成专权和腐败。</li><li>我国事权划分的一大特点是<strong>属地管理</strong>。属地管理兼顾了公共服务边界问题和信息优势问题，同时也给了地方政府很大的权力，有利于调动其积极性。1956年，毛泽东在著名的《论十大关系》中论述“中央和地方的关系”时就提到了这一点：“我们的国家这样大，人口这样多，情况这样复杂，有中央和地方两个积极性，比只有一个积极性好得多。我们不能像苏联那样，把什么都集中到中央，把地方卡得死死的，一点机动权也没有。”</li></ul><h2 id="事权改革方向"><a href="#事权改革方向" class="headerlink" title="事权改革方向"></a>事权改革方向</h2><ul><li>2013年，党的十八届三中全会通过了《中共中央关于全面深化改革若干重大问题的决定》，其中对事权改革方向的阐述就非常符合这些原则：“<strong>适度加强中央事权和支出责任</strong>，国防、外交、国家安全、关系全国统一市场规则和管理等作为中央事权；<strong>部分社会保障、跨区域重大项目建设维护等作为中央和地方共同事权</strong>，逐步理顺事权关系；<strong>区域性公共服务作为地方事权</strong>。”</li><li>2016年，《国务院关于推进中央与地方财政事权和支出责任划分改革的指导意见》发布，将十八届三中全会的决定进一步细化，从中可以更清楚地看到本章讨论的三大原则：“要逐步将国防、外交、国家安全、出入境管理、国防公路、<strong>国界河湖治理</strong>、<strong>全国性重大传染病防治</strong>、<strong>全国性大通道</strong>、全国性战略性自然资源使用和保护等基本公共服务确定或上划为<strong>中央的财政事权</strong>……要逐步将社会治安、市政交通、农村公路、城乡社区事务等<strong>受益范围地域性强、信息较为复杂且主要与当地居民密切相关的基本公共服务确定为地方的财政事权</strong>……要逐步将义务教育、高等教育、科技研发、公共文化、基本养老保险、基本医疗和公共卫生、城乡居民基本医疗保险、就业、粮食安全、跨省（区、市）重大基础设施项目建设和环境保护与治理等体现中央战略意图、跨省（区、市）且具有地域管理信息优势的基本公共服务确定为中央与地方共同财政事权，并明确各承担主体的职责。”</li></ul><h2 id="招商引资"><a href="#招商引资" class="headerlink" title="招商引资"></a>招商引资</h2><ul><li>地方政府是城市土地的所有者，为了招商引资发展经济，会把工业用地以非常优惠的价格转让给企业使用，并负责对土地进行一系列初期开发，比如“七通一平”（通电、通路、通暖、通气、给水、排水、通信，以及平整场地）。</li><li>对企业至关重要的生产要素，地方政府几乎都有很强的干预能力。其中土地直接归政府所有，资金则大多来自国有银行主导的金融体系和政府控制的其他渠道，比如国有投融资平台。对于劳动力，政府控制着户口，也掌握着教育和医疗等基本服务的供给，还掌握着土地供应，直接影响住房分配。而生产中的科技投入，也有相当大一部分来自公立大学和科研院所。除此之外，地方政府还有财税政策、产业政策、进出口政策等工具，都可能对企业产生重大影响。<strong>政府及其各类附属机构（国企、事业单位、大银行等）深度参与大多数生产和分配环节的模式。政府及其各类附属机构（国企、事业单位、大银行等）深度参与大多数生产和分配环节的模式。</strong></li></ul><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p><strong>财税与政府行为</strong></p><p>政府办事必然要花钱，由事权引出财权。</p><h2 id="分税制改革"><a href="#分税制改革" class="headerlink" title="分税制改革"></a>分税制改革</h2><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220902214943241.png" alt="image-20220902214943241"></p><p>1985—1993年，地方政府的收入和支出是比较匹配的（图2-1），这种“事权和财权匹配”的体制对经济发展影响很大，也造成很多不良后果，催生了1994年的分税制改革。</p><h3 id="改革斗争过程"><a href="#改革斗争过程" class="headerlink" title="改革斗争过程"></a>改革斗争过程</h3><ol><li><p>很多学生不太理解为何谈判如此艰难：只要中央做了决策，地方不就只有照办的份儿吗？“00后”一代有这种观念，不难理解。一方面，经过分税制改革后多年的发展，<strong>今天的中央政府确实要比20世纪80年代末和90年代初更加强势</strong>；另一方面，公众所接触的信息和看到的现象，大都已经是博弈后的结果，而缺少社会阅历的学生<strong>容易把博弈结果错当成博弈过程</strong>。其实即使在今天，中央重大政策出台的背后，也要经过很多轮的征求意见、协商、修改，否则很难落地。成功的政策背后是成功的协商和妥协，而不是机械的命令与执行，所以理解利益冲突，理解协调和解决机制，是理解政策的基础。</p></li><li><p><strong>增值税</strong>改革：分税制改革中最重要的税种是<strong>增值税，占全国税收收入的1/4</strong>。改革之前，增值税（即产品税）是最大的<strong>地方税</strong>，改革后变成<strong>共享税</strong>，中央拿走75%，留给地方25%。假如改革前的1993年，地方增值税收入为100亿元，1994年改革后增长为110亿元，那么按照新税制，地方拿25%，收入一下就从1993年的100亿元下降到了27.5亿元。为防止地方收入急剧下跌，中央设立了<strong>“税收返还”机制</strong>：保证改革后地方增值税收入与改革前一样，<strong>新增部分才和中央分</strong>。1994年，地方可以拿到102.5亿元，而不是27.5亿元（基数：110亿+10亿*25%）。因此改革后增值税占地方税收收入的比重没有急速下跌，而是缓慢地逐年下跌</p><p>1993年，中央经过与广东省地方的妥协，将1993年作为分税制改革的基数年，减免税过度。地方为了应对税制改革，利用税收返还的漏洞，提高基数，在1993年底突击征税，使1993年后四个月财政收入大大提高。</p></li></ol><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220915082251018.png" alt="image-20220915082251018"></p><ol><li><p><strong>企业所得税</strong>（23%）</p><p>改革之前：中央企业交中央，地方企业交地方。地方企业比中央企业多，所以六成以上的所得税交给了地方。容易导致地方为了企业所得税形成地方保护主义。</p><p>改革之后：除一些特殊央企的所得税归中央外，所有企业的所得税中央和地方六四分成（仅2002年当年为五五分）。为防止地方收入下降，同样也设置了税收返还机制，并把2001年的所得税收入定为返还基数。</p></li></ol><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>分税制是20世纪90年代推行的根本性改革之一，也是最为成功的改革之一。改革扭转了“两个比重”不断下滑的趋势（图2-2）：<strong>中央占全国预算收入的比重从改革前的22%一跃变成55%</strong>，并长期稳定在这一水平；国家预算收入占GDP的比重也从改革前的11%逐渐增加到了20%以上。<strong>改革大大增强了中央政府的宏观调控能力</strong>，为之后应付一系列重大冲击（1997年亚洲金融危机、2008年全球金融危机和汶川地震等）奠定了基础，也保障了一系列重大改革（如国企改革和国防现代化建设）和国家重点建设项目的顺利实施。<strong>分税制也从根本上改变了地方政府发展经济的模式（土地财政的原因之一）。</strong></p><h2 id="土地财政"><a href="#土地财政" class="headerlink" title="土地财政"></a>土地财政</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>分税制改革导致中央收入增加，但地方收入减少，但是事做的还是和原来的一样多，支出的大头仍在地方。尽管税收返还等政策可以缓解，但是发展经济所需的诸多额外支出，比如招商引资和土地开发等，就需要另筹资金了。</p><h3 id="招商引资与税收"><a href="#招商引资与税收" class="headerlink" title="招商引资与税收"></a>招商引资与税收</h3><p>给定税率的情况下，想要增加税收收入，要么靠<strong>扩大税源</strong>，要么靠加强征管。</p><p>改革前，企业的大多数税收按隶属关系上缴。</p><p>改革后则变成了在所在地上缴，这自然会刺激地方政府招商引资。<strong>地方政府尤其青睐重资产的制造业</strong>，一是因为<strong>投资规模大，对GDP的拉动作用明显</strong>；二是因为<strong>增值税在生产环节征收</strong>，跟生产规模直接挂钩；三是因为制造业不仅可以吸纳从农业部门转移出的低技能劳动力，也可以带动第三产业发展，增加相关税收。</p><p>因为绝大多数税收征收自企业，且<strong>多在生产环节征收</strong>，所以地方政府<strong>重视企业而相对轻视民生</strong>，重视生产而相对轻视消费。以增值税为例，虽然企业可以层层抵扣，最终支付税金的一般是消费者（增值税发票上会分开记录货款和税额，消费者支付的是二者之和），<strong>但因为增值税在生产环节征收，所以地方政府更加关心企业所在地而不是消费者所在地。这种倚重生产的税制，刺激了各地竞相投资制造业、上马大项目</strong>，推动了制造业迅猛发展，加之充足高效的劳动力资源和全球产业链重整等内外因素，我国在短短二三十年内就成为世界第一制造业大国。当然，这也付出了相应的代价。比如说，地方为争夺税收和大工业项目，不惜放松环保监督，损害了生态环境，推高了过剩产能。2007—2014年，地方政府的工业税收收入中，一半来自过剩产能行业。而在那些财政压力较大的地区，工业污染水平也普遍较高。</p><p><strong>不仅九成的税收征收自企业，税收之外的其他政府收入基本也都征收自企业</strong>，比如土地转让费和国有资本经营收入等。社保费中个人缴纳的比例也低于企业缴纳的比例。所以在分税制改革后的头些年，地方政府在财政支出上向招商引资倾斜（如基础设施建设、企业补贴等），而民生支出（教育、医疗、环保等）相对不足。(16)2002年，中央提出“科学发展观”，要求“统筹经济社会发展、统筹人与自然和谐发展”，要求更加重视民生支出。由于第一章中讨论过的规模经济、信息复杂性等原因，民生支出基本都由地方政府承担，所以地方支出占比从2002年开始快速增长，从70%一直增长到了85%（图2-1）。</p><p>分税制改革后，<strong>地方政府手中能用来发展经济的资源受到了几方面的挤压</strong>。首先，预算内财政支出从重点支持生产建设转向了重点支持公共服务和民生。20世纪90年代中后期，财政支出中“经济建设费”占40%，“社会文教费”（科教文卫及社会保障）只占26%。到了2018年，“社会文教费”支出占到了40%，“经济建设费”则下降了。(17)其次，分税制改革前，企业不仅缴税，还要向地方政府缴纳很多费（行政收费、集资、摊派、赞助等），这部分预算外收入在改革后大大减少。<strong>90年代中后期，乡镇企业也纷纷改制，利润不再上缴，基层政府的预算外收入进一步减少</strong>。最后，2001年的税改中，<strong>中央政府又拿走了所得税收入的60%，加剧了地方财政压力</strong>。地方不得不另谋出路，寻找资金来源，轰轰烈烈的“土地财政”就此登场。</p><h3 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h3><p>我国实行土地公有制，<strong>城市土地归国家所有，农村土地归集体所有。农地要转为建设用地，必须先经过征地变成国有土地，然后才可以用于发展工商业或建造住宅。</strong>所以国有土地的价值远远高于农地。为什么会有这种城乡割裂的土地制度？追根溯源，其实也没有什么惊天动地的大道理和顶层设计，不过是从1982年宪法开始一步步演变成今天这样罢了。<strong>虽说每一步变化都有道理，针对的都是当时亟待解决的问题，但演变到今天，已经造成了巨大的城乡差别、飞涨的城市房价以及各种棘手问题。</strong></p><p>初期在分税制改革后，尽管<strong>国有土地转让的决定权和收益都留给了地方，</strong>但是还并没有作为地方的主要收入，原因如下：</p><p>一来虽然<strong>乡镇企业</strong>当时还很兴盛，但它们占用的都是农村集体建设用地，不是城市土地。</p><p>二来虽然城市土地使用权当时就可以有偿转让，不必再像计划经济体制下那样无偿划拨，但各地为了<strong>招商引资</strong>（尤其是吸引外资），土地转让价格<strong>大都非常优惠</strong>，“卖地收入”并不多。</p><p><strong>1998年</strong>，城市土地价值开始显现。原因：</p><ol><li>单位<strong>停止福利分房</strong>，逐步实行<strong>住房分配货币化，商品房和房地产时代的大幕拉开</strong>。住房不再由单位分配，逐渐商品化，产生价值。</li><li>修订后的《中华人民共和国土地管理法》开始实施，<strong>基本上锁死了农村集体土地的非农建设通道</strong>，规<strong>定了农地要想转为建设用地，必须经过征地后变成国有土地</strong>，这也就确立了<strong>城市政府对土地建设的垄断权力</strong>。</li></ol><p><strong>国有土地转让收入占地方公共预算收入的比重</strong></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220915085749567.png" alt="image-20220915085749567"></p><p>1999年和2000年这两年的国有土地转让收入并不高（图2-4），因为尚未普遍实行土地“招拍挂”（招标、拍卖、挂牌）制度。</p><p>2001年，为治理土地开发中的腐败和混乱，国务院提出“大力推行招标拍卖”。2002年，国土部明确四类经营用地（商业、旅游、娱乐、房地产）采用“招拍挂”制度。于是各地政府开始大量征收农民土地然后有偿转让，土地财政开始膨胀。土地出让收入从2001年开始激增，2003年就已经达到了地方公共预算收入的55%（图2-4）。2008年全球金融危机之后，在财政和信贷政策的共同刺激之下，土地转让收入再上一个台阶，2010年达到地方公共预算收入的68%。最近两年这一比重虽有所下降，但土地转让收入的绝对数额还在上涨，2018年达到62910亿元，比2010年高2.3倍。</p><p>所谓“土地财政”，<strong>不仅包括巨额的土地使用权转让收入，还包括与土地使用和开发有关的各种税收收入</strong>。其中大部分税收的税基是<strong>土地的价值而非面积</strong>，所以税收随着土地升值而猛增。这些<strong>税收</strong>分为两类，一类是<strong>直接和土地相关的税收</strong>，主要是土地增值税、城镇土地使用税、耕地占用税和契税，其<strong>收入百分之百归属地方政府</strong>。2018年，这四类税收共计15081亿元，占地方公共预算收入的15%，相当可观。另一类税收则和<strong>房地产开发和建筑企业</strong>有关，主要是<strong>增值税和企业所得税</strong>。2018年，这两种税收中归属地方的部分（增值税五成，所得税四成）占地方公共预算收入的比重为9%。(20)若把这些税收与土地转让收入加起来算作“土地财政”的总收入，<strong>2018年“土地财政”收入相当于地方公共预算收入的89%</strong>，是名副其实的“第二财政”。</p><p>土地税收并不等于地方的净利润，地方政府也要负担相关支出，包括<strong>征地拆迁补偿</strong>和<strong>“七通一平”等基础性土地开发支出</strong>。从近几年的数字看，跟土地转让有关的支出总体与收入相当，有时甚至比收入还高。2018年，国有土地使用权出让金收入为62910亿元，支出则为68167亿元。光看这一项，地方政府还入不敷出。当然<strong>地方政府本来也不是靠卖地赚钱，它真正要的是土地开发之后吸引来的工商业经济活动</strong>。</p><p><strong>100个重点城市土地出让季度平均成交价</strong></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220915090430922.png" alt="image-20220915090430922"></p><p>所以<strong>商住用地虽然面积上只占出让土地的一半，但贡献了几乎所有的土地使用权转让收入</strong>。因此“土地财政”的实质是“房地产财政”（即工业用地并不是主要收入，而是商业与居住用地）。一方面，各地都<strong>补贴工业用地，大力招商引资，推动了制造业迅猛发展</strong>（进而引导-&gt;）；另一方面，随着工业化和<strong>城市化</strong>的发展，大量新增人口涌入经济发达地区，而<strong>这些地方的住宅用地供给却不足，房价自然飞涨，带动地价飞涨</strong>。</p><p><strong>土地财政”虽有种种弊端，但确实是过去数年城市化和工业化得以快速推进的重要资金来源。</strong></p><p>经济学家张五常曾做过一个比喻：地方政府就像一家商场，招商引资就是引入商铺。商铺只要交一个低廉的入场费用（类似工业用地转让费），但营业收入要和商场分成（类似增值税，不管商铺是否盈利，只要有流水就要分成）。商场要追求总体收入最大化，所以既要考虑入门费和租金的平衡，也要考虑不同商铺间的平衡。一些商铺大名鼎鼎，能为商场带来更大客流，那商场不仅可以免除它们的入门费，还可以降低分成，甚至可以倒贴（类似地方给企业的各种补贴）</p><h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>以行政区划为单位、以税收和土地为手段展开招商引资竞争，且在上下级政府间层层承包责任和分享收益，这一制度架构对分税制改革后经济的飞速发展，无疑有很强的解释力。但随着时代发展，这种模式的弊端和负面效果也越来越明显，需要改革。</p><ol><li><p>首先是地方政府的债务问题（见第三章）。土地的资本化运作，本质是把未来的收益抵押到今天去借钱，如果借来的钱投资质量很高，转化成了有价值的资产和未来更高的收入，那债务就不是大问题。但地方官员任期有限，难免会催生短视行为，寅吃卯粮，过度借债去搞大项目，搞“面子工程”，功是留在当代了，利是不是有千秋，就是下任领导的事了。如此一来，投资质量下降，收益不高，债务负担就越来越重。</p></li><li><p>虽然各地都有动力调配好手中的土地资源，平衡工业和商住用地供给，但在<strong>全国范围内，</strong>土地资源和建设用地分配却很难优化。地区间虽然搞竞争，但用地指标不能跨省流动到效率更高的地区。<strong>珠三角和长三角的经济突飞猛进，人口大量涌入，却没有足够的建设用地指标，工业和人口容量都遭遇了人为的限制</strong>。寸土寸金的上海，却保留着289.6万亩农田（2020年的数字），可以说相当不经济。同时，中西部却有大量闲置甚至荒废的产业园区。虽然地广人稀的西北本就有不少荒地，所以真实的浪费情况可能没有媒体宣扬的那么夸张，但<strong>这些用地指标本可以分给经济更发达的地区</strong>。如果竞争不能让资源转移到效率更高的地方，那这种竞争就和市场竞争不同，无法长久地提高整体效率。一旦投资放水的闸门收紧，经济增长的动力立刻不足。</p><p>原因：因为经济发展阶段变了。在工业化和城市化初期，传统农业生产率低，只要把农地变成工商业用地，农业变成工商业，效率就会大大提升。但<strong>随着工业化的发展，市场竞争越来越激烈，技术要求越来越高，先进企业不仅需要土地，还需要产业集聚、研发投入、技术升级、物流和金融配套等，很多地方并不具备这些条件，徒有大量建设用地指标又有何用？</strong>改革的方向是清楚的。2020年，中共中央和国务院发布的《关于构建更加完善的要素市场化配置体制机制的意见》中，放在最前面的就是“推进土地要素市场化配置”。要求不仅要在省、市、县内部打破城乡建设用地之间的市场壁垒，建设一个统一的市场，盘活存量建设用地，而且要“探索建立全国性的建设用地、补充耕地指标跨区域交易机制”，以提高土地资源在全国范围内的配置效率。</p></li></ol><h2 id="纵向不平衡与横向不平衡"><a href="#纵向不平衡与横向不平衡" class="headerlink" title="纵向不平衡与横向不平衡"></a>纵向不平衡与横向不平衡</h2><p>分税制改革之后，中央拿走了收入的大头，但事情还是要地方办，所以支出的大头仍留在地方，<strong>地方收支差距由中央转移支付来填补。从全国总数来看，转移支付足够补上地方收支缺口</strong>。(22)但总数能补上，不等于每级政府都能补上，也不等于每个地区都能补上（纵向）。省里有钱，乡里不见得有钱；广州有钱，兰州不见得有钱（横向）。这种纵向和横向的不平衡，造成了不少矛盾和冲突，也催生了很多改革。</p><h3 id="基层财政困难（纵向）"><a href="#基层财政困难（纵向）" class="headerlink" title="基层财政困难（纵向）"></a>基层财政困难（纵向）</h3><p>分税制改革之后，中央和省分成，省也要和市县分成。可因为上级权威高于下级，所以越往基层分到的钱往往越少，但分到的任务却越来越多，出现了“财权层层上收，事权层层下压”的局面。改革后没几年，基层财政就出现了严重的困难。</p><p>在东部沿海，随着工业化和城市化的大发展，可以从“土地财政”中获取大量额外收入，一手靠预算财政“吃饭”，一手靠土地财政“办事”。但在很多中西部县乡，土地并不值钱，财政收入可能连发工资都不够，和用于办事的钱相互挤占，连“吃饭财政”都不算，要算“讨饭财政”。<strong>基层政府一旦没钱，就会想办法增收，以保持正常运转。20世纪90年代末到21世纪初，农村基层各种乱收费层出不穷，农民的日子不好过，干群关系紧张，群体性事件频发。</strong></p><p><strong>农村改革</strong>：科学发展观”对应的“五个统筹”原则中，第一条就是“统筹城乡发展”。(24)从2000年开始，农村税费改革拉开帷幕，制止基层政府乱摊派和乱收费，陆续取消了“三提五统”和“两工”等。(25)2006年1月1日，农业税彻底废止（得益于我国加入世界贸易组织（WTO）之后飞速发展的工商业，使得国家财政不再依赖于农业税费。2000年至2007年，农业部门产值占GDP的比重从15%下降到了10%，而全国税收总收入却增加了3.6倍）。</p><p>此外，之后的改革就加大了<strong>上级的统筹和转移支付力度</strong>。</p><p>其一，是把农村基本公共服务开支纳入国家公共财政保障范围，由中央和地方政府共同负担。如新农合、新农保</p><p>其二，是在转移支付制度中加入激励机制，鼓励基层政府达成特定目标，并给予奖励。比如2005年开始实施的“三奖一补”，就对精简机构和人员的县乡政府给予奖励。冗员过多一直是政府顽疾，分税制改革后建立的转移支付体系中，相当一部分转移支付是为了维持基层政府正常运转和保障人员工资。<strong>财政供养人员（即有编制的人员）越多，得到的转移支付越多，这自然会刺激地方政府扩编。</strong>从1994年到2005年，地方政府的财政供养人员（在职加退休）猛增了60%，从2981万人增加到4778万人。2005年实行“三奖一补”之后，<strong>2006年财政供养人口下降了318万。之后又开始缓慢上升，2008年达到4631万。2009年后，财政供养人员的数据不再公布。</strong>（如今，房地产市场崩盘，地方为了扩大收入，可能会继续进行公务员等地扩编获取转移支付的收入）</p><p>其三，是把基层财政资源向上一级政府统筹。比如2003年开始试点的“乡财县管”改革。农村税费改革后，<strong>乡镇一级的财政收入规模和支出范围大大缩减，乡镇冗员问题、管理问题、债务问题就变得突出。通过预算共编、票据统管、县乡联网等手段，把乡镇财政支出的决定权上收到县</strong>，有利于规范乡镇行为，也有利于在县域范围内实现乡镇之间公共服务的均等化。根据财政部网站，截至2012年底，86%的乡镇都已经实施了“乡财县管”。</p><p><strong>让县政府去统筹乡镇财务，那县一级的财政紧张状况又该怎么办呢？</strong>在市管县的行政体制下，县的收入要和市里分账，可<strong>市财政支出和招商引资却一直偏向市区</strong>，“市压县，市刮县，市吃县”现象严重，城乡差距不断拉大。而且很多城市本身经济发展水平也不高，难以对下辖县产生拉动作用，所以在21世纪初，全国开始推行<strong>“扩权强县”和“财政省直管县”</strong>改革。<strong>前者给县里下放一些和市里等同的权限，比如土地审批、证照发放等；后者则让县财政和省财政直接发生关系，绕开市财政，在财政收支权力上做到县市平级</strong>。这些改革增加了县一级的财政资源，缩小了城乡差距。</p><p>乡财县管”和“省直管县”改革，实质上把我国五级的行政管理体制（中央—省—市—区县—乡镇）在财政管理体制上“拉平”了，变成了三级体制（中央—省—市县）。县里的财政实力固然是强了，<strong>但是否有利于长远经济发展，则不一定。</strong></p><p>缺陷：1. 省里管不过来  2. 市和县本是合作大于竞争的关系，但是由于县权力扩大，导致县域经济“孤岛化”比较严重。尤其在经济欠发达地区，市的实力本就不强，现在进一步分裂成区和县，<strong>更难以产生规模和集聚效应</strong>。经济弱市的“小马”本就拉不动下辖县的“大车”，但改革并没有把“小马”变成“大马”，反倒把“大车”劈成了一辆辆“小车”，结果是小城镇遍地开花，经济活动和人口不但没有向区域经济中心的市区集聚，反而越搞越散。<strong>从现有研究来看，省直管县之后，虽然县里有了更多资源，但人均GDP增速反而放缓了。</strong></p><h3 id="地区间不平等（横向）"><a href="#地区间不平等（横向）" class="headerlink" title="地区间不平等（横向）"></a>地区间不平等（横向）</h3><p>沿海经济发展远大于中西部地区。</p><p>中央也开始对中西部地区进行大规模转移支付。1995年至2018年，转移支付总额从665亿元增加到了61649亿元，增加了93倍，远高于地方财政收入的增长率，占GDP的比重也从1%升至7%。(32)80%以上的转移支付都到了中西部地区，这保障了地区间人均财政支出的均等化。(33)<strong>虽然目前东部和中西部的公共服务水平差异依然明显，但如果没有中央转移支付，地区差异可能更大。</strong></p><p>中央对地方的转移支付大概可以分为两类：一般性转移支付（2009年之后改称“<strong>均衡性转移支付</strong>”）和专项转移支付。(35)简单来说，前者附加条件少，地方可自行决定用途，而后者必须专款专用。为什么要指定资金用途、不让地方自主决策呢？因为无条件的均衡性转移支付是为了拉平地区差距，<strong>所以越穷的地方拿到的钱越多，地方也就越缺乏增收动力。而且均衡性转移支付要保证政府运作和公务员工资，可能会刺激财政供养人员增加，恶化冗员问题。</strong></p><p>专项转移支付约占转移支付总额的<strong>四成</strong>，一般以“做项目”的形式来分配资金，专款专用，可以约束下级把钱花在上级指定的地方，但在实际操作中，<strong>这种转移支付加大了地区间的不平等。(36)经济情况越好、财力越雄厚的地区，反而可能拿到更多的专项转移支付项目</strong>，原因有三。第一，上级分配项目时一般不会“撒胡椒面儿”，而是<strong>倾向于集中财力投资大项目，并且交给有能力和条件的地区来做，所谓“突出重点，择优支持</strong>”。第二，2015年之前，<strong>许多项目都要求地方政府提供配套资金，只有有能力配套的地方才有能力承接大项目，拿到更多转移支付</strong>。(37)第三，项目审批过程中人情关系在所难免。很多专项资金是由财政部先拨款给各部委后再层层下拨，所以就有了“跑部钱进”的现象，而<strong>经济发达地区往往与中央部委的关系也更好</strong>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220915093857603.png" alt="image-20220915093857603"></p><p>分税制之后兴起的“土地财政”，为地方政府贡献了每年五六万亿的土地使用权转让收入，着实可观，但仍不足以撬动飞速的工业化和城市化。想想每年的基础设施建设投入，想想高铁从起步到普及不过区区十年，钱从哪里来？每个城市都在大搞建设，高楼、公园、道路、园区……日新月异，钱从哪里来？所以土地真正的力量还不在“土地财政”，而在<strong>以土地为抵押而撬动的银行信贷与其他各路资金</strong>。“土地财政”一旦嫁接了资本市场，加上了杠杆，就成了“土地金融”，能像滚雪球般越滚越大，推动经济飞速扩张，也造就了地方政府越滚越多的债务，引发了一系列宏观经济问题。</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><p>土地本身并不值钱，值钱的是土地之上的经济活动。</p><p>上一章介绍了城市政府如何平衡工业用地和商住用地供应，一手搞“工业化”，一手搞“城市化”，用土地使用权转让费撑起了“第二财政”。但这种一笔一笔的转让交易并不能完全体现土地的金融属性。地方政府还可以把与土地相关的<strong>未来收入资本化，去获取贷款和各类资金，将“土地财政”的规模成倍放大为“土地金融”</strong>。</p><p>本章第一节用实例来解释这种“土地金融”与政府投资模式。第二节介绍这种模式的弊端之一，即地方政府不断加重的债务负担。与政府债务相关的各项改革中也涉及对官员评价和激励机制的改革，因此第三节将展开分析地方官员在政府投融资过程中的角色和行为。</p><h2 id="城投公司与土地金融"><a href="#城投公司与土地金融" class="headerlink" title="城投公司与土地金融"></a>城投公司与土地金融</h2><p>​    实业投资要比金融投资复杂得多，除了考虑时间、利率、风险等基本要素之外，还要处理现实中的种种复杂情况。</p><p>​    实业投资不是买卖股票，不能随时退出，且投资过程往往不可逆：未能完成或未能正常运转的项目，前期的投入可能血本无归。所以政府一旦下场就很难抽身，常常不得不深度干预。在很长一段时期内，中国GDP增长的主要动力来自投资，这种增长方式必然伴随着政府深度参与经济活动。</p><p><strong>城投公司的由来：</strong></p><pre><code>1. 法律规定，**地方政府不能从银行贷款**，2015年之前也不允许发行债券，所以**政府要想借钱投资，需要成立专门的公司**。这类公司大都是国有独资企业，一般统称为“地方政府融资平台”。这个名称突出了其融资和负债功能。这些平台名称大多有建设投资、投资开发等字样。</code></pre><p>​    比如芜湖建设投资有限公司（奇瑞汽车大股东）和上海城市建设投资开发总公司（即上海城投集团），都是当地国资委的全资公司。还有一些公司专门开发旅游景点，名称中一般有“旅游发展”字样，比如成都文化旅游发展集团，也是成都市政府的全资公司，开发过著名景点“宽窄巷子”。</p><ol><li>城建开发项目繁复，包括自来水、道路、公园、防洪，等等，有的赚钱，有的赔钱，但缺了哪个都不行，所以不能以单个项目分头借款，最好捆绑在一起，以赚钱的项目带动不赚钱的项目</li><li>仅靠财政预算收入不够还债，要能把跟土地有关的收益用起来。</li></ol><p><strong>以成都宽窄巷子为例：</strong></p><p>​    由于项目的难度，该项目从建立到完成都是政府一手操办的。2007年之前由成都城投集团负责，之后则由成都文旅集团接手。</p><p>成都文旅集团具有政府融资平台类公司的典型特征：</p><p>​    第一，它持有从政府取得的大量土地使用权。</p><p>​    第二，<strong>盈利状况依赖政府补贴</strong>。项目本身盈利性不强，该类项目的回报不能只看项目本身，还要算上它带动的经济效益和社会效益。对政府和老百姓来说，这也许比项目本身的盈利能力更加重要。</p><p>​    第三，政府的隐性担保可以让企业大量借款。市场自然认为这些公司不会破产，政府不会“见死不救”，所以风险很低。</p><p><strong>工业园区开发</strong>：</p><p>​    城投公司的主业是工业园区开发和城市基础设施建设。</p><p>​    在经济发展不高的区域，政府会把一部分地委托给民营企业，借此来开发产业园区。</p><p><strong>以华夏幸福为例：</strong></p><p>​    该公司的经营模式为<strong>产城结合</strong>：同时开发产业园区与房地产。政府将土地交给华夏幸福完成一级开发进行拆迁和九通一平，之后通过一些手段继续由华夏完成房地产二级开发。通过房地产的盈利来反哺产业园区。</p><p>​    政府“亏本”招商引资，图的是税收和就业。</p><p>​    华夏幸福也可以和政府分享税收收益。按照法律，政府不能和企业直接分享税收，但可以购买企业服务，以产业发展服务费的名义来支付约定的分成。</p><h2 id="地方政府债务"><a href="#地方政府债务" class="headerlink" title="地方政府债务"></a>地方政府债务</h2><p>房价只涨不降的原因：</p><p>​    1994年分税制改革后，中央拿走了大部分税收。但因为有税收返还和转移支付，地方政府维持运转问题不大。但地方还要发展经济，要招商引资，要投资，都需要钱。随着城市化和商品房改革，土地价值飙升，政府不仅靠土地使用权转让收入支撑起了“土地财政”，还将未来的土地收益资本化，从银行和其他渠道借入了天量资金，利用“土地金融”的巨力，推动了快速的工业化和城市化。但同时也积累了大量债务。这套模式的关键是<strong>土地价格</strong>。只要不断地投资和建设能带来持续的经济增长，城市就会扩张，地价就会上涨，就可以偿还连本带利越滚越多的债务。可<strong>经济增速一旦放缓，地价下跌，土地出让收入减少，累积的债务就会成为沉重的负担，可能压垮融资平台甚至地方政府。</strong></p><p><img src="https://blog-markdown-1308253960.cos.ap-shanghai.myqcloud.com/markdown/image-20220919175935236.png" alt="image-20220919175935236"></p><p>​    为应对金融危机，我国当时迅速出台“4万亿”计划：中央政府投资1.18万亿元（包括汶川地震重建的财政拨款），地方政府投资2.82万亿元。为配合政策落地、帮助地方政府融资，中央也放宽了对地方融资平台和银行信贷的限制。2008年，全国共有融资平台公司3000余家，2009年激增至8000余家，其中六成左右是县一级政府融资平台。快速猛烈的经济刺激，对提振急速恶化的经济很有必要，但大水漫灌的结果必然是泥沙俱下。财政状况不佳的地方也能大量借钱，盈利前景堪忧的项目也能大量融资。短短三五年，地方政府就积累了天量债务。直到十年后的今天，这些债务依然没有完全化解，还存在不小的风险。</p><h3 id="城商行"><a href="#城商行" class="headerlink" title="城商行"></a>城商行</h3><p>​    2010年，在地方融资平台公司的所有贷款中，<strong>国开行</strong>约2万亿元，<strong>四大行</strong>2万亿元，<strong>城商行</strong>（七成左右的城商行的第一股东是地方政府）2.2万亿元，其他股份制银行与农村合作金融机构合计1万亿元。</p><p>​    <strong>城商行相比于国开行和四大行存在不稳定因素。</strong></p><p>​    其一，基础设施建设项目周期长，需要中长期贷款。国开行是政策性银行，有稳定的长期资金来源，适合提供中长期贷款。但商业银行的资金大都来自短期存款，与中长期贷款期限不匹配，容易产生风险。其二，四大行的存款来源庞大稳定，可以承受一定程度的期限错配。但<strong>城商行的存款来源并不稳定，自有资本也比较薄弱</strong>，所以经常需要在资本市场上融资，容易出现风险（想今年出事的河南银行）。</p><p>​    <strong>城商行融资方式</strong></p><p>​    城投公司最主要的融资方式是银行贷款，其次是发行债券，即通常所说的城投债。与贷款相比，发行债券有两个理论上的好处。其一，把债券卖给广大投资者可以分散风险，而贷款风险都集中在银行系统；其二，债券可以交易，价格和利率时时变动，反映了市场对风险的看法。高风险债券价格更低，利率更高。灵活的价格机制可以把不同风险的债券分配给不同类型的投资者，提高了配置效率。</p><p>​    但对城投债来说，这两个理论上的好处基本都不存在。第一，绝大多数城投债都在银行间市场发行，七八成都被商业银行持有，流动性差，风险依然集中在银行系统。第二，市场认为城投债有政府隐性担保，非常安全。缺钱的地方明明风险不小，但若发债时提高一点利率，也会受市场追捧。事实证明市场是理性的。城投债从2008年“4万亿”刺激后开始爆发，虽经历了大小数次改革和清理整顿，但整体违约率极低。<strong>这个低风险高收益的“怪胎”对债券市场发展影响很大，积累的风险其实不小。</strong></p><h3 id="地方债务与风险"><a href="#地方债务与风险" class="headerlink" title="地方债务与风险"></a>地方债务与风险</h3><p>中外学术界和业界对中国的地方政府债务做了大量研究，所估计的地方债务总额在2015年到2017年间约为四五十万亿元，占GDP的五六成，其中三四成是隐性负债。</p><p>​    地方债务水平虽然不低，但相比于其他国家其实算好的了（美国 107% 日本 237%）。而且我国地方政府借来的钱，并没有多少用于政府运营性支出，也没有像一些欧洲国家如希腊那样去支付社会保障，而<strong>主要是投资在了基础设施项目上，形成了实实在在的资产</strong>。虽然这些投资项目的回报率很低，可能平均不到1%，但如果“算大账”，事实上也拉动了GDP，完善了基础设施，方便了民众生活，整体经济与社会效益可能比项目回报率高。</p><p>​    虽然从经济分析的角度看，地方政府投资的项目有很多外溢的经济效益和社会效益，但在现实世界里，还债需要借款人手中实打实的现金，虚的效益没用。<strong>融资平台投资回报率低，收入就低，还债就有困难。</strong>由于有地方政府背后支持，这些公司只要能还上利息和到期的部分本金，就能靠借新还旧来滚动和延续其余债务。但大多数融资平台收入太少，就算是只还利息也要靠政府补贴。2017年，除了北京、上海、广东、福建、四川和安徽等六省市外，其他省份的融资平台公司的平均收入，若扣除政府补贴，都无法覆盖债务利息支出。(20)但政府补贴的前提是政府有钱，这些钱主要来自和土地开发有关的各种收入。<strong>一旦经济遇冷，地价下跌，政府也背不起这沉重的债务。</strong></p><h3 id="治理手段"><a href="#治理手段" class="headerlink" title="治理手段"></a>治理手段</h3><ol><li>债务置换。债务置换就是用地方政府发行的公债，替换一部分融资平台公司的银行贷款和城投债。</li><li>改革是推动融资平台转型，厘清与政府之间的关系，剥离其为政府融资的功能，同时破除政府对其形成的“隐性”担保。</li><li>约束银行和各类金融机构，避免大量资金流入融资平台。</li><li>问责官员</li></ol><h2 id="地方官员"><a href="#地方官员" class="headerlink" title="地方官员"></a>地方官员</h2><p>​    从人数构成上看，地方官员是官僚体系的绝对主体。按公务员总人数算，中央公务员只占6%，若把各类事业单位也算上，中央只占4%。这在世界各主要国家中是个异数。美国中央政府公务员占比为19%，日本为14%，德国为11%，而经济合作与发展组织（OECD）成员国的平均值高达41%。——主要还是因为我国地广人多的特点…</p><p>​    <strong>经济发展是地方官的主要政绩</strong>，对其声望和升迁有重要影响。而对广大普通政府工作人员而言，职务晋升机会虽然很少，但实际收入与本地财政情况密切相关，也和本部门、本单位的绩效密切相关，这些又都取决于本地的经济发展。</p><p>​    <strong>地方主官任期有限</strong>，要想在任内快速提升经济增长，往往只能<strong>加大投资力度，上马各种大工程、大项目</strong>。以市委书记和市长为例，在一个城市的平均任期不过三四年，而基础设施或工业项目最快也要两三年才能完成，所以“新官上任三把火”烧得又快又猛：上任头两年，基础设施投资、工业投资、财政支出往往都会快速上涨。</p><p>​    <strong>缺陷</strong>：2016年之前，官员升迁或调任后就无需再对任内的负债负责，而新官又通常不理旧账，会<strong>继续加大投资，所以政府债务不断攀升</strong>。在经济发展到一定阶段之后，低风险高收益的工业投资项目减少，基础设施和城市建设投资的经济效益也在减弱，继续加大投资会降低经济整体效率，助推产能过剩。此外，出于政绩考虑，<strong>地方官员在基础设施投资方面常常偏重“看得见”的工程建设</strong>，比如城市道路、桥梁、地铁、绿地等，<strong>相对忽视“看不见”的工程，比如地下管网</strong>。所以每逢暴雨，“看海”的城市就很多。</p><h3 id="治理"><a href="#治理" class="headerlink" title="治理"></a>治理</h3><ol><li>2013年，中组部发布《关于改进地方党政领导班子和领导干部政绩考核工作的通知》，特别强调：“<strong>不能仅仅把地区生产总值及增长率作为考核评价政绩的主要指标</strong>，不能搞地区生产总值及增长率排名。</li><li>2019年，中共中央办公厅印发《党政领导干部考核工作条例》，明确在考核地方党委和政府领导班子的工作实绩时，要看“全面工作”</li></ol><h3 id="腐败与反腐败"><a href="#腐败与反腐败" class="headerlink" title="腐败与反腐败"></a>腐败与反腐败</h3><p>​    政绩和晋升无疑对地方一把手和领导班子成员非常重要，却无法激励绝大多数公务员。</p><p>​    他们的日常工作与政绩关系不大，晋升希望也十分渺茫。在庞大的政府工作人员群体中，<strong>“县处级”及以上的干部大约只占总人数的1%。</strong>平均来说，在一个县里所有的正科实职干部中，每年升副县级的概率也就1%，而从副县级干部到县委副书记，还要经历好几个岗位和台阶，动辄数年乃至数十年。因此绝大多数政府工作人员最在意的激励并不是晋升，而是实际收入以及一些工作福利，包括工资、奖金、补助、补贴、实惠的食堂、舒适的办公条件，等等。</p><p><strong>我国的腐败现象有两个显著特点。</strong></p><p>第一，<strong>腐败与经济高速增长长期并存</strong>。这与“腐败危害经济”这一过度简单化的主流观念冲突，以腐败为由唱空中国经济的预测屡屡落空。第二，随着改革的深入，政府和市场间关系在不断变化，腐败形式也在不断变化。20世纪80年代的腐败案件大多与价格双轨制下的“官倒”和各种“投机倒把”有关；90年代的案件则多与国企改革和国有资产流失有关；21世纪以来，与土地开发相关的案件成了主流。</p><p><strong>腐败大概可以分为两类</strong>。</p><p>第一类是<strong>“掠夺式”</strong>腐败，比如对私营企业敲诈勒索、向老百姓索贿、盗用挪用公款等，这类腐败对经济增长和产权保护极其有害。随着我国各项制度和法制建设的不断完善、各种监督技术的不断进步，<strong>这类腐败已大大减少</strong>。</p><p>第二类腐败是<strong>“官商勾连共同发财式”</strong>腐败。比如官员利用职权把项目批给关系户企业，而企业不仅要完成项目、为官员贡献政绩，也要在私下给官员很多好处。这类腐败发生在招商引资过程中，而相关投资和建设可以促进经济短期增长，所以腐败在一段时期内可以和经济增长并存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="读书" scheme="http://ppnostalgia.github.io./categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://ppnostalgia.github.io./tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>面试准备</title>
    <link href="http://ppnostalgia.github.io./c5576490.html"/>
    <id>http://ppnostalgia.github.io./c5576490.html</id>
    <published>2022-08-26T07:55:34.000Z</published>
    <updated>2022-11-04T06:23:11.315Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="实习项目"><a href="#实习项目" class="headerlink" title="实习项目"></a>实习项目</h1><p><strong>做了哪些算法？</strong></p><p>节假日假冒客一、大件运输车逃费、假冒免费车辆、有入无出、跨省屏蔽通行介质</p><p><strong>介绍下实习中遇到的困难？</strong></p><p><strong>有入无出</strong></p><p>a) 根据3天范围数据进行检索(3天内的入口数据，3天范围内的出数据表，门架表，牌识表).<br>b) <strong>没有与入口数据对应的出口数据</strong>.对应上的条件为(车牌+入口时间相同)或(卡号+入口时间相同)或(站点+入口时间相同)或（出口流水中为无通行介质且出入口时间相同，则使用入口车牌+入口站相同且入口时间&lt;出口时间）<br>c）根据相邻的入口数据入口时间取轨迹检索截断时间？？？。<br>d) 符合上述,在上述时间范围内检索门架数据。要求： 门架轨迹长度&gt;15,结尾不是承载门架或省界门架。<br>e）同上规则检索牌识轨迹：牌识轨迹长度&gt;15,,结尾不是承载门架或省界门架。<br>f)符合上述：输出</p><p><strong>跨省屏蔽通行介质</strong></p><p>高速公路有一种逃费方法是<strong>跨省屏蔽通行介质</strong>的，这种类型的车是全程屏蔽etc的，它在出入口中均没有记录，难点就是可用数据太少，唯一提供鉴别性的门架牌识信息，写了一种算法</p><p>在入口表和出口表中，均没有该车的记录，在门架表中，也没有该车的记录。但是在牌识表中，能找到该车的记录，且从牌识表中，能看到该车经过省界门架进入和离开</p><p>1.查询单位时间内(现在是使用 1天 为单位)的牌识数据.vehiclePlate.截取车牌号,以 出口数据表.exVehicleId.截取车牌号 和 入口数据表.vehicleId.截取车牌 作为查询条件,过滤掉能找到对应记录的,保留找不到的.（可改为出入口流水的passID进行比较）<br>2.对剩余牌识数据,按牌识数据.vehiclePlate进行分组,合并轨迹,按时间升序排序.删除数据长度小于10的.<br>3.分组合并后的牌识轨迹,若首/尾门架都是省界门架,则保留否则删除.<br>4.剩余的轨迹,若首-尾时间范围内在 门架表 中按”vehicleplate.截取车牌号(无颜色约束)”查询不到,则输出<br>逃费金额计算：修复门架金额。</p><p><strong>实习收获</strong></p><p>数据库sql优化经验</p><ol><li>索引字段不要太长，否则会导致索引节点可以存储的key变少，B+数高度增加，增大io次数，减慢查询效率</li><li>尽量使用join代替子查询，因为子查询是临时表没有索引</li><li>尽量避免使用函数对列进行转换和计算</li></ol><p>20%</p><h1 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h1><p>不熟悉的一些问题</p><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><ol><li><p>10亿条数据，如何找到出现频率最高Top100</p><p>分治+Trie树/hash+小顶堆（就是上面提到的最小堆），即先将数据集按照Hash方法分解成多个小数据集，然后使用Trie树或者Hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出现频率最高的前K个数（小顶堆的话会每次弹出K个中最小的元素），最后在所有top K中求出最终的top K。</p></li><li><p>如何保证三个线程<strong>顺序执行</strong>？</p><ol><li>使用reentrantlock，底层有个线程等待队列，可以通过condition方法</li><li>使用<strong>countdownlatch</strong>减数器，定义一个（几个线程n-1个这个）countdownlatch（1），a线程执行完调用减数器的countdown方法减一，若为0，唤醒其他处于同步队列中的线程，其他线程为await  例子：A countDown(AB) -1, B await  (AB 0)唤醒 countDown(BC) -1 C   await(BC  0)</li><li>jdk1.8中的CompletableFuture对象方法</li><li>semaphore信号量（0） A 执行完，调用release方法信号量+1，B调用acquire方法-1，执行完，释放+1，C-1</li></ol></li><li><p>大文件去重：8G内存，50G的文件，如何去重</p><ol><li>先将50G的数据分别做hash%1000，分成1000个文件，理论上hash做得好那么这1000个文件的大小是差不多接近的。如果有重复，那么<strong>A和B的重复数据一定在相对同一个文件内</strong>，因为hash结果是一样的。将1000个文件分别加载进来，<strong>一一比对是否有hash重复</strong>。这种想法是先把所有数据按照相关性进行分组，相关的数据会处于同样或者接近的位置中，再将小文件进行对比。</li></ol></li><li><p>十万个数，找最频繁的数</p><ol><li><p>常规思路：map，key：数  value：出现次数。取出value数组，排序，找到key对应的value等于最大出现次数的</p></li><li><p>小顶堆（一般我们直接用优先队列实现堆：）: 维护一个k大小的小顶堆，若大小大于k，弹出顶部元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;o1.getValue()-o2.getValue());</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:entries)&#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span>(queue.size()&gt;k)&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            result[i]=queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>可视化工具：sourcetree</p><ol><li><p>git <strong>remote</strong> add origin 。。。</p></li><li><p>git push origin master</p></li><li><p>git checkout -b test 创建并切换分支 </p></li><li><p>git merge test 将当前分支与test分支合并  git rebase master test 把master分支合并到test分支，（这一步的场景就可以类比为我们在自己的分支feature上开发了一段时间了，准备从主干master上拉一下最新改动）</p><p>当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向基分支的最新提交，最后将刚才提取的修改应用到<strong>基分支的最新提交的后面</strong>。不建议使用，容易篡改历史</p><p>git merge只需要解决一次冲突  git rebase需要解决多次冲突</p></li></ol><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ol><li>docker ps</li><li>docker image ls 查看所有已下载镜像</li><li>docker container ls 查看所有容器</li><li>docker build -t hello</li></ol><p>​    怎么打包docker镜像？</p><pre><code> 1. 准备jar包 2. 编写dockerfile文件 3. 编译镜像包 docker build -t hello 4. docker run </code></pre><p>​    docker exec -it container id/names /bin/bash</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><strong>常用命令</strong></p><ol><li><p>查看端口： lsof -i </p></li><li><p>创建文件：touch a.txt  vi a.txt</p></li><li><p>远程拷贝文件： scp -r 用户名@ip地址：文件路径  目录</p></li><li>cat/tail 查看文件</li><li>tar -zcvf xxx 压缩  tar -xvf 解压</li><li>r4w2x1  所有者 所在组 其他用户  chmod 777 test.txt</li><li>ps -ef 查看正在运行的进程  ps -ef | grep redis</li><li>网卡信息 ipconfig  </li><li><strong>netstat -an</strong>  查看端口使用情况</li><li>pwd 查看当前位置</li><li><strong>查找文件</strong>  <strong>find /home -name “*.txt”</strong>  find . 当前目录下所有文件和文件夹</li><li>查看一个进程的内存  top -p xxx  或者ps -ef | grep kafka</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>稳定性：待排序的序列中有两元素相等,排序之后它们的<strong>先后顺序</strong>不变</p><p>时间复杂度：“以nlog2n的速度<strong>快些归队</strong>”，其中快指<strong>快速排序</strong>，些指<strong>希尔排序</strong>，归指<strong>归并排序</strong>，队指<strong>堆排序</strong>。<br>初始有序的情况下，直接插入排序和冒泡排序的时间复杂度为O(n)，简记为“容易插”和“冒得好”<br>算法稳定性：“情绪<strong>不稳定</strong>，<strong>快些选一堆</strong>零食解压吧”，其中快指<strong>快速排序</strong>，些指希尔排序，选指<strong>简单选择排序</strong>，堆指<strong>堆排序</strong>，这四种排序方式是不稳定的。</p><p><strong>冒泡排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// Set a flag, if true, that means the loop has not been swapped,</span></span><br><span class="line">        <span class="comment">// that is, the sequence has been ordered, the sorting has been completed.</span></span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=arr[j];</span><br><span class="line">                arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                flag=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li><strong>空间复杂度</strong> ：O(1)</li></ul><p><strong>归并排序思想</strong></p><p>采用分治法，先使每个子序列有序，再使子序列段间有序</p><p>步骤：</p><p>将序列中待排序数字分为若干组，每个数字分为一组。然后将若干组两两合并，保证合并的组都是有序的。重复上一步的操作，直到剩下最后一组即为有序数列。</p><ul><li><strong>稳定性</strong>：稳定</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：O(n)</li></ul><p>为什么最坏为nlogn?</p><p><strong>这是因为无论是最坏情况还是平均情况，合并排序只是在每个阶段将数组分成两半，这给它 lg(n) 分量，而另一个 N 分量来自它在每个阶段进行的比较.因此，将其组合起来几乎是 O(nlg n)。无论是平均情况还是最坏情况，lg(n) 因子始终存在。剩余 N 因子取决于在两种情况下进行的比较所进行的比较。现在最坏的情况是在每个阶段对 N 个输入进行 N 次比较。所以它变成了 O(nlg n)。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> middle = arr.length / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] arr_1 = Arrays.copyOfRange(arr, <span class="number">0</span>, middle);</span><br><span class="line">    <span class="keyword">int</span>[] arr_2 = Arrays.copyOfRange(arr, middle, arr.length);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(arr_1), mergeSort(arr_2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Merge two sorted arrays</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr_1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr_2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> sorted_arr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] arr_1, <span class="keyword">int</span>[] arr_2) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] sorted_arr = <span class="keyword">new</span> <span class="keyword">int</span>[arr_1.length + arr_2.length];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>, idx_1 = <span class="number">0</span>, idx_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (idx_1 &lt; arr_1.length &amp;&amp; idx_2 &lt; arr_2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr_1[idx_1] &lt; arr_2[idx_2]) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_1[idx_1];</span><br><span class="line">            idx_1 += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sorted_arr[idx] = arr_2[idx_2];</span><br><span class="line">            idx_2 += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        idx += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (idx_1 &lt; arr_1.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx_1 &lt; arr_1.length) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_1[idx_1];</span><br><span class="line">            idx_1 += <span class="number">1</span>;</span><br><span class="line">            idx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (idx_2 &lt; arr_2.length) &#123;</span><br><span class="line">            sorted_arr[idx] = arr_2[idx_2];</span><br><span class="line">            idx_2 += <span class="number">1</span>;</span><br><span class="line">            idx += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sorted_arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序思想</p><p>​        通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p><p>​        步骤：</p><pre><code>        1. 从序列中**随机**挑出一个元素，做为 “基准”(`pivot`)；        1. 重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；        1. 递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</code></pre><p>​    算法分析</p><ul><li><strong>稳定性</strong> ：不稳定 不稳定发生在中枢元素和a[j] 交换的时刻。</li><li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(n^2)，平均：O(nlogn)</li><li><strong>空间复杂度</strong> ：O(nlogn)</li></ul><p>​        最差情况：划分不平衡，每次选取的主元素为最大或最小元素</p><p>​        解决：选取随机化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> leftBound,<span class="keyword">int</span> rightBound)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(leftBound &gt;= rightBound) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid= partition(arr, leftBound, rightBound); <span class="comment">//得到轴的位置</span></span><br><span class="line">sort(arr, leftBound, mid-<span class="number">1</span>); <span class="comment">//左边排序</span></span><br><span class="line">sort(arr, mid+<span class="number">1</span>, rightBound); <span class="comment">//右边排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> leftBound,<span class="keyword">int</span> rightBound)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[rightBound]; <span class="comment">//指定数组最右边的数是用来比较的值 轴</span></span><br><span class="line"><span class="keyword">int</span> left = leftBound;</span><br><span class="line"><span class="keyword">int</span> right = rightBound - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right &amp;&amp; arr[left] &lt;= pivot) left++;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right &amp;&amp; arr[right] &gt; pivot) right--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="comment">//如果 左边的数比右边的数小  两个数交换</span></span><br><span class="line">swap(arr, left, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把left最后一次指向的位置与pivot（轴）的位置交换</span></span><br><span class="line">swap(arr, left, rightBound);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left; <span class="comment">//返回轴的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>栈和队列的区别</p><ol><li>队列：先进先出(First In First Out)FIFO 栈：先进后出(First In Last Out )FILO</li><li>队列：只能在表的一端进行插入，并在表的另一端进行删除;栈：只能在表的一端插入和删除。</li></ol><p>堆</p><p>堆是一种满足以下条件的树：</p><p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p><p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong> 堆的初始化时间复杂度为 <code>O(nlog(n))</code>，堆可以做到<strong>O(1)</strong>时间复杂度取出最大值或者最小值，<strong>O(log(n))</strong>时间复杂度插入或者删除数据</p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ol><li><p>抽象类和接口的区别</p><p>语法层面上的区别：</p><ul><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而<strong>抽象类可以有静态代码块和静态方法</strong>；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ul><p>设计层面上的区别：</p><ul><li>抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对<strong>整个类整体进行抽象</strong>，包括属性、行为，但是接口却是对类<strong>局部（行为）</strong>进行抽象。</li><li>设计层面不同，抽象类作为很多子类的父类，它是一种<strong>模板式设计</strong>。而接口是一种<strong>行为规范</strong>，它是一种辐射式设计。</li></ul></li><li><p>解决hash冲突方法？</p><ol><li>开放定址法（再散列法）：如果<code>p=H(key)</code>出现冲突时，则以<code>p</code>为基础，再次hash，<code>p1=H(p)</code>,如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址<code>pi</code>。</li><li>多重散列法：提供<strong>多个不同的hash</strong>函数，当<code>R1=H1(key1)</code>发生冲突时，再计算<code>R2=H2(key1)</code>，直到没有冲突为止。 </li><li>链地址法：将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。</li></ol></li><li><p>switch支持<strong>枚举类型和字符串</strong>，byte、short、char、int</p></li><li><p><strong>Threadlocal</strong></p><ol><li><p>应用场景：</p><p>   数据库连接池、会话管理</p></li><li><p>ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。</p></li><li><p>内存泄漏问题</p><p>   如何解决？</p><p>   使用完ThreadLocal后，及时调用remove()方法释放内存空间。在拦截器的aftercompletion方法里释放空间</p></li><li><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p></li></ol></li><li><p>泛型</p><pre><code>   定义：泛型就是将类型参数化，其在编译时才确定具体的参数。   原理：一种语法糖，基本原理是类型擦除：使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数。   好处：1. 提供了编译期类型安全，确保只把正确类型的对象放入对象中   2. 避免强制类型转换</code></pre></li><li><p>hashmap为什么线程不安全？</p><pre><code>  1. 多线程put时，可能会导致相同hash值元素的覆盖  2. put和get并发时，若put导致元素个数超出threshold而导致rehash，线程2此时执行get获得null  链表转红黑树阈值为8？泊松分布，链表中元素个数为 8 时的概率已经非常小，再多的就更少了</code></pre></li><li><p>Concurrenthashmap</p><pre><code>  1. 1.7是由segment数组+hashentry数组组成（锁分段）   1.8 数组+链表+红黑树（锁元素）  2. 如何保证线程安全的？ 1.7用了分段锁  1.8用了cas+synchronized</code></pre></li><li><p>hashtable</p><pre><code>  Hashtable是使用Synchronized来实现线程安全的，**给整个哈希表加了一把大锁**，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放</code></pre><p>   <strong>与hashmap的区别：</strong></p><p>   <strong>底层数据结构</strong>不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树<br>   Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。<br>   添加key-value的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法,而HashTable是直接采用key的hashCode()<br>   <strong>实现方式不同</strong>：Hashtable 继承的是 Dictionary类，而 HashMap 继承的是 AbstractMap 类。<br>   <strong>初始化容量不同</strong>：HashMap 的初始容量为：<strong>16，</strong>Hashtable 初始容量为：<strong>11</strong>，两者的负载因子默认都是：0.75。<br>   <strong>扩容机制不同</strong>：当已用容量&gt;总容量 <em> 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 +1。<br>   支持的遍历种类不同：HashMap只支持Iterator遍历,而HashTable支持Iterator和Enumeration两种方式遍历<br>   <em>*迭代器不同</em></em>：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。<br>   部分API不同：HashMap不支持contains(Object value)方法，没有重写toString()方法,而HashTable支持contains(Object value)方法，而且重写了toString()方法<br>   同步性不同: Hashtable是同步(synchronized)的，适用于多线程环境, 而hashmap不是同步的，适用于单线程环境。多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。</p></li><li><p>hashset去重原理</p><pre><code>   获取对象的hashcode值，然后得到数组存储下标，如果为空直接添加，如果不为空，调用equals判断如果相同插入失败</code></pre></li><li><p>Java的多态怎么理解？什么是运行时多态和编译时多态？</p><pre><code>             它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。             重载（overload）就是编译时多态的一个例子，编译时多态在编译时就已经确定，运行的时候调用的是确定的方法。             编译时不确定究竟调用哪个具体方法，一直延迟到运行时才能确定。</code></pre></li><li><p>static理解</p><pre><code>               static修饰的成员被所有对象共享，位于方法区中，static优于对象存在，它在类加载过程中的准备阶段，会为static变量分配存储空间，并进行初始化。</code></pre></li><li><p>访问控制权限</p><pre><code>           package（默认）、private、public和protected.           package:同一个包内的其他类可以访问           private:只能被同一个类的其他方法访问           public:都可以访问           protected:只能在子类和同一个包里面的类访问</code></pre></li><li><p>Object类有哪些方法</p><pre><code>           - toString           - getClass           - finalize：该方法用于释放资源           - equals           - hashCode           - wait(使当前线程等待该对象的锁)、notify(唤醒在该对象上等待的某个线程)、notifyAll</code></pre></li><li><p>反射</p><pre><code>        在**运行状态**中，对于任意一个类，都能够知道这个类的所有属性和方法        getMethod  invoke        **反射应用在哪些地方？**        1. JDBC数据库连接  1. 加载类驱动程序 2. 通过drivermanager类进行连接，输入参数  3. 通过connection接口接收连接        2. spring通过xml配置bean的过程 1. 将xml配置文件存入内存中 2. 调用java类进行解析，得到对应实体类字节码字符串及相关属性信息 3. 通过class.forname以这个字符串为参数生成class对象， 4. 动态配置</code></pre></li><li><p>异常</p><pre><code>        exception(可以捕获的异常)和error（无法捕获）</code></pre></li><li><p>NIO：非阻塞同步，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。相比于BIO一个连接占用一个线程，NIO是一个请求占用一个线程，它中的线程可以处理多个连接请求</p></li><li><p>hashcode与equals</p><p>   两个对象==相等，则其hashcode一定相等，反之不一定成立。</p><pre><code> 两个对象equals相等，则其hashcode一定相等，反之不一定成立。 其实这个重写自己的hashCode方法并没有什么绝对正确的答案，但是我们的目标是：不相等的对象尽可能有不同的hashCode，而且必须满足的一个通用约定是：**相等的对象应该具有相同的hashCode**。 **如果两个对象的hashcode相等，那么这两个对象可能是不同的对象吗？** 可能是两个完全不同，没有任何关系的对象。因为hashcode的本质上是一个整数，这个整数默认情况下由内存地址计算而来，怎么计算？假设hashcode的取值范围是0-10，假设 散列算法是 除10 取余【当然这只是假设，具体算法可以去看源码，但是大致效果应该是差不多，都是把可能相当大的一个数字 收敛到一个 小的区间 方便使用】，那么 对象A内存地址假设为 101，则对象A的hashcode为1， 对象B内存地址假设为201 ，则对象B的hashcode为1.AB两个对象地址不同 是 不同的对象，但是他们的hashcode还是相同的。</code></pre></li><li><p>Map遍历方式</p><pre><code>  **第一种方法：使用for循环的Entry遍历**  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  **第二种方法：使用for循环，按需遍历**  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key:map.keySet())</span><br><span class="line"><span class="keyword">for</span>(Integer value:map.values())</span><br></pre></td></tr></table></figure>  **第三种方法：使用Iterator遍历**  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; it=map.entrySet().iterator()</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     Map.Entry&lt;String, Integer&gt; entry = it.next();</span><br><span class="line">     System.out.println(<span class="string">&quot;Key = &quot;</span> + entry.getKey() + <span class="string">&quot;, Value = &quot;</span> + entry.getValue());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>  **第四种方法：先遍历键，然后通过键找值**  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">     Integer value = map.get(key);</span><br><span class="line">     System.out.println(<span class="string">&quot;Key = &quot;</span> + key + <span class="string">&quot;, Value = &quot;</span> + value);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><pre><code>​      </code></pre><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><p><strong>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</strong> </p><p>最好用这个方法创建线程池，否则可能会造成资源耗尽</p><ul><li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li></ul><p>Executor: 1. 任务（需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>） 2. 任务的执行(<code>Executor</code>)  3. 异步计算的结果(<code>Future</code>) (任务返回结果)</p><ol><li><p>线程池有哪些参数（7个）？</p><p>corePoolSize: 核心线程数量（最小可以同时运行的线程数量），默认情况下，线程池的线程数量为0，只有任务来时，才会创建线程，<strong>当线程池中的线程数量达到corePoolSize</strong>，就会把达到的任务放到缓存队列当中。</p><p>maximumPoolSize: 线程池最大线程数量。非核心线程数量（空闲线程）=maximumPoolSize-corePoolSize（队列线程数）</p><p>keepAliveTime: <strong>空闲的线程保留时间</strong>。意思是线程被用过之后，一定时间没有再用后，就会自动放回线程池。</p><p>unit :keepAliveTime的单位</p><p>workingQueue: <strong>阻塞队列</strong>（不是执行队列！）。 <strong>用来存放被提交但是尚未被执行的任务</strong>。ArrayBlockingQueue、<br>LinkedBlockingQueue、SynchronousQueue可选。</p><p>defaultHandler ：饱和策略。队列已满，而且任务量大于最大线程的异常处理策略。。ThreadPoolExecutor类中一共有4种饱和策略。通过实现RejectedExecutionHandler接口。</p><ul><li>AbortPolicy ： 线程任务丢弃报错。默认饱和策略。</li><li>DiscardPolicy ： 线程任务直接丢弃不报错。</li><li>DiscardOldestPolicy ： 将workQueue<strong>队首任务丢弃</strong>，将最新线程任务重新加入队列执行。</li><li>CallerRunsPolicy ：线程池之外的线程直接调用run方法执行。</li></ul><p>ThreadFactory ：线程工厂。executor创建新线程会用到</p></li><li><p>为什么要用线程池？</p><ul><li><strong>降低资源消耗</strong>，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>， 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul></li><li><p>线程池工作原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//任务队列</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">   </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">     <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">     <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">     <span class="comment">// 1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span></span><br><span class="line">     <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">         <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         c = ctl.get();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 2.如果当前之行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">     <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">     <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">         <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">         <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">         <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             reject(command);</span><br><span class="line">             <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">             addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">     <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">         reject(command);</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/04/GIEQMegNJ2BuyxY.png" alt="图解线程池实现原理"></p></li><li><p>有哪几种线程池，底层是怎么实现的？</p><p>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。工作线程的创建数量几乎没有限制<br>newFixedThreadPool ：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>newScheduledThreadPool： 创建一个定长线程池，支持定时及周期性任务执行。<br>newSingleThreadExecutor ：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，<strong>保证所有任务按照指定顺序</strong>(FIFO, LIFO, 优先级)执行。</p><p>有哪几种阻塞队列？</p><p>无界队列（LinkedBlockingQueue），有界队列（ArrayBlockingQueue）</p><p><strong>如何合理配置线程池参数？</strong></p><ol><li><p>首先分析线程池处理的程序是CPU密集型（I/O在很短的时间就可以完成，而CPU还有许多运算要处理,只有在真正的多核CPU才可能得到加速）还是IO密集型（CPU性能相对硬盘、内存要好很多，任务需要大量的IO，即大量的阻塞。）？</p><p>CPU密集型：corePoolSize = CPU核数 + 1<br>IO密集型：corePoolSize = CPU核数 * 2</p></li><li><p>阻塞队列：无界队列不适合qps较高的场景，容易造成OOM。有界队列可以减少内存消耗，但会降低吞吐量</p></li></ol></li></ol><ol><li><p><strong>如何实现线程安全</strong>？</p><ol><li><p>阻塞（互斥）同步，一种悲观锁，认为只有不加锁，一定会出现问题</p><p>一个线程进入监视器（可以认为是一个只允许一个线程进入的盒子），其他线程必须等待，直到那个线程退出监视器为止。最常见的synchronized</p><p><strong>synchronized底层原理</strong></p><p>synchronized 同步代码块的实现是通过 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。当执行 monitorenter 指令时，<strong>线程试图获取锁</strong>也就是获取 <strong>monitor</strong>(monitor对象存在于<strong>每个Java对象的对象头中</strong>，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。</p><p><strong>其内部包含一个计数器，当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</strong></p></li><li><p>非阻塞同步，一种乐观锁</p><p>使用锁会有性能损耗</p><p><strong>先进行操作，如果没有其他线程争用共享数据，那么操作就成功了，如果共享数据有争用，就采取补偿措施（不断地重试）。</strong></p><p><strong>CAS</strong>是实现非阻塞同步的计算机指令，是一种<strong>硬件对并发的支持</strong>。它有三个操作数：内存位置，旧的预期值，要修改的更新值 ，在执行CAS操作时，当且仅当内存地址的值符合旧的预期值的时候，才会用新值来更新内存地址的值，否则就不执行更新。</p><p>例子：一个线程从主内存中得到num值，并对num进行操作，写入值的时候，线程会把第一次取到的num值和主内存中num值进行比较，如果相等，就会将改变后的num写入主内存，如果不相等，则一直循环对比，知道成功为止。</p><p>jdk1.5中java.util.concurrent.  AtomicInteger类的compareAndSet通过原子操作实现了CAS操作，最底层基于汇编语言实现。</p><pre><code> 使用方法：使用JUC包下的整数原子类（AtomicInteger）的decompareAndSet（）和getAndIncrement（）方法</code></pre><p>  缺点 ：<strong>ABA 问题</strong> ，如何解决？</p><p>使用<strong>版本号方法</strong>来解决，使用<strong>AtomicStampedReference</strong>对象代替AtomicInteger对象，其内部维护了初始值和初始版本号，<strong>当该对象设置值时，必须对象值和状态戳都满足期望值</strong>，写入才会成功</p></li></ol></li></ol><ol><li><p>无同步方案</p><p>线程本地存储：将共享数据的可见范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题。</p><p><strong>访问threadlocal变量的每个线程都有这个变量的本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</strong></p><p>经常使用的就是ThreadLocal类</p><p>ThreadLocal类 最常见的ThreadLocal使用场景为 用来解决数据库连接、Session管理等。</p><ul><li>Thread类有一个类型为ThreadLocal.ThreadLocalMap的<strong>成员变量</strong>threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。</li><li><strong>ThreadLocalMap</strong>内部维护着<strong>Entry数组</strong>，每个Entry代表一个完整的对象，key是ThreadLocal本身，<strong>value是ThreadLocal的泛型值。（项目中的User对象）</strong></li><li>每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li></ul><p><strong>内存泄漏问题：</strong></p><p>threadlocal本身引用类型是弱引用（只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。），而threadlocalmap的生命周期和thread是一样的，所以可能造成key这个threadlocal本身虽然被回收了，但是value还在，就造成了…。</p></li></ol><ol><li><p>Synchronized和Reentrantlock的区别</p><p><strong>1.两者都是可重入锁</strong></p><p>可重入锁：重入锁，也叫做递归锁，可重入锁指的是在<strong>一个线程中可以多次获取同一把锁</strong>，比如： 一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而<strong>无需重新获得锁</strong>， 两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</strong></p><ul><li>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的</li><li>ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）</li></ul><p><strong>3.ReentrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知</strong>（锁可以绑定多个条件）</p><ul><li>等待可中断.通过lock.lockInterruptibly()来实现这个机制。也就是说<strong>正在等待的线程可以选择放弃等待，改为处理其他事情。</strong></li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是<strong>先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 <strong>ReentrantLock类的ReentrantLock(boolean fair)构造方法</strong>来制定是否是公平的。</li><li>ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，<strong>用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong></li></ul><p><strong>4.使用选择</strong></p><ul><li>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。</li><li>synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放</li></ul></li><li><p>synchronized 和 Lock 有什么区别？</p><ul><li>synchronized 可以给<strong>类. 方法. 代码块</strong>加锁；而 <strong>lock</strong> 只能给<strong>代码块</strong>加锁。</li><li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 <strong>lock 需要自己加锁和释放锁</strong>，如果使用不当没有 unLock()去释放锁就会造成死锁。</li><li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li></ul></li></ol><ol><li><p>自己设计线程池要考虑哪些问题</p><p>并发量、任务执行时间——&gt;核心线程数、最大线程数、阻塞队列、饱和策略</p></li><li><p>Java中有哪些锁？</p><p>1、<strong>悲观锁和乐观锁</strong><br>悲观锁：当前线程去操作数据的时候，总是认为别的线程会去修改数据，所以每次操作数据的时候都会上锁，别的线程去操作数据的时候就会阻塞，比如synchronized；</p><p>乐观锁：当前线程每次去操作数据的时候<strong>都认为别人不会修改，更新的时候会判断别人是否会去更新数据，通过版本来判断，如果数据被修改了就拒绝更新</strong>，例如cas是乐观锁，但是严格来说并不是锁，通过原子性来保证数据的同步，例如数据库的乐观锁，通过版本控制来实现，cas不会保证线程同步，乐观的认为在数据更新期间没有其他线程影响</p><p>总结：悲观锁适合<strong>写操作多</strong>的场景，乐观锁适合<strong>读操作多</strong>的场景，乐观锁的吞吐量会比悲观锁高</p><p>2、<strong>公平锁和非公平锁</strong><br>公平锁：有多个线程按照申请锁的顺序来获取锁，就是说，如果一个线程组里面，能够保证每个线程都能拿到锁，例如：ReentrantLock（使用的同步队列FIFO）</p><p>非公平锁：获取锁的方式是随机的，保证不了每个线程都能拿到锁，会存在有的线程饿死，一直拿不到锁，例如：synchronized，ReentrantLock</p><p>总结：非公平锁性能高于公平锁，更能重复利用CPU的时间</p><p>3、<strong>可重入锁和不可重入锁</strong><br>可重入锁：也叫递归锁，在外层使用锁之后，在内层仍然可以使用，并且不会产生死锁</p><p>不可重入锁：在当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞</p><p>总结：可重入锁能一定程度的避免死锁，例如：synchronized，ReentrantLock</p><p>4、<strong>自旋锁</strong><br>自旋锁：<strong>一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待</strong>，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环，任何时刻最多只能有一个执行单元获得锁</p><p>总结：不会发生线程状态的切换，一直处于用户态，减少了线程上下文切换的消耗，缺点是循环会消耗CPU</p><p>5、<strong>共享锁和独享锁</strong><br>共享锁：也叫读锁，可以查看数据，但是不能修改和删除的一种数据锁，加锁后其他的用户可以并发读取，但不能修改、增加、删除数据，该锁可被多个线程持有，用于资源数据共享</p><p>独享锁：也叫排它锁、写锁、独占锁、独享锁，该锁每一次只能被一个线程所持有，加锁后任何线程试图再次加锁都会被阻塞，直到当前线程解锁。例如：线程A对data加上排它锁后，则其他线程不能再对data加任何类型的锁，获得互斥锁的线程既能读数据又能修改数据</p></li><li><p>线程状态                      </p><p>新建、就绪、运行、阻塞、死亡</p><p><strong>就绪状态是进入到运行状态的唯一入口</strong>，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p></li></ol><p>​        <strong>阻塞状态（Blocked）</strong>：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同</p><p>​        1.<strong>等待阻塞</strong>：运行状态中的线程执行<strong>wait()方法</strong>，使本线程进入到等待阻塞状态，JVM 会将线程放入等待序列（waitting queue）；</p><p>​        2.<strong>同步阻塞</strong> — 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态，若该 <strong>同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中</strong>；</p><p>​        3.其他阻塞 — 通过调用线程的<strong>sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。</strong>当<strong>sleep()状态超时. join()等待线程终止或者超时</strong>. 或者I/O处理完毕时，线程重新转入就绪状态。</p><ol><li><p>sleep和wait方法的区别（thread类的yield方法也能暂停线程）</p><ul><li><p>wait方法是Object的方法，需要与synchronized关键字一起使用，sleep是线程中的方法</p></li><li><p>sleep阻塞期间不释放锁，wait释放</p></li><li>sleep时间到了重新进入就绪，wait需要另一个线程调用notify或notifyall唤醒，重新占用互斥锁后进入就绪状态</li><li>sleep通常用于暂停线程，wait用于线程间通信（join底层使用wait）</li></ul></li><li><p>volatile</p><p>原子性是指一个线程的操作是不能被其他线程打断，同一时间只有一个线程对一个变量进行操作。</p><p>可见性是指某个线程修改了某一个共享变量的值，而其他线程是否可以看见该共享变量修改后的值。</p><p>有序性：按照代码顺序执行</p><p>实现了可见性（当volatile变量被修改，新值对所有线程会立即更新。或者理解为多线程环境下使用volatile修饰的变量的值一定是最新的。）、有序性，无法保证原子性，只能保证单次读写的原子性。</p><p>原理：</p><p>JVM底层使用了<strong>内存屏障的操作禁止了指令重排</strong>保证了有序性，而且使本线程工作内存中的volatile变量值立即写入到主内存中，并使其他工作内存中volatile变量无效化，这样其他线程必须重新从主内存中读取变量值保证了可见性。</p></li><li><p>synchronized和volatile的区别</p><ol><li>volatile 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile <strong>仅能使用在变量级别</strong>；synchronized 则可以使用在 <strong>变量. 方法. 和类级别的</strong></li><li>volatile 仅能实现变量的修改可见性，<strong>不能保证原子性</strong>；而synchronized 则可以 <strong>保证变量的修改可见性和原子性</strong></li><li>volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。</li><li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li></ol></li><li><p>介绍下原子类</p><p>Atomic-Integer、boolean、long、atomicstampedReference</p><p>AtomicInteger 类主要利用 <strong>CAS</strong>和 <strong>volatile</strong> 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p></li><li><p>线程通信的方式：1. wait、notify  2. join  3. volatile共享内存</p></li><li><p>进程通信方法: 1. 消息队列 2. socket（网络）</p></li><li><p>synchronized锁<strong>类</strong>和<strong>this</strong>有什么区别？</p><ol><li><p>当加了类锁的方法或代码块处于访问状态时，<strong>该类</strong>的其他加了类锁的方法或代码块将拒绝其他线程的访问，但是<strong>其他线程可以访问该类的普通方法或者未被占用的this锁或object锁</strong>。只有当该方法或代码块执行完毕，其他线程才能访问该类的类锁（注意是方法执行完毕，而不是线程执行完毕。）</p><p><img src="https://img-blog.csdnimg.cn/20210501165343705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDk1NjA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>当加了this锁（对象锁）处于访问状态时，那么<strong>该对象的其他this锁（对象锁）将拒绝其他线程访问</strong>，但是它的普通方法或者加了<strong>类锁、object锁只要不被其他线程占有，其他线程依然可以进行访问</strong>。只有当该方法或代码块执行完毕，其他线程才能访问该对象的对象锁（注意是<strong>对象锁，同一个类的不同对象，他们之间的对象锁是没有任何关系的，只有处于同一个对象，他们的对象锁才会发生阻塞。</strong>）</p><p><img src="https://img-blog.csdnimg.cn/20210501171140383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMDk1NjA3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>讲讲你对AQS的理解？</p><p>​    AQS是一个并发包的基础组件，内部实现的关键是：<strong>先进先出的线程等待队列</strong>、代表<strong>加锁状态</strong>的state变量、表示<strong>当前占锁的线程</strong>的变量，拥有两种线程模式独占模式和共享模式。在LOCK包中的相关锁(常用的有ReentrantLock、 ReadWriteLock)都是<strong>基于AQS来构建</strong>，一般我们叫<strong>AQS为同步器</strong>。</p></li><li><p>Reentrant(可重入)Lock原理</p><p>reentrant底层是基于AQS组件实现的，当reentrantloc调用lock方法进行加锁的过程，就是将state状态变量利用cas操作从0变1的过程，一旦加锁成功，那么它就可以设置当前加锁线程是它自己，说它是可重入锁的原因就是它每次加锁的时候都会判断当前加锁线程是否是他自己，是就可以对state进行累加。</p><p>线程2进行加锁的时候，先看是否能将state值从0变1，若失败，查看当前加锁线程是否是它自己，若不是就放入等待队列中，等锁释放后（state递减，加锁线程变量设置为null）将其唤醒</p></li></ol></li></ol><p>​        </p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM内存模型：</p><p>方法区：存放已加载的类信息、常量、静态变量等。jdk1.8中不存在方法区，被<strong>元空间</strong>替代。原方法区分为两部分：加载的类信息放在元空间中，运行时常量池保存在堆中</p><p>堆：java堆是所有线程共享的一块内存，<strong>几乎所有对象的实例和数组都要在堆上分配内存</strong>，因此该区域经常发生垃圾回收的操作；</p><p>程序计数器：用于记录当前虚拟机<strong>正在执行</strong>的<strong>线程指令地址</strong></p><p>本地方法栈：保存的是<strong>本地方法</strong>的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的<strong>动态链接并直接调用该方法</strong>；</p><p>虚拟机栈：线程私有，<strong>每个方法</strong>执行的时候都会创建一个<strong>栈帧</strong>，用于存储<strong>局部变量表</strong>、<strong>操作数</strong>、动态链接和<strong>方法返回</strong>等信息</p><ol><li><p>类加载过程</p><pre><code>  加载——链接——初始化  加载：1. 通过类的全限定性类名获取该类的二进制流； 2、将该二进制流的静态存储结构转为方法区的运行时数据结构； 3、在堆中为该类生成一个class对象；  验证：验证该class文件中的字节流信息复合虚拟机的要求，不会威胁到jvm的安全；  准备：为class对象的静态变量分配内存，初始化其初始值；  解析：该阶段主要完成符号引用转化成直接引用；  初始化：到了初始化阶段，才开始执行类中定义的java代码；初始化阶段是调用类构造器的过程；</code></pre></li><li><p>双亲委派机制</p><p>   类加载器：<strong>启动类加载器</strong>、扩展类加载器、系统类加载器、自定义类加载器</p><p>   当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；</p><p>   <strong>那怎么打破双亲委派模型</strong>？</p><p>   自定义类加载器，继承ClassLoader类，重写<strong>loadClass方法</strong>和<strong>findClass</strong>方法。</p><p>   打破类加载器的例子：</p><p>   Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。</p></li><li><p>分代垃圾回收</p><p>   原因：不同对象的生命周期是不一样的</p><p>   堆内存划分为新生代和老年代，新生代采用复制算法进行垃圾回收，分为伊甸区和幸存者from、to区。</p><p>   <strong>第一次minor GC</strong>, 伊甸区满了之后利用可达性分析算法将存活对象放到幸存者to区中，同时交换from、to, 幸存区寿命+1，伊甸区垃圾回收</p><p>   第二次minor GC 与第一次类似，也会回收幸存区中垃圾，当from区中寿命超过一定阈值，晋升到老年代</p><p>   Full GC  如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p></li><li><p>内存溢出和内存泄漏？。</p><p>   内存溢出：程序申请内存时，没有足够的内存空间供其使用</p><p>   内存泄漏：指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费</p></li><li><p>内存泄漏举个例子？有没有什么方法避免写出这种情况？threadlocal </p></li><li><p>CMS垃圾回收器</p><p>   <strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p>   <strong>并发标记</strong>：根据上一步的结果，继续向下标识所有关联的对象，直到这条链上的最尽头。是进行GC Roots Tracing 的过程，找出存活对象且用户线程可<strong>并发执行</strong>(不需要STW)</p><p>   <strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在<strong>Stop The World</strong>问题 （较慢）</p><p>   <strong>并发清除</strong>：对标记的对象进行清除回收</p></li><li><p>volatile原理</p><p>   volatile底层使用了一个内存屏障的操作，它可以使本线程工作内存中的volatile变量立即写入到主内存中，并且使其他线程共享的该volatile变量无效化，这样其他线程必须重新从主内存中读取变量值。</p></li><li><p><strong>根对象</strong>(GC ROOT)：肯定不能被当成垃圾被回收的对象</p><ul><li><strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong></li><li>方法区中类静态属性引用的对象</li><li>方法区中<strong>常量</strong>引用的对象</li><li>本地方法栈中JNI引用的对象</li></ul></li><li><p>如何手动去调用GC？</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line"><span class="comment">// 或者下面，两者等价</span></span><br><span class="line">Runtime.getRuntime().gc();</span><br></pre></td></tr></table></figure></li></ol><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol><li><p>osi七层模型及各层作用</p><p>物理层：实现相邻节点间<strong>比特流</strong>的透明传输，尽可能屏蔽传输介质和通信手段的差异。</p><p>数据链路层：数据链路层通常简称为链路层。将网络层传下来的<strong>IP数据包</strong>组装成<strong>帧</strong>，并再相邻节点的链路上<strong>传送帧</strong>。（交换机，mac表）</p><p>网络层：选择合适的<strong>路由和交换结点</strong>，确保数据及时传送。主要包括IP协议。</p><p>传输层：向主机<strong>进程</strong>提供通用的数据传输服务。tcp、udp</p><p>会话层: 负责在网络中的两节点之间建立、维持和终止<strong>通信</strong></p><p>表示层: 主要负责数据格式的转换，如<strong>加密解密、转换翻译、压缩解压缩</strong>等</p><p>应用层: 为<strong>应用程序提供交互服务</strong>。在互联网中的应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等。</p></li><li><p>TCP拥塞控制的四种算法：</p><p>围绕着拥塞窗口来说</p><ul><li><strong>慢开始</strong> (slow-start)：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。</li><li><strong>拥塞避免</strong> (congestion avoidance)：每经过<strong>一个往返时间RTT</strong>就把发送方的<strong>拥塞窗口cwnd加1而不是加倍</strong>。这样拥塞窗口按线性规律缓慢增长。</li><li><strong>快速重传</strong> (fast retransmit)：比如<strong>接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li><li><strong>快速恢复</strong> (fast recovery)：主要是配合快重传。<strong>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半</strong>（为了预防网络发生拥塞），但接下来并不执行慢开始算法</li></ul></li><li><p>浏览器输入url到显示页面的简要流程</p><ol><li><p>域名解析（域名 <a href="http://www.baidu.com/">www.baidu.com </a>变为 ip 地址）。</p><p><strong>浏览器搜索自己的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索<strong>操作系统的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索操作系统的<strong>hosts文件</strong>（维护一张域名与IP的对应表）。</p><p>若都没有，则找 tcp/ip 参数中设置的首选 dns 服务器，即<strong>本地 dns 服务器</strong>（递归查询），<strong>本地域名服务器查询自己的dns缓存</strong>，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。</p></li><li><p>发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 <strong>80</strong> 端口发起 tcp 的连接。</p></li><li><p>建立 tcp 连接后发起 http 请求。</p></li><li><p>服务器响应 http 请求，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。</p></li><li><p>浏览器解析 html 代码，并请求 html 中的资源。</p></li><li><p>浏览器对页面进行渲染，并呈现给用户。</p></li></ol></li><li><p>TCP三次握手、四次挥手</p><ul><li>第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN=1），同时选择一个随机数 seq = x 作为<strong>初始序列号</strong>，并进入SYN_SENT状态，等待服务器确认。</li><li>第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN=1，ACK=1），确认号为 ack = x + 1，同时选择一个随机数 seq = y 作为<strong>初始序列号</strong>，此时服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK=1），确认号为 ack = y + 1，序列号为 seq = x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li></ul></li></ol><p>   ​    </p><ul><li><p>第一次挥手：客户端向服务端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认。</p><ul><li>序列号 seq = u，即客户端上次发送的报文的最后一个字节的序号 + 1</li><li>确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1</li></ul></li><li><p>第二次挥手：服务端收到连接释放报文后，立即发出<strong>确认报文</strong>（ACK=1），（确认序号为收到的序号加 1 。）序列号 seq = k，确认号 ack = u + 1。</p><p>这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。</p></li><li><p>第三次挥手：服务端向客户端发送连接释放报文（FIN=1，ACK=1），主动关闭连接，同时等待 A 的确认。</p><ul><li>序列号 seq = w，即服务端上次发送的报文的最后一个字节的序号 + 1。</li><li>确认号 ack = u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据</li></ul></li><li><p>第四次挥手：客户端收到服务端的连接释放报文后，立即发出<strong>确认报文</strong>（ACK=1），序列号 seq = u + 1，确认号为 ack = w + 1。</p><p>此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p><p><strong>为什么需要三次握手，而不是两次？</strong></p><p>在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，<strong>由于网络原因造成 A 暂时无法到达服务器</strong>，服务器接收不到请求报文段就不会返回确认报文段。</p><p>客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。</p><p>此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致<strong>服务器长时间单方面等待，造成资源浪费。</strong></p><p><strong>为什么需要三次握手，而不是四次？</strong></p><p>因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p><ul><li>第一次握手：服务端确认“自己收、客户端发”报文功能正常。</li><li>第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。</li><li>第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。</li></ul></li></ul><ol><li><p>http和https的区别</p><ul><li>端口：80 443</li><li>安全性：https有加密机制，安全性更高</li><li>https需要证书，http不需要</li><li>http运行在tcp协议之上，https在ssl协议之上</li></ul></li><li><p>状态码</p><p>3：重定向 4：客户端错误 5：服务器端错误</p><p>403：服务器收到请求，但是拒绝提供服务。</p><p>301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示<strong>旧地址A的资源还在</strong>（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会<strong>抓取新的内容而保存旧的网址</strong>。</p></li><li><p>get和post的区别</p><ul><li>GET使用URL或Cookie传参，而POST将数据放在BODY中”，这个是因为HTTP协议用法的约定。</li><li>GET方式提交的数据有<strong>长度限制</strong>，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</li><li>POST比GET<strong>安全</strong>，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</li></ul></li><li><p>请求报文格式</p><ol><li>请求行（<strong>请求方法+URI协议+版本</strong>）</li><li>请求头部</li><li>空行</li><li>请求主体</li></ol></li><li><p>cookie和session</p><p>Cookie（也叫 Web Cookie或浏览器 Cookie）是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p><p>Session 代表着<strong>服务器和客户端一次会话的过程。</strong> 当<strong>客户端关闭会话，或者 Session 超时失效</strong>时会话结束。</p></li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ol><li><p>索引匹配原则</p><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>、<strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p></li><li><p>索引失效情况？</p><ol><li>有or</li><li>范围查询，或like查询是以%开头</li><li>索引列参与计算</li><li>违背最左匹配原则</li></ol></li><li><p>数据误删除操作之后能不能回滚</p><p>不能，能恢复binlog记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。</p></li><li><p>写sql语句：可以灵活使用 order by count() limit 1等方法</p></li><li><p>怎么做分页？limit 偏移量 数目</p></li><li><p>获取当前时间？select now()</p></li><li><p>Mysql的左连接和右连接有什么区别？左连接后的检索结果是显示tbl1的所有数据和tbl2中满足where 条件的数据。右连接类似（横向）</p><p>  1、left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。<br>   　　<br>   　 2、right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。<br>   　<br>   　 3、inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。</p></li><li><p>索引类型？</p><p>主键索引（不能为null, 不能重复），普通索引、唯一索引（不能重复，可以为null）、复合索引等</p></li><li><p>介绍下事务</p><p>事务就是<strong>一组原子性的操作</strong>，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。</p></li><li><p>说下可重复读</p><p>  这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。<strong>读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。</strong></p></li><li><p>mysql是如何实现事务隔离的？</p><pre><code>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。MySQL 在可重复读级别解决了幻读问题，是通过**行锁**和**间隙锁**的组合 Next-Key 锁实现的。</code></pre></li><li><p>B+树特点</p><p>  能使B+树<strong>保持较低的高度</strong>，从而达到有效避免<strong>磁盘过于频繁的查找存取操作</strong>，从而有效提高查找效率，若是二叉树可能会退化成线性查找，导致高度过高（B+树的节点，即非叶子节点大小 = 页大小 读取一页需要一次IO）</p><pre><code>- 只有叶子节点存放key和data, 其他节点只存放key  B+树的优点：  由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。  搜索时间复杂度mlogN(m是每个节点有几个数据)</code></pre></li></ol><ol><li><p>聚簇索引和非聚簇索引</p><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是<strong>数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引</strong>（或聚集索引）（有且只有一个，是<strong>主键索引</strong>）”，而其余的索引都作为辅助索引，<strong>辅助索引的 data 域存储相应记录主键的值而不是地址</strong>，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要<strong>先取出主键的值，再走一遍主索引</strong>。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></li><li><p>索引失效的场景</p><ul><li>select *</li><li>索引列上有计算</li><li>不满足最左匹配原则</li><li>索引列用了函数</li><li>like %开头</li><li>or关键字</li></ul></li><li><p>B+树索引的优点</p><ol><li>B+树的非叶节点只包含键，而不包含真实数据，因此相同内存情况下<strong>每个节点存储的记录个数比B数多很多</strong>（即阶m更大），因此<strong>B+树的高度更低</strong>，<strong>访问时所需要的IO次数更少</strong></li><li>在B树中进行范围查询时，首先找到要查找的下限，然后对<strong>B树进行中序遍历</strong>，直到找到查找的上限；而B+树的范围查询，只需要对<strong>双向链表进行遍历即可</strong>。</li><li>B树的查询时间复杂度在<strong>1到树高之间</strong>(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。</li></ol></li><li><p>mysql分页优化(翻页过多时，查询性能急剧下降)</p><p>​        <strong>分页游标</strong>：当我们查询第二页的时候，把<strong>第一页的查询结果</strong>放到第二页的<strong>查询条件中</strong>。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select * from user </span><br><span class="line">where create_time&gt;<span class="string">&#x27;2022-07-03&#x27;</span> and id&gt;<span class="number">10</span> </span><br><span class="line">limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>​                    适用于没有跳转到指定页面需求的应用，如瀑布流新闻等。</p><p>​                <strong>避免回表查询</strong></p><p>​                使用inner join关联查询</p><ol><li><p>mysql的索引</p><p><strong>InnoDB 的 B+Tree 索引分为主索引（聚集索引）和辅助索引(非聚集索引)。一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树。</strong></p><p>InnoDB聚集索引的叶子节点存储<strong>行记录</strong>，因此， InnoDB必须要有，<strong>且只有一个聚集索引</strong>：</p><p>（1）如果表定义了PK，则PK就是<strong>聚集索引</strong>；</p><p>（2）如果表没有定义PK，则第一个not NULL unique列是聚集索引；</p><p>（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；</p><p>表中有四条记录：</p><p>　　1, shenjian, m, A</p><p>　　3, zhangsan, m, A</p><p>　　5, lisi, m, A</p><p>　　9, wangwu, f, B</p><p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220818150438243.png" alt="image-20220818150438243"></p><p>两个B+树索引分别如上图：</p><p>　　（1）id为PK，聚集索引，叶子节点存储行记录；</p><p>　　（2）name为KEY，普通索引，叶子节点存储PK值，即id；既然从普通索引无法直接定位行记录，那普通索引的查询过程是怎么样的呢？</p><p>通常情况下，需要扫码两遍索引树。</p></li></ol><pre><code>例如：select * from t where name=&#39;lisi&#39;;　是如何执行的呢？如粉红色路径，需要扫码两遍索引树：（1）先通过普通索引定位到主键值id=5；（2）在通过聚集索引定位到行记录； ![image-20220818150552992](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220818150552992.png)不宜使用过长的字段作为索引，可能导致相同内存情况下，高度变高，io次数变多这就是所谓的回表查询，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。18. **MySQL中如何解决幻读**    1. 使用串行化隔离级别，它是加表级锁，所以效率较低    2. 在快照读（普通select）下，采用 MVCC 机制解决幻读，读取的是快照中的数据。    3. 在当前读（update、delete）下，不仅对扫描到的行进行加锁，还对**行之间的间隙**进行加锁，这样就能杜绝新数据的插入和更新。这个其实就是记录锁 **Record Lock** 和间隙锁 **Gap Lock**，也被称为临键锁 **Next-Lock Key**。       临键锁只在**可重复读**也就是 InnoDB 的默认隔离级别下生效。也可以采用更高的可串行化隔离级别，所有的操作都是串行执行的，可以直接杜绝幻读问    SELECT查询分为快照读和实时读，快照读通过MVCC（并发多版本控制）来解决幻读问题，实时读通过行锁来解决幻读问题。19. MVCC实现原理    隐藏字段：在InnoDB存储引擎中，对于每一条记录都会有隐藏字段，包括**ROWID，事务ID（最新一次被哪个事务修改），回滚指针**    ReadView： 当前数据的快照    在READ COMMITTED隔离级别下，一个事务执行过程中**每次执行SELECT操作都会生成一个ReadView**，ReadView本身就保证了事务不可以读取到未提交的事务做出的修改，也就避免了脏读现象    在REPETABLE READ隔离级别下，**一个事务执行过程中只有第一次执行SELECT操作时才会生成一个ReadView，之后的SELECT操作都是复用这个ReadView**，这也就避免了不可重复度和幻读    对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：    - ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。    - 事务 ID：记录最后一次修改该记录的事务 ID。    - 回滚指针：指向这条记录的上一个版本。    InnoDB 每一行数据都有一个隐藏的回滚指针，用于**指向该行修改前的最后一个历史版本**，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。    MVCC 作用于**读取已提交**和**可重复读（默认）**这两个隔离级别，这俩隔离级别下的**普通 select 操作就是快照读**, **读取快照中的数据，不需要进行加锁。**</code></pre><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ol><li><p>死锁的四个必要条件</p><ul><li>互斥条件：一个资源一次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li><li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺：当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源</li><li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li></ul></li><li><p>线程和进程的关系？</p><p>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上<strong>各进程是独立</strong>的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。<strong>线程执行开销小，但不利于资源的管理和保护</strong>；而进程正相反。</p></li><li><p>两个进程怎么通信？</p><ol><li>消息队列</li><li>套接字： 此方法主要用于在客户端和服务器之间通过网络进行通信。</li><li><strong>共享内存</strong>：使得多个进程可以访问同一块内存空间，<strong>不同进程可以及时看到对方进程中对共享内存中数据的更新</strong>。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</li></ol></li><li><p>线程同步的方式</p><ol><li>临界区：<strong>一段独占对某些共享资源访问的代码</strong>，在任意时刻只允许一个线程对共享资源进行访问。</li><li>互斥锁（reentranklock）：<strong>采用互斥对象机制</strong>。 <strong>只有拥有互斥对象的线程才有访问公共资源的权限</strong>，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。<strong>和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效</strong>率。</li><li>事件：事件机制，则<strong>允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。</strong></li></ol></li></ol><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Autowired注解自动注入原理"><a href="#Autowired注解自动注入原理" class="headerlink" title="Autowired注解自动注入原理"></a>Autowired注解自动注入原理</h3><h3 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h3><p>简答版：</p><p>启动类的@SpringBootApplication注解由@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan三个注解组成，三个注解共同完成自动装配；</p><p>@SpringBootConfiguration 注解标记启动类为配置类<br>@ComponentScan 注解实现启动时扫描启动类所在的包以及子包下所有标记为bean的类由IOC容器注册为bean<br>@EnableAutoConfiguration通过 <strong>@Import 注解</strong>导入 <strong>AutoConfigurationImportSelector</strong>类，然后通过AutoConfigurationImportSelector 类的 <strong>selectImports</strong> 方法去读取spring.factories中的自动配置类的类全名，并按照一定的规则（@ConditionalOnxxx注解）过滤掉不符合要求的组件的类全名，将剩余读取到的各个组件的类全名集合返回给IOC容器并将这些组件注册为bean</p><p>原理：</p><p><strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p><p>@SpringBootApplication:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//允许在上下文中注册额外的 bean 或导入其他配置类</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">//启用 SpringBoot 的自动配置机制</span></span><br><span class="line">AutoConfigurationImportSelector类 <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br><span class="line">        selectImports方法：获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。</span><br><span class="line"><span class="meta">@ComponentScan</span> <span class="comment">//扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] NO_IMPORTS = <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// &lt;1&gt;.判断自动装配开关是否打开</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//&lt;2&gt;.获取所有需要装配的bean</span></span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>Spring两大特性</p><ul><li><p>IOC（控制反转）: 把对象的创建、销毁的权利交给容器框架,由容器来管理对象的生命周期；  ioc包括<a href="https://so.csdn.net/so/search?q=依赖注入&amp;spm=1001.2101.3001.7020">依赖注入</a>(DI,核心) 和 依赖查找；DI:依赖注入 就是在spring实例化对象的时候,由容器来设置这些对象的属性值，也就是组件之间依赖关系由容器在运行期决定。</p></li><li><p>AOP（面向切面编程）：采用<strong>横向抽取</strong>机制,能够将那些与业务无关，却为业务模块所共同调用的<strong>逻辑或责任</strong>（例如事务处理、日志管理、权限控制等）封装起来。便于减少重复代码，降低模块间的耦合度。</p><p>Spring AOP 就是基于<strong>动态代理</strong>的，如果要代理的对象，实现了某个<strong>接口</strong>，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p></li><li><p>​    通知(Advice):aop在切点上执行的增强处理。<br>​    切点(Pointcut):就是带有通知的连接点。<br>​    切面(Aspect):通常上就是一个类,里面定义了 通知和切点。<br>​    AOP=通知+切点</p><ul><li>应用场景：日志记录、事务管理、权限验证、性能检测</li></ul></li></ul></li><li><p><strong>Spring bean的生命周期</strong></p><p>实例化：实例化一个bean对象</p><p>属性赋值：为bean设置相关属性和依赖</p><p>初始化</p><p>销毁</p><p><strong>实例化阶段</strong><br>1.spring读取xml配置文件,容器就会调用doCreateBean方法进行实例化,底层是通过工厂+反射完成的创建<br>2.bean实例化后,进行bean对象属性填充<br>3.执行Aware接口的方法,spring会检查bean对象是否实现了Aware接口,通过Aware接口我们可以拿到spring为我们提供的一些资源,比如实现了BeanNameAware接口获取beanName,实现BeanFactoryAware接口可以获取工厂对象<br>.<br><strong>初始化阶段</strong><br>1.检查是否实现了BeanPostProcessor接口执行postProcessBeforeInitialization()对bean进行前置初始化<br>2.检查是否实现了InitializingBean接口如果实现了就调用afterPropertiesSet方法完成初始化 使用场景比如我们想在对象创建完之后调用其他bean对象的方法可以在afterPropertiesSet方法完成调用,<br>如果你是在构造方法里进行调用其他bean的对象或者在普通代码块调用都会出现空指针异常,这是因为你调用bean对象没有完成实例化,afterPropertiesSet方法是在所有bean对象完成实例化后进行执行的<br>3.检查是否实现了BeanPostProcessor后置处理接口执行ProcessAfterInitialization()方法,可以获取这个bean对象添加一些默认值的属性,甚至可以返回一个代理对象<br>.<br><strong>销毁阶段</strong><br>4.检查bean对象是否实现DisposbleBean接口调用destroy方法</p></li><li><p>spring mvc是怎么从url解析到具体的方法的？</p><ol><li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li><li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li><li><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol></li><li><p>mybatis传递参数？</p><p>传表名用${ }，传参用#{}，#相当于对数据 加上 单引号，可以防止sql注入，$相当于直接显示数据，</p></li><li><p>mybatis如何自增，设置主键</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;</span><br></pre></td></tr></table></figure></li></ol><p>​        优缺点？</p><ul><li>自增，趋势自增，可作为聚集索引，提升查询效率</li><li>节省磁盘空间。500W数据，UUID占5.4G,自增ID占2.5G.</li><li>查询，写入效率高：查询略优。写入效率自增ID是UUID的四倍。</li></ul><p>​        缺点：</p><ul><li>导入旧数据时，可能会ID重复，导致导入失败。</li><li>分布式架构，多个Mysql实例可能会导致ID重复。</li></ul><ol><li><p>IOC创建对象用的哪几种设计模式</p><ol><li><p>工厂模式：将将创建对象的责任转移到工厂类。</p></li><li><p>单例模式，<strong>Spring中bean的默认作用域就是singleton(单例)的</strong>  @Scope(value = “singleton”) scpoe: singleton、prototype、request、session、global-session  </p><p>Spring通过<code>ConcurrentHashMap</code>实现单例注册表的特殊方式实现单例模式。检查map中是否存在以beanname为key的对象，如果不存在，则添加到concurrenthashmap中（使用了synchronized锁住了对象），否则直接返回</p></li><li><p>策略模式：一个类的行为或其算法可以在运行时更改。Spring框架提供了一个InstantiationStrategy实例化策略接口，当实例化bean对象，在autowire方法中，其会获取当前factory中的InstantiationStrategy接口实现类，并调用instantiate方法来完成实例化，此时，便可以根据factory中不同的实现类完成不同的实例化策略，从而提高可扩展性。</p></li></ol></li><li><p>restcontroller=responsebody+controller</p></li><li><p>AOP有哪些实现类？</p></li><li><p>bean的作用域</p><p>singleton: 仅创建一个bean实例，ioc每次返回的都是同一个实例</p><p>prototype: 可见创建多个实例，每次返回的都是一个新的实例</p><p>request :每次http请求都会创建一个新的bean</p><p>session: 仅用于http session,同一个session共享一个bean实例，不同session使用不同实例</p><p>global-session: 在spring5.x中已删除</p></li><li><p>@Autowired  @Resource</p><p>@Autowird默认的注入方式为byType，也就是根据类型匹配，当有多个实现时，则通过byName注入，也可以通过配合@Qualifier注解来显式指定name值，指明要使用哪个具体的实现类</p><p>@Autowired注解是Spring提供的，而@Resource注解是J2EE本身提供的<br>@Autowird注解默认通过byType方式注入，而@Resource注解默认通过byName方式注入<br>@Autowired注解注入的对象需要在IOC容器中存在，否则需要加上属性required=false，表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错</p></li><li><p>forward和redirect的区别</p><p>从<strong>url地址</strong>来说</p><p>forward：是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.</p><p>redirect:服务端根据逻辑,<strong>发送一个状态码</strong>,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p><p><strong>数据共享</strong>：</p><p>forward:转发页面和转发到的页面可以共享request里面的数据.<br>redirect:不能共享数据.</p><p>从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p><p><strong>运用地方</strong></p><p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.<br>redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p></li><li><p>spring依赖注入有哪几种方式</p><ul><li><p>构造器注入：<strong>构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖</strong>。</p><p>优点：<strong>对象初始化完成后便可获得可使用的对象</strong>；</p><p>缺点：<strong>当需要注入的对象很多时，构造器参数列表将会很长；不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;myStudent&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.bit.ba03.Student&quot;</span> &gt;</span><br><span class="line"> </span><br><span class="line">&lt;constructor-arg name=<span class="string">&quot;myage&quot;</span> value=<span class="string">&quot;20&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;constructor-arg name=<span class="string">&quot;mySchool&quot;</span> ref=<span class="string">&quot;myXueXiao&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;constructor-arg name=<span class="string">&quot;myname&quot;</span> value=<span class="string">&quot;周良&quot;</span>/&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>setter方法注入</p><p><strong>Setter方法注入是容器通过调用无参构造器或无参static工厂方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入</strong>；</p><p>优点：<strong>灵活。可以选择性地注入需要的对象</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">&quot;xx&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;yyy.Id&quot;</span>&gt;</span><br><span class="line"> </span><br><span class="line">&lt;property name=<span class="string">&quot;属性名字&quot;</span> value=<span class="string">&quot;此属性的值&quot;</span>/&gt;</span><br><span class="line"> </span><br><span class="line">一个property只能给一个属性赋值</span><br><span class="line"> </span><br><span class="line">&lt;property name=<span class="string">&quot;school&quot;</span> ref=<span class="string">&quot;mySchool&quot;</span> /&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ol><li><p>手写单例模式</p><ol><li><p>饿汉式(线程安全，类加载时就初始化实例，在线程访问单例对象之前，其就已经创建好了。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hunger</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Hunger instance = <span class="keyword">new</span> Hunger();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hunger</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hunger <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>懒汉式(线程不安全，实例对象在第一次被调用的时候才真正构建的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lazy instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双重校验锁（DCL）-针对懒汉式优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@title</span>: DCL双检锁/双重校验锁（DCL，即 double-checked locking）线程安全，效率高</span></span><br><span class="line"><span class="comment"> * 区别于懒汉的加锁</span></span><br><span class="line"><span class="comment"> * dcl只锁创建单例，不锁获取单例，如果已经创建好了则不会加锁</span></span><br><span class="line"><span class="comment"> * @<span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> sujiaying</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/7/29 12:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCL</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DCL instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCL</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCL <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DCL.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问：为什么要有第二个if？<br>因为如果没有第二个if的话，在当前A线程获得锁的线程后可能有其他如B线程也在等待进入这个Class锁，A线程获取锁后创建实例，然后释放锁，之后<strong>等待池中的B线程获得锁</strong>，然后就会产生创建两个对象的错误情况。</p><p>问：instance为什么需要采⽤ volatile 关键字修饰？<br>instance采⽤ volatile 关键字修饰也是很有必要的，在上述代码中有下面这一句代码<br>instance= new DCL();<br>其实是分为三步执⾏的：<br>1.为 instance 分配内存空间</p><ol><li>初始化 instance</li><li>将 instance指向分配的内存地址<br> 但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。<br> *（例如，线程A 执⾏了 1 和3，此时线程B调⽤ getInstance() 后发现 instance不为空，因此返回instance，但此时instance还未被初始化。）<br> 使⽤ volatile 可以禁⽌ JVM 的指令重排 ，保证在多线程环境下也能正常运⾏。</li></ol></li><li><p>代理模式</p><p><strong>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p>代理模式有静态代理和动态代理两种实现，动态代理最常见的是JDK动态代理和GLIB动态代理</p><p>动态代理的核心是<strong>InvocationHandler接口</strong>和<strong>Proxy类</strong></p></li></ol></li></ol><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><strong>内存淘汰策略</strong></p><p>volatile：从已设置过期时间的key中淘汰  allkeys:从键空间中淘汰</p><p>lru:最近最少使用  lfu:最不经常使用   random:随机淘汰</p><p>默认淘汰策略：noeviction:对于写请求不再提供服务，直接返回错误</p><p><strong>双写一致性</strong></p><p>两个更新：如果数据库更新失败或回滚，可能会造成并发更新导致的覆盖，或缓存更新成功，数据库更新失败导致的数据不一致</p><p>先删除缓存，后更新数据库  A写B读-&gt;a删缓存，b读，将数据加到缓存，a更新数据库。  读取的是脏数据。延时双删：（1）先淘汰缓存 （2）再写数据库（这两步和原来一样） （3）休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><p>先更新数据库，后删除缓存</p><p>消息队列解决删除缓存失败的问题</p><p><strong>多线程模型</strong></p><p>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，<strong>执行命令仍然是单线程顺序执行。</strong></p><ol><li>主线程获取 socket 放入等待列表</li><li>将 socket 分配给各个 <strong>IO 线程</strong>（并不会等列表满）</li><li>主线程阻塞等待 IO 线程（多线程）读取 socket 完毕</li><li><strong>主线程执行命令 - 单线程</strong>（如果命令没有接收完毕，会等 IO 下次继续）</li><li>主线程<strong>阻塞等待 IO 线程（多线程）将数据回写 socket 完毕</strong>（一次没写完，会等下次再写）</li><li>解除绑定，清空等待队列</li></ol><p><strong>哨兵模型</strong></p><p>哨兵可以监视一个或者多个redis <strong>master服务</strong>，以及这些master服务的所有<strong>从服务</strong>。 某个master服务宕机后，会把这个master下的某个从服务<strong>升级</strong>为master来替代已宕机的master继续工作。</p><p>分布式锁</p><p>setnx key test 当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败；</p><p>del key 当得到的锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式就是执行del指令。</p><p>expire</p><p><strong>如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？</strong></p><p>如果是读高并发的话，先看读并发的数量级是多少，因为Redis单机的读QPS在万级，每秒几万没问题，使用一主多从+哨兵集群的缓存架构来承载每秒10W+的读并发，主从复制，读写分离。</p><p>使用哨兵集群主要是提高缓存架构的可用性，解决单点故障问题。主库负责写，多个从库负责读，支持水平扩容，根据读请求的QPS来决定加多少个Redis从实例。如果读并发继续增加的话，只需要增加Redis从实例就行了。</p><h1 id="校园论坛项目"><a href="#校园论坛项目" class="headerlink" title="校园论坛项目"></a>校园论坛项目</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><ol><li><p>项目有四张表（loginticket保存在redis中）：评论、帖子、消息、用户</p></li><li><p>索引加了没有？创建索引的方法？</p><ul><li>创建表时创建</li></ul><p>index/key st_name(sname)</p><p>key/index (sname)</p><ul><li>create (unique)index index_name on table (column_name)</li></ul><p><strong>各个表的索引</strong></p><p>评论comment表   userid     entity_id</p><p>帖子表discuss_post      userid</p><p>消息表message   from_id  to_id   conversation_id</p><p>用户表user  username email</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `comment` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `user_id` int(11) DEFAULT NULL,</span><br><span class="line">  `entity_type` int(11) DEFAULT NULL,</span><br><span class="line">  `entity_id` int(11) DEFAULT NULL,</span><br><span class="line">  `target_id` int(11) DEFAULT NULL,</span><br><span class="line">  `content` text,</span><br><span class="line">  `status` int(11) DEFAULT NULL,</span><br><span class="line">  `create_time` timestamp NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `index_user_id` (`user_id`) /*!80000 INVISIBLE */,</span><br><span class="line">  KEY `index_entity_id` (`entity_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>常用注解：</p><p>Component、Configuration、Repository、Service、Controller、RequestMapping、Responsebody、Value</p><p>Controller和RestController的区别？</p><p>restcontroller是controller和responsebody的合体，controlller可以通过返回string跳转到模板页面，也可以通过responsebody返回实体对象</p></li><li><p>如何开启事务？</p><p>在service层的方法上加上@Transactional注解，设置隔离级别为读取已提交（避免脏读问题），设置事务传播行为为REQUIRED(默认), 如果当前存在事务则加入该事务，否则创建新事务 </p></li><li><p>explain mysql</p><p>在select语句之前增加explain关键字，执行后MySQL就会返回执行计划的信息，而不是执行sql。但如果from中包含子查询，MySQL仍会执行该子查询，并把子查询的结果放入临时表中。用来查询是否命中索引等信息</p></li><li><p>springboot的核心配置文件？</p><p>application.properties   application.yml</p><p>使用方式？@Value注解</p></li><li><p><strong>怎么部署的？</strong></p><p>先使用jar -cvf xxx.jar进行打包</p><p>复制到对应目录</p><p>启动redis(6379)、kafka(9092)、nacos、zookeeper等</p><p>java -jar xxx.jar命令启动项目</p><p>tomcat端口：8080</p></li><li><p>异步请求controller</p><p>加上responsebody注解</p><p>使用fastjson工具类，封装了状态码（0）和消息对象（发布成功等），controller返回时返回这个封装好的对象</p></li></ol><h2 id="项目难点或亮点"><a href="#项目难点或亮点" class="headerlink" title="项目难点或亮点"></a>项目难点或亮点</h2><ol><li><p>帖子或评论敏感词过滤</p><p>步骤：</p><ul><li><p>定义前缀树</p><ul><li>主要有两个成员变量，关键词结束标志和子节点，在节点的数据结构中建立hashmap用于存储结构</li></ul></li><li><p>根据敏感词，初始化前缀树</p><ul><li><p>通过类加载器在classPath目录下获取资源.并且是以流的形式。<strong>（</strong>InputStream  数据流类</p><p>　一般来说，就是将字符串、管道数据（socket通倒）、文件、字节等转换为输入流，以流的方式去读取；</p><p>但是inputstream的读取速率较低，为了提高读取速率，一般将InputStream 交给 BufferedReader，然后调用BufferedReader的读取方法；BufferedReader 缓存阅读器，简单来说吧，就是通过BufferedReader，将要读取的数据调入缓冲区，这样读取效率就高了。<strong>）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;sensitive-words.txt&quot;</span>);</span><br><span class="line"><span class="comment">//字节流转字符流</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><pre><code> - 遍历字符串，取出字符 - 若当前节点存在以c为key的子节点，指向子节点，进入下一轮循环 - 若不存在，初始化子节点，并放入 - 若达到敏感词结尾，设置关键词结束标志为true</code></pre><ul><li><p>编写过滤敏感词的方法</p><p>定义3个指针，指针1为根节点，指针2为begin，指针3为position。</p><p>遍历字符串，如果遇到符号，符号在begin位置，23都加1，否则3加1.</p><p>检查前缀树中是否存在以begin位置所在字符开头的节点，若不存在，将其添加到结果中，postition和begin指向下一个位置，指针1节点归位，如果存在并且为关键词结束标识，将替换字符串(**)添加到结果中，begin从position下一位置开始，树节点归位</p><p>难点：</p><p>遇到敏感词为fabcd和abc，要检测的字符串最后一段为fabc<br>原来以指针3position作为循环判断条件，此时指针2为f，循环之后指针3为c，c不是fabcd的敏感词标志位节点，所以直接跳出了，<strong>没有检测f之后的字符作为begin的情况。</strong><br>所以要以指针2begin作为循环条件。</p></li></ul><ol><li>评论回复功能</li></ol><h2 id="自增主键"><a href="#自增主键" class="headerlink" title="自增主键"></a>自增主键</h2><p>Mybatis 获取自增主键？</p><p>若数据库支持自动生成主键（比如 MySQL 和 SQL Server），则可以设置 <strong>useGeneratedKeys=“true”，</strong>表明使用自增主键获取主键值策略，然后再利用 <strong>keyProperty</strong> 属性指定对应的主键属性，也就是 Mybatis 获取到主键值后，将这个值封装给 JavaBean 的哪个属性。</p><h2 id="登录验证码"><a href="#登录验证码" class="headerlink" title="登录验证码"></a>登录验证码</h2><p>使用了开源的谷歌的验证码库</p><p>生成验证码文本和图片，并存入redis和cookie（cookie再放入response中，返回给客户端）（因为属于敏感数据）中</p><p>登录时从cookie（@CookieValue注解）中取出，并与redis缓存中的数据进行对比</p><h2 id="点赞"><a href="#点赞" class="headerlink" title="点赞"></a>点赞</h2><p>点赞功能如何实现的？</p><p>前端传入点赞指向类型，指向类型id，指向类型的发布用户id(帖子、评论还是评论回复)</p><p>查询某用户是否给实体点赞了，用的set数据类型<strong>isMember</strong>方法，key为对应的实体类型和实体id组成的字段，查询对应的实体集合里是否有该用户的userid</p><p>开启事务</p><p>如果有</p><p>则取消点赞，将userid从实体集合里移除，并将该用户点赞数减一</p><p>否则添加到集合，并点赞数加1</p><p>结束事务</p><h2 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h2><p>邮箱功能用到了网络中的什么协议？</p><p>应用层的SMTP POP3</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>使用aop做了日志记录功能，用户在何时访问了哪些服务</p><p>定义一个切面类使用@Component、@Aspect注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span> <span class="comment">//指告诉切面类，通知方法在什么时候运行</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.ps.community.service.*.*(..))&quot;)</span> <span class="comment">//定义在service包里的任意方法的执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//运行顺序，编写before方法</span></span><br><span class="line"><span class="meta">@Before(&quot;pointCut&quot;)</span></span><br><span class="line"><span class="comment">//参数为joinpoint类</span></span><br><span class="line"><span class="comment">//从requestcontextholder类中取出request对象，再进一步取出用户的ip值，从joinpoint类中取出当前方法名</span></span><br><span class="line"><span class="comment">//logger.info()输出</span></span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ol><li>定义了三个继承了HandlerInterceptor类的自定义拦截器<ol><li><strong>统计网站uv和dau的拦截器</strong>： 从<strong>HttpServletRequest</strong>对象中取出<strong>ip</strong>值，调用redis中的<strong>hyperloglog</strong>存入ip值。从<strong>threadlocal</strong>中取出<strong>user</strong>对象，调用redis中的<strong>bitmap</strong>将<strong>userid</strong>存入对应的key中，设置状态为true</li><li><strong>登录拦截器</strong><ul><li>preHandle（handler调用前，首次登录存入）: 从HttpServletRequest对象中取出cookie，再从cookie中取出ticket值，根据ticket值找出loginticket对象，取出userid, 找到user对象，存入threadlocal。并存入springsecurity中的authentication对象，将此对象存入securtiycontextholder对象</li><li>postHandle(渲染之前，handler调用之后)：从threadlocal里取出user，存入modelandview，方便后续调用</li><li>aftercompletion(<strong>DispatcherServlet进行视图的渲染之后</strong>):清除threadlocal，防止内存泄漏</li></ul></li><li><strong>消息拦截器</strong>(统计用户未读消息总数)<ul><li>postHandle: 调用未读消息数量方法和未读私信数量方法，放入modelandview对象中</li></ul></li></ol></li><li>重写了preHandle、postHandle、afterCompletion方法</li></ol><p>并在继承了WebMvcConfigurer类的自定义配置类上，重写addInterceptor方法，调用registry对象进行注册拦截器，并过滤静态资源</p><h2 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h2><ol><li><p>redis在项目中主要用在哪些地方？</p><ul><li><strong>社交网络</strong>：与用户相关的一些操作如：点赞（Set、String,opsForValue）、关注（zset, add,remove,score为关注时间）等。社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。如在微博中的共同好友，通过Redis的set能够很方便得出。</li><li>保存用户登录凭证</li><li><strong>计数器</strong>：统计网站的uv(浏览用户数量，没有时间限制，一天内同一个用户多次访问只能算一次)和日活跃用户数量DAU（计算在一日之内，不重复的访问用户数量；）</li><li><strong>缓存</strong>：使用Redis作为缓存保存用户信息</li></ul></li><li><p>如何保证数据库和缓存双写时的一致性？</p><p>​    <strong>先更新数据库，再删除缓存</strong></p><p>​    可能存在的问题：比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p><p>解决方案：</p><p><img src="https://s2.loli.net/2022/06/27/MsJjgWpG6DFvqoc.png" alt="image-20220627142602478"></p><p>此时解决方案就是利用消息队列进行删除的补偿。具体的业务逻辑用语言描述如下：</p><ol><li>请求 A 先对数据库进行更新操作</li><li>在对 Redis 进行删除操作的时候发现报错，删除失败</li><li>此时将Redis 的 key 作为消息体发送到消息队列中</li><li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li></ol></li><li><p>统计网站的uv和日活跃用户DAU用到了什么数据结构？</p><p>uv和dau其实没多大区别，只是uv没有时间限制，dau指的是一天内</p><p>hyperloglog有一定误差0.81%，但对于统计UV这种不需要很精确的数据是可以忽略不计的。</p><ul><li><p>UV使用了HyperLogLog（ip）</p><p><strong>使用原因</strong>：如果使用set统计元素数量的方法, 当网站访问量过大是，占用内存过大。而hyperloglog是一种算法，访问在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数</strong>((不重复元素))</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String redisKey = RedisUtil.getUVKey(df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">redisTemplate.opsForHyperLogLog().add(redisKey, ip);</span><br></pre></td></tr></table></figure><p>指定范围内的uv，取到日期keylist，调用<strong>union</strong>方法，最后返回size大小</p></li><li><p>DAU使用了Bitmap(user, 只有用户登录了，代表活跃)，属于string数据类型</p><p>统计用户信息是否活跃，是否经常登录，两种状态的。Bitmap位图都是操作二进制来进行记录，只有0和1两个状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String redisKey = RedisUtil.getDAUKey(df.format(<span class="keyword">new</span> Date()));</span><br><span class="line">redisTemplate.opsForValue().setBit(redisKey, userId, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol><li><p>项目采用默认的<strong>RDB持久化方法</strong></p><p>细说AOF: 命令追加（将写指令追加到aof缓冲区，将缓冲区内容写入到aof文件，将文件保存到磁盘）</p></li></ol><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><ol><li><p>在哪些地方用到了事务管理</p><p>添加评论模块</p><p>当多个用户对帖子添加评论时，可能会出现第一类丢失更新的问题（某一个事务的回滚，导致另一个事务已更新的数据丢失）</p><p>设置事务隔离级别：读取已提交，通过@Transactional关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="comment">//TransactionDefinition.PROPAGATION_REQUIRED：</span></span><br><span class="line">   如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</span><br></pre></td></tr></table></figure></li></ol><h2 id="缓存设置"><a href="#缓存设置" class="headerlink" title="缓存设置"></a>缓存设置</h2><p><strong>redis缓存</strong>：缓存热点数据，指用户主页信息界面中的user信息以及右上角的头像信息，</p><p><strong>本地缓存：</strong>本地缓存是指将<strong>客户端本地的物理内存划分出一部分空间</strong>用来<strong>缓冲客户机回写到服务器的数据，如cookie等</strong></p><p>本地缓存是在<strong>同一个进程内的内存空间中缓存数据，数据读写都是在同一个进程内完成</strong>；而分布式缓存是一个独立部署的进程并且一般都是与应用进程部署在不同的机器，故需要通过网络来完成分布式缓存数据读写操作的数据传输。</p><p> 多级缓存机制</p><p>帖子列表使用本地缓存（caffine，底层使用concurrenthashmap）,使用<strong>@PostContrust</strong>注解，该注解修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。在spring中在autowired注解实现依赖注入之后调用。</p><p><strong>Caffine.buidler返回一个LoadingCache的map，在builder中重写load方法</strong></p><p>​    使用redis缓存存储用户信息(user对象），如果拦截器cookie里的ticket值不为空，根据ticket值去redis缓存中查找该ticket对象，若有则根据ticket对象中的userId去缓存找对应的user对象，如果没有再去数据库中找，并初始化缓存，找到后放到threadlocal的map里)</p><p>使用redis缓存存储用户登录凭证loginTicket</p><p>​    </p><h2 id="Elasticserach搜索"><a href="#Elasticserach搜索" class="headerlink" title="Elasticserach搜索"></a>Elasticserach搜索</h2><p>使用elasticsearch搜索帖子</p><ol><li><p>elasticsearch怎么实现的？实现关键点？</p><ol><li>自定义一个接口继承<strong>ElasticsearchRepository</strong></li><li>构建服务类导入自定义接口和elasticsearch模板</li><li>调用接口实现增删方法</li><li>构建nativesearchquery查询，设置相关属性。调用模板返回结果</li></ol><p>高亮显示关键词：使用nativesearchbuilder中的<strong>withhighlightField</strong>方法指定<strong>高亮字段</strong></p></li><li><p>elasticsearch查询为什么快？为什么不用mysql</p><p>mysql使用的b-tree 索引是为<strong>写入</strong>优化的索引结构。当我们不需要支持快速的更新的时候，可以用预先排序等方式换取更小的存储空间，更快的检索速度等好处，其代价就是更新慢，即倒排索引。</p><p>现在我们可以回答“为什么 Elasticsearch/Lucene 检索可以比 mysql 快了。Mysql 只有 term dictionary 这一层，是以 b-tree 排序的方式存储在磁盘上的。<strong>检索一个 term 需要若干次的 random access 的磁盘操作</strong>。而 Lucene 在 term dictionary 的基础上<strong>添加了 term index</strong> （这棵树不会包含所有的 term，它包含的是 term 的一些前缀。<strong>通过 term index 可以快速地定位到 term dictionary 的某个 offset，然后从这个位置再往后顺序查找。</strong>再加上一些压缩技术（搜索 Lucene Finite State Transducers FST） term index 的尺寸可以只有所有 term 的尺寸的几十分之一，使得用内存缓存整个 term index 变成可能。）来加速检索，<strong>term index</strong> 以树的形式缓存在内存中。从 term index 查到对应的 term dictionary 的 block 位置之后，再去磁盘上找 term，<strong>大大减少了磁盘的 random access 次数。</strong></p></li><li><p>elasticsearch原理（倒排索引）</p><p>Elasticsearch分别为每个field都建立了一个倒排索引，Kate, John, 24, Female这些叫term，而 [1,2] 就是Posting List。Posting list就是一个int的数组，存储了所有符合某个term的文档id。通过posting list这种索引方式可以很快进行查找，比如要找age=24的人。</p><h4 id="Term-Dictionary"><a href="#Term-Dictionary" class="headerlink" title="Term Dictionary"></a>Term Dictionary</h4><p>Elasticsearch为了能快速找到某个term，将所有的term排序，二分法查找term，logN的查找效率，就像通过字典查找一样，这就是Term Dictionary。类似于传统数据库的B-Tree的，但是Term Dictionary较B-Tree的查询快。</p><h4 id="Term-Index"><a href="#Term-Index" class="headerlink" title="Term Index"></a>Term Index</h4><p>B-Tree通过减少磁盘寻道次数来提高查询性能，Elasticsearch也是采用同样的思路，直接通过<strong>内存</strong>查找term，不读磁盘，但是如果term太多，term dictionary也会很大，放内存不现实，于是有了<strong>Term Index</strong>，就像字典里的索引页一样，A开头的有哪些term，分别在哪页，term index其实是一颗 (trie) 前缀树：<img src="https://s2.loli.net/2022/07/18/g7IpiwYrVeB4unT.webp" alt="img"></p></li></ol><p>   这棵树不会包含所有的term，它包含的是term的一些前缀。通过term index可以快速地定位到term dictionary的某个offset，然后从这个位置再往后顺序查找。</p><p>   <img src="https://s2.loli.net/2022/07/18/jDoa3TIb2VmxM5f.webp" alt="img"></p><p>   所以term index不需要存下所有的term，而仅仅是他们的一些前缀与Term Dictionary的block之间的映射关系，再结合FST(Finite State Transducers)的压缩技术，可以使term index缓存到内存中。从term index查到对应的term dictionary的block位置之后，再去磁盘上找term，大大减少了磁盘随机读的次数。</p><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>功能：</p><ul><li>异步（接口的吞吐量会大幅度提高（因为未做真正实际调用，接口RT会非常低））</li><li>解耦</li><li>削峰（ 即便有大批量的消息调用接口都不会让系统受到影响（流量由消息队列承载））</li></ul><ol><li><p>kafka为什么吞吐量高呢？</p><ul><li><p>顺序读写</p><p>kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能，顺序读写不需要硬盘磁头的寻道时间，只需很少的扇区旋转时间，所以速度远快于随机读写。</p></li><li><p>零拷贝</p><p>减少拷贝次数，直接将文件数据发送到网卡上</p></li><li><p>分区</p><p>kafka中的topic中的内容可以被分为多个partition，每个partition又分为多段segment，所以每次操作都是针对一小部分做操作，很轻便，并且增加并行操作的能力。</p></li><li><p>批量发送</p><p>kafka允许进行批量发送消息，producer发送消息的时候，可以将消息缓存在本地，等到固定条件再发送到kafka</p><ul><li>消息条数满足固定条数</li><li>一段时间发送一次数据压缩</li></ul></li></ul></li><li><p>kafka如何保证数据可靠性(高可用）</p><p>Kafka的ack机制，指的是<strong>producer的消息发送确认机制</strong></p><p>在kafka中，<strong>每个主题可以有多个分区，每个分区又可以有多个副本。这多个副本中，只有一个是leader，而其他的都是follower副本。</strong>仅有leader副本可以对外提供服务。</p><p>kafka每个分区上的数据都会同步到其他机器，形成自己的几个副本。为保证producer发送的数据，能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后，都需要向producer发送ack（acknowledgement确认收到），如果producer收到ack，就会进行下一轮的发送，否则重新发送数据。</p><ul><li><p>副本数据同步策略： kafka用的策略为全部同步完成，发送ack</p></li><li><p>ISR</p><p> leader维护了一个集合（同步副本），和leader保持同步的follower集合。当ISR中的follower完成数据的同步之后，leader就会给生产者发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定（默认：10s）。</p><p>如果Leader发生故障，就会从ISR中选举新的leader</p></li><li><p>ack应答机制</p></li></ul></li></ol><pre><code> Kafka为用户提供了三种可靠性级别（acks参数）：  acks：               0：producer不等待broker的ack，直接发送下一条数据，提供了最低的延迟，broker一接受到还没写入磁盘，就已经返回，当broker故障时有可能丢失数据               1：producer等待broker的ack，partition的leader确认接收后返回ack，如果在follower同步之前leader故障，将会丢失数据              -1：producer等待broker的cak，partition的leader和follower全部落盘成功后才返回ack，但如果在follower同步完成后，broker发送ack之前，leader发生故障，那么将会造成数据重复。</code></pre><ol><li><p>kafka选主机制</p><p>它在所有的broker中选出一个controller，所有的partition的leader选举都有controller决定。controller会将leader的改变直接通过RPC的方式（比zookeeper Queue的方式更高效）通知需要为此作为响应的broker。</p></li><li><p>消费者如何提高吞吐量（数据积压问题）</p><ul><li>增加分区数，不能大于broker数，大于时会出现无法消费数据的情况</li><li>多线程消费一个分区的数据，但需要手动维护每个分区的offset</li></ul></li><li><p>保证消息顺序性？</p><ul><li>设定topic有且只有一个分区（kafka只保证分区内有序）</li><li>多个分区时可以指定message key, 将key的hash值与topic的分区数取余得到对应分区，保证同一条数据会被分配到同一个分区内</li><li>为了保证一个消费者中多个线程去处理时，不会使得消息的顺序被打乱，则可以在消费者中，<strong>消息分发至不同的线程时，加一个队列，通过消息key，消费者去做hash分发</strong>，<strong>将具有相同key的数据，分发至同一个内存队列中</strong>，最后多个线程从队列中取数据。（写N个queue，将具有相同key的数据都存储在同一个queue，然后对于N个线程，每个线程分别消费一个queue即可。）</li></ul></li><li><p>消息丢失问题？</p><p>生产者端：设置消息应答重试机制，保证在生产端不会造成数据丢失</p><p>消费者端：auto.commit.enable=true，消费端自动提交offersets设置为true时，当消费者拉到消息之后还没有处理完而commit interval 提交间隔就到了，提交了offersets。这时consummer又挂了，重启后，从下一个offersets开始消费，之前的消息丢失了（设置auto.commit.enable=false 消费端手动提交，确保消息真的被消费并处理完成）</p></li><li><p>kafka订阅模式</p><p>指定分区、指定主题</p></li></ol><h2 id="帖子功能"><a href="#帖子功能" class="headerlink" title="帖子功能"></a>帖子功能</h2><ol><li><p>获取帖子</p><p>前端get请求，携带帖子id，controller使用pathvariable注解获得参数</p></li></ol><h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p>封装了一个page对象，里面有current当前页，每页条数limit, 总数rows，访问路径path。</p><p>getoffset方法：(current-1)*limit</p><p>获取总页数方法： rows/limit。</p><p>controller传入page对象,只有<strong>当前页数</strong>，设置对象参数</p><p>limit : 5</p><p>path：相对路径+帖子id</p><p>rows: 调用方法</p><h2 id="通知功能"><a href="#通知功能" class="headerlink" title="通知功能"></a>通知功能</h2><p>站内通知主要是系统通知，定义了一个事件类（topic、userid、entitytype、entityid、entityuserid、data）, 当handler触发<strong>评论或点赞或关注</strong>事件时，生成一个event对象，调用生产者类中的kafkatemplate.send方法发送消息（json序列化，JSONObject.toJSONString）到指定主题，在消费者端定义一个方法，该方法上有<strong>kafkalistener</strong>注解，监听指定topic上的事件，对传过来的记录解析成event对象，并从event对象中取出相关字段，封装到message对象中，然后将message添加到message表中。</p><h2 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h2><p>post方法传入comment类，请求url传入贴子id，补齐字段，添加评论，添加过程中使用@Tranactional注解，设置隔离级别为读已提交，事务传播行为为默认，然后插入评论及更新评论数量</p><h2 id="数据统计功能"><a href="#数据统计功能" class="headerlink" title="数据统计功能"></a>数据统计功能</h2><p>使用拦截器的prehandle方法获取用户的ip值，然后使用hyperloglog(add)，以当前日期为key，ip值为value添加，使用bitmap(<strong>opsForValue.setBit</strong>)，以日期为key，userid为value,状态为true</p><p>controller层，传入起始日期和终止日期，统计范围内的uv（使用Calendar工具类，每隔一天取出日期，转换到arraylistlist列表中,将天数里的value合并到一起，用union方法，最后返回总key的size）和dau(使用or运算)。</p><h2 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h2><p>刷新帖子分数</p><p>Quartz定时任务实现过程?</p><p>当<strong>评论或点赞的controller层中传过来的实体类型是帖子类型的话，</strong>事件触发时，将对应的帖子id存入redis的set集合中</p><ol><li><p>定义quartz配置类，定义jobdetail bean和trigger触发器bean（5分钟执行一次），注入到工厂中</p></li><li><p>定义实现了quartz的job接口的任务类，重写<strong>execute</strong>方法，从redis对应的set中依次取出（pop）所有postid</p><p>根据postId查询帖子，查询该帖子是否加精、评论数量及点赞数量，以此计算帖子分数，并更新到数据库中</p><p>分数计算规则：帖子权重+帖子距离天数</p></li></ol><h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h2><p>这个spring security权限控制是怎么做的。</p><ol><li>因为没有使用security的登录认证，所以使用一个拦截器，在处理前查找cookie中是否有登录凭证，如果有根据登录凭证查找用户，定义authentication对象，保存用户相关信息，并存入SecurityContextHolder中方便后面配置类取出</li><li>定义一个配置类，继承自<strong>WebsecurityConfigureAdapter</strong>类。</li><li>重写<strong>configure</strong>方法，对不同访问路径设置不同权限</li><li>并配置没有登录及权限不够时的处理规则<ul><li>分为两种请求情况：没有登录时，若是ajax异步请求，使用json工具类封装一个json对象，里面包含403状态码及响应信息，并写到httpservletresponse里。若是普通请求，response.sendredirect重定向到登录页面</li></ul></li></ol><h2 id="分布式-Session"><a href="#分布式-Session" class="headerlink" title="分布式 Session"></a>分布式 Session</h2><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p><p>分布式 Session 一般会有以下几种解决方案：</p><ul><li><p><strong>客户端存储</strong>：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息</p></li><li><p><strong>Nginx ip_hash 策略</strong>：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</p></li><li><strong>Session 复制</strong>：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li><li><strong>共享 Session</strong>：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</li></ul><p>本项目使用redis存储用户的ticket（userid, status, 随机字符串， 过期时间），直接将ticket保存在cookie中的方法</p><h2 id="登录机制"><a href="#登录机制" class="headerlink" title="登录机制"></a>登录机制</h2><p>用户登录时生成一个类似session的loginticket登录凭证对象，该对象由userid, 状态码，ticket值，过期时间组成，将该对象存入redis中，登录成功后将ticket值存入cookie中，访问时通过拦截器查询ticket值找到ticket对象，如果不为空，根据ticket对象里的userid取出对应的user对象，并存入当前线程中，即threadlocal局部变量中，可以在同一线程中很方便的获取用户信息，方便后续访问</p><h2 id="后端如何传数据到前端"><a href="#后端如何传数据到前端" class="headerlink" title="后端如何传数据到前端"></a>后端如何传数据到前端</h2><p>使用ModelAndView+Map    使用HttpServletRequest    使用Model</p><h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="BIO-NIO"><a href="#BIO-NIO" class="headerlink" title="BIO NIO"></a>BIO NIO</h2><p>BIO: 线程等待某个条件，如果条件不满足，会一直等待下去，这个线程会阻塞住不能做其他操作</p><p>NIO: 线程等待某个条件，如果条件不满足,会直接返回-1，并去做其他的操作。</p><p>IO多路复用：程序注册一组socket文件描述符给操作系统，表示“我要监视这些fd是否有IO事件发生，有了就告诉程序处理”。</p><p>内核态：<strong>内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备</strong>，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况。</p><p>用户态:：用户态运行的程序只能受限地访问内存，<strong>只能直接读取用户程序的数据</strong>，<strong>并且不允许访问外围设备</strong>，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</p><h2 id="复用Channel怎么实现的？"><a href="#复用Channel怎么实现的？" class="headerlink" title="复用Channel怎么实现的？"></a>复用Channel怎么实现的？</h2><ol><li>定义一个concurrenthashmap存储channel对象，其中key为连接地址和序列化器代码的拼接字符串，值为channel对象</li><li>发送请求包时先判断map中是否有对应的channel对象，若有并且处于激活状态则直接返回</li><li>若未激活从map中移除该对象</li><li>初始化一个bootstrap，设置好handler, 调用connect方法，设置监听器addListener异步返回连接成功的channel对象</li><li>并放入map中</li></ol><p>设置一个静态方法，返回值为channel对象，并维护、一个ConcurrentHashMap用于存储channel对象，其中对象以连接地址和序列化器作为key存储，如果map中有并且channel处于激活状态则直接返回对象，如果没有则进行连接并生成一个channel对象并放入</p><p>为什么这么做？</p><ol><li>避免多次连接，生成多个channel消耗内存</li><li>方便其他方法直接获取通道，比如心跳检测</li></ol><p><strong>可配置怎么做的？</strong></p><p>调用不同的实例化方法</p><h2 id="请求包"><a href="#请求包" class="headerlink" title="请求包"></a>请求包</h2><p>发送的请求包含哪些信息？</p><p>请求序号、接口名、方法名、方法参数、参数类型、是否心跳包</p><h2 id="响应包"><a href="#响应包" class="headerlink" title="响应包"></a>响应包</h2><p>对应请求号、状态码、消息、返回数据</p><p>跟其他的 RPC 框架有作对比嘛，有哪些区别呢？  </p><h2 id="Netty粘包你是怎么解决的？"><a href="#Netty粘包你是怎么解决的？" class="headerlink" title="Netty粘包你是怎么解决的？"></a>Netty粘包你是怎么解决的？</h2><p>本质原因： <strong>TCP 是流式协议，消息无边界</strong></p><p>粘包原因？</p><ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul><p>半包原因？</p><ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul><p><strong>你的RPC如何防止粘包半包？</strong></p><ol><li><p>客户端服务器端 防止nagle算法延迟发送<br>.childOption(ChannelOption.TCP_NODELAY, true)</p></li><li><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的，协议中包含数据长度，解码器继承自replayingdecoder，当缓冲区中没有足够的数据时，会抛出某种类型的一个Error。</p><p>网络波动呢？check方法</p></li></ol><p><strong>还可以有哪些方法？</strong></p><ol><li>短连接。<strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></li><li>定长解码器。客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong></li><li><strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的：行解码器、指定分隔符解码器</li></ol><h2 id="Rpc和Http的区别"><a href="#Rpc和Http的区别" class="headerlink" title="Rpc和Http的区别"></a>Rpc和Http的区别</h2><ol><li><p>http是协议、rpc是方法，rpc也可以基于http</p></li><li><p>http基于http协议，rpc基于tpc协议，也可以基于http协议</p></li><li><p>http中所使用的报文中<strong>有效字节数仅仅占约 30%</strong>，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。而rpc仅通过序列化发送有效数据，省去了很多无效的数据，提高传输效率。</p><p>http需要可读性强，包括输入、输出，解析等。rpc就像调用方法一样调用，很简单。</p></li><li><p>良好的rpc调用是<strong>面向服务</strong>的封装，针对服务的<strong>可用性</strong>和<strong>效率</strong>等都做了优化。单纯使用http调用则缺少了这些特性。</p><h2 id="自动注册具体是怎么做的？"><a href="#自动注册具体是怎么做的？" class="headerlink" title="自动注册具体是怎么做的？"></a>自动注册具体是怎么做的？</h2><p>自动注册方法在抽象类rpcserver上实现的 （成员变量对本包和其子类可见）</p></li><li><p>定义注解</p><p>service、servicescan</p><p>@Service 放在一个类上，标识这个类提供一个服务，@ServiceScan 放在启动的入口类上（main 方法所在的类），标识服务的扫描的包的范围。</p></li><li><p>扫描服务</p></li></ol><p>​    首先调用Throwable.getStackTrace方法获取当前线程运行栈，并依此得到栈底的主方法的全限定类名，通过反射获取主方法class对象，判断是否存在servicescan注解，若存在则截取全限定类名获得包名，获得扫描的包的范围的所有class对象，逐个判断是否有service注解，如果有通过反射创建该对象（用于日志），并调用publishservice入服务名和服务地址进行注册</p><p>补充</p><ol><li><p>Nacos服务注册中心什么时候注册的服务？</p><p>服务器端初始化时，在 NettyServer 的构造方法最后，调用 scanServices 方法，即可自动注册所有服务：</p></li></ol><h2 id="自动注销怎么做的？"><a href="#自动注销怎么做的？" class="headerlink" title="自动注销怎么做的？"></a>自动注销怎么做的？</h2><p>用了一个钩子，将注销服务的方法写到关闭系统的钩子方法里</p><p>定义一个钩子类，并使用了单例模式创建了一个shutdownhook对象，在 该对象中的addClearAllHook方法 中，Runtime 对象是 JVM 虚拟机的运行时环境，调用其 Runtime.getRuntime.addShutdownHook 方法增加一个钩子函数，在其中创建一个新线程调用 注册中心工具类的clearRegistry 方法，以及关闭线程池中所有线程完成注销工作。这个钩子函数会在 JVM 关闭之前被调用。</p><p>最后在rpcserver启动之前注册addclearhook这个钩子</p><h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><h3 id="Netty的设计模式"><a href="#Netty的设计模式" class="headerlink" title="Netty的设计模式"></a>Netty的设计模式</h3><p>单例模式：MqtEncoder 保证独一无二</p><p>责任链模式：pipeline 一条链上处理各自任务</p><p>观察者模式：channel.writeAndFlush 任务完成时通知</p><h3 id="Netty的线程模型"><a href="#Netty的线程模型" class="headerlink" title="Netty的线程模型"></a>Netty的线程模型</h3><p>Netty默认线程模型是<strong>主从线程模型的改进</strong>，netty中定义了两个线程池：bossGroup和workerGroup（EventLoopGroup，有一个属性children为NioEventLoop[]）。线程池中的所有线程（NioEventLoop）都包含一个<strong>多路复用器</strong>（selector）。bossGroup中的线程用来监听连接建立（accept）的事件，workerGroup中的线程用来监听通道上的读写（read、write）事件。</p><p>当boss线程监听到accept事件，接受连接并创建channel，然后将channe<strong>l注册到一个worker线程</strong>中。worker线程不断的监听channel上的读写事件，当有事件发生时，会调用channel上的ChannelHandler进行处理。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><strong>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</strong></p><h3 id="Netty为什么选择NIO-NIO的好处-？介绍一下NIO"><a href="#Netty为什么选择NIO-NIO的好处-？介绍一下NIO" class="headerlink" title="Netty为什么选择NIO(NIO的好处)？介绍一下NIO"></a>Netty为什么选择NIO(NIO的好处)？介绍一下NIO</h3><p>三大组件：buffer、channel、selector</p><p>NIO的好处：为了处理BIO在等待客户端连接以及等待接收数据时的阻塞,并且不用为每一个客户端去创建线程，而是从线程池中获取线程资源来处理客户端任务，这样可以使用较少的线程来处理业务。</p><p><strong>非阻塞</strong>：非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</p><p><strong>网络中的非阻塞IO</strong>:  客户端将发送的连接请求注册到server中的selector中， selector会循环去判断哪些客户端发生了读、写事件，然后从线程池中获取资源去处理这些事件，处理完之后将线程放回线程池，等待下一次的读、写事件。</p><h3 id="心跳机制？"><a href="#心跳机制？" class="headerlink" title="心跳机制？"></a>心跳机制？</h3><p>Netty 的心跳机制是怎么实现的？   </p><ol><li>开启tcp底层心跳（.option(<strong>ChannelOption.SO_KEEPALIVE</strong>, true)）,缺点：udp用不了，默认为2小时灵活性不够</li><li><strong>应用层</strong>：服务端和客户端</li></ol><p>//5秒未发生读操作，触发事件IdleState.READ_IDLE</p><p>服务器端：pipeline上首先添加了一个<strong>IdleStateHandler</strong>(readerIdleTime(读超时时间):30,writerIdleTime（写超时时间）: 0, allIdleTime（写超时时间）: 0, TimeUnit.SECONDS)</p><p>再设置一个自定义handler，重写<strong>userEventTriggered</strong>方法，如果触发了<strong>IdleState.READ_IDLE事件</strong>，断开连接</p><p>客户端：pipeline上添加了一个IdleStateHandler(readerIdleTime(读超时时间):0,writerIdleTime（写超时时间）:30, allIdleTime（写超时时间）: 0, TimeUnit.SECONDS)</p><p>若5秒未发生写操作，触发事件IdleState.WRITE_IDLE</p><p>设置一个handler，重写事件触发方法，如果触发了IdleState.WRITE_IDLE事件，<strong>获取当前连接通道，new一个请求消息，设置消息为心跳包类型，调用channel.writeAndFlush写入通道</strong></p><p><strong>如果网络存在波动的话，现在的心跳机制可以解决吗？如果不行有什么优化思路？</strong>  </p><p>finally块中，断开连接后，重新调用客户端启动方法，客户端重连</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>定义一个接口（实例列表，ip（客户端ip））</p><p>随机法、轮询法(顺序)、<strong>源地址哈希法</strong></p><p>源地址哈希法：</p><p>根据客户端ip得到哈希值并与实例列表大小进行取模运算，得到实例序号</p><p>优点：<strong>保证相同客户端ip哈希到同一服务器</strong>，可以利用<strong>此特性建立有状态的session会话</strong></p><p>缺点：如果服务器频繁上下线，不适合建立session</p><h2 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h2><p>组成：魔数、版本号、调用类型、序列化器、数据长度（防止粘包）</p><h2 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h2><p>   四种序列化协议的优缺点讲一下，为什么选择这四种序列化协议，依据是什么？</p><p>​    为什么使用kryo?</p><p>​    一是基于字节的序列化，对空间利用率较高，在网络传输时可以减小体积；二是序列化时记录属性对象的类型信息</p><h2 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h2><p>编码器继承自<strong>MessageToByteEncoder</strong>类（假定消息未被规范化）</p><p>写到比特缓存区内</p><p>自定义协议：魔数、版本号、消息类型（请求、响应）、序列化器类型、消息长度、消息</p><p>解码器继承自<strong>ReplayingDecoder</strong> 略慢于bytetomessagedecoder</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>四种序列化器（kryo、json、hessian、protobuf），默认<strong>Kryo</strong>（稳定且最快）</p><p>定义了一个序列化接口</p><p>（序列化器常量四种0123</p><p>根据代码获取序列化实例的方法(静态)</p><p>序列化、反序列化方法</p><p>获取序列化器代码）</p><p><strong>速度对比</strong>： protostuff &gt; kryo &gt; hassian &gt; json</p><p>序列化之后的占用空间，kryo略低于protostuff, 两者都远高于json.</p><p>protostuff（是protobuf的改良版本） 速度快   不支持无默认构造函数的类</p><p>kryo  速度快，序列化后体积小</p><p>Hessian 支持跨语言  较慢</p><h3 id="kryo"><a href="#kryo" class="headerlink" title="kryo"></a>kryo</h3><p>Kryo序列化机制比默认的Java序列化机制速度要快，序列化后的数据要更小，大概是Java序列化机制的1/10。所以Kryo序列化优化以后，可以让网络传输的数据变少，在集群中耗费的内存资源大大减少。</p><p> 缺点:</p><p>生成的byte数据中部包含field数据，对<strong>类升级</strong>的兼容性很差！所以，若用kryo序列化对象用于C/S架构的话，两边的Class结构要保持一致。</p><p>如果序列化之后，反序列化之前这段时间内，java class增加了字段（这在实际业务中是无法避免的事情），kyro就废了</p><p>使用：</p><p>使用了一个threadlocal，里面存储了<strong>kryo对象</strong>，threadlocal初始化时对kryo类进行注册，注册请求类的class对象以及响应类的class对象</p><p><strong>序列化和反序列化方法从threadlocalmap里取出kyro对象</strong>，并调用读写方法（read/write Object），并在<strong>结束时从threadlocal中移除kryo对象防止内存泄漏</strong></p><h3 id="Protostuff"><a href="#Protostuff" class="headerlink" title="Protostuff"></a>Protostuff</h3><p>优点：速度最快，对类升级兼容性较好</p><p>protostuff只要保证新字段添加在类的最后，而且用的是sun系列的JDK, 是可以正常使用的。</p><p>缺点：序列化后兼容空间略高于kryo</p><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><p>使用的<strong>jackson</strong>工具包，</p><h3 id="Hessian"><a href="#Hessian" class="headerlink" title="Hessian"></a>Hessian</h3><p>Dubbo默认，优势为跨语言</p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><p>注册中心的作用：存放和调度服务，提供服务注册、服务发现、服务删除等功能</p><p>nacos、zookeeper、eureka(springcloud使用的)</p><p>注册中心需要<strong>高可用</strong></p><p><strong>注册中心可配置？</strong></p><p>主要利用了多态的特性，定义一个rpc抽象类，在抽象类中定义一些变量以及服务注册类型，在子类构造器中初始化服务注册类</p><p><strong>Nacos和zookeeper的区别？</strong></p><p>1.zookeeper采用cp模式形式实现注册中心<br>2.Nacos默认采用AP模式，在1.0版本之后采用ap+cp模式混合实现注册中心。</p><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>一致性(Consistency)：多个副本之间的数据一致性</p><p>可用性(Availability)：保证每个请求不管成功或者失败都有响应</p><p>分区容错性(Partition tolerance)：在分区故障的情况下，仍然可以对外提供正常服务</p><p>Zookeeper:cp  (leader宕机后，在选举过程中，整个微服务无法通讯)</p><p>Nacos:ap+cp（默认情况下采⽤Ap保证服务可⽤性，CP形式底层采⽤Raft协议保证数据的⼀致性问题。如果选择为Ap模式，注册服务的<strong>实例仅⽀持临时模式</strong>，在⽹络分区的的情况允许注册服务实例。选择CP模式可以⽀持注册服务的实例为持久模式，在⽹络分区的产⽣了抖动情况下不允许注册服务实例。）</p><p>临时服务使用的是 Nacos 为服务注册发现场景定制化的私有协议 distro，其一致性模型是 AP；而持久化服务使用的是 raft 协议，其一致性模型是 CP</p><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>使用了官方API</p><h4 id="nacos怎么知道注册到nacos中的微服务还存活？"><a href="#nacos怎么知道注册到nacos中的微服务还存活？" class="headerlink" title="nacos怎么知道注册到nacos中的微服务还存活？"></a>nacos怎么知道注册到nacos中的微服务还存活？</h4><p>Nacos 在 1.0.0版本 instance级别增加了一个ephemeral字段，该字段表示注册的实例是否是临时实例还是持久化实例。如果是临时实例，则不会在 Nacos 服务端持久化存储，需要通过上报心跳的方式进行保活，如果一段时间内没有上报心跳，则会被 Nacos 服务端摘除。在被摘除后如果又开始上报心跳，则会重新将这个实例注册。持久化实例则会持久化到Nacos 服务端，通过主动探知客户端健康的方式进行检测，此时即使注册实例的客户端进程不在，这个实例也不会从服务端删除，只会将健康状态设为不健康。</p><h4 id="Nacos作为注册中心，需要实现哪些功能"><a href="#Nacos作为注册中心，需要实现哪些功能" class="headerlink" title="Nacos作为注册中心，需要实现哪些功能"></a>Nacos作为注册中心，需要实现哪些功能</h4><p>服务注册、服务发现、服务删除</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>高可用怎么实现的？<strong>主从复制集群方式，主节点可进行读和写操作，从节只进行读操作。</strong></p><p>怎么做的注册中心？</p><p>用了一个工具API：ZkClient</p><p><strong>Zookeeper中的共识机制是一种改进型的Raft协议。称为ZAB协议。</strong></p><h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><p>半数机制（Paxos协议）：集群中只要有半数以上节点（最少3台）存活，Zookeeper集群就能正常服务</p><p>myid: 服务器id  zid：事务id, 用来标识一次服务器状态变更。在某一时刻，集群中的每台机器的zxid值不一定完全一致</p><p>epoch: 每个leader任期的代号，每投完一次票(当过一次leader)该数据会增加</p><p><strong>第一次选举</strong></p><p>假设有五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是<strong>最新启动</strong>的，也就是<strong>没有历史数据</strong>，在存放数据量这一点上，都是一样的，并且这些服务器是从1-5依序启动的。</p><p>​    1.  服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING；</p><ol><li>服务器2启动，再发起一次选举。服务器1和2分别投自己一票并<strong>交换选票</strong>信息：此时两台服务器的zxid相同，但是服务器1发现服务器2的myid比自己目前投票推举的（服务器1自己）大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上（3票）结果，选举无法完成，服务器1，2状态保持LOOKING；</li><li>服务器3启动，发起一次选举。同理此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING；</li><li>服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，<strong>不会更改选票信息</strong>。<strong>交换选票信息结果</strong>：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING，此时服务器3的票数为4票；</li><li>服务器5启动，同服务器4一样没得选择，只能当小弟，只能说生不逢时了。</li></ol><p><strong>leader故障时</strong></p><p>选举规则（交换选票结果时）</p><p>epoch&gt;zid&gt;mid</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>InetSocketAddress：封装ip+端口的一个类</p><p>实例节点为临时节点（会话失效就删除，下面不能创建子节点），服务名节点为持久节点（即使创建节点的客户端和 Zookeeper 服务端的会话失效(例如断开连接)，节点也不会被删除，只有客户端主动发起删除节点的请求，节点才会被删除。）</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>1.基于唯一节点特性实现;2. 基于顺序节点特性实现。</p><p><strong>唯一节点特性</strong></p><p>多个应用程序去抢占锁资源时，只需要在指定节点上创建一个 /Lock 节点，由于Zookeeper中节点的唯一性特性，使得只会有一个用户成功创建 /Lock 节点，剩下没有创建成功的用户表示竞争锁失败。</p><p>如下图所示，假设有非常多的节点需要等待获得锁，那么等待的方式自然是使用watcher机制来<strong>监听/lock节点的删除事件，</strong>一旦发现该节点被删除说明之前获得锁的节点已经释放了锁，那么此时剩下的B、C、D节点会同时收到删除事件从而去竞争锁，这个过程会产生惊群效应。</p><p>什么是“惊群效应”呢？简单来说就是如果存在许多的客户端在等待获取锁，当成功获取到锁的进程释放该节点后，所有处于等待状态的客户端都会被唤醒，这个时候<strong>zookeeper会在短时间内发送大量子节点变更事件给所有待获取锁的客户端，然后实际情况是只会有一个客户端获得锁</strong>。如果在集群规模比较大的情况下，会对zookeeper服务器的<strong>性能产生比较大的影响。</strong></p><p><strong>顺序节点特性</strong></p><p><strong>每个客户端都往指定的节点下注册一个临时有序节点，越早创建的节点，节点的顺序编号就越小，那么我们可以判断子节点中最小的节点设置为获得锁。</strong>如果自己的节点不是所有子节点中最小的，意味着还没有获得锁。这个的实现和前面单节点实现的差异性在于，<strong>每个节点只需要监听比自己小的节点，当比自己小的节点删除以后，客户端会收到watcher事件，此时再次判断自己的节点是不是所有子节点中最小的，如果是则获得锁</strong>，否则就不断重复这个过程，这样就不会导致羊群效应，因为每个客户端只需要监控一个节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Web开发" scheme="http://ppnostalgia.github.io./categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Spring" scheme="http://ppnostalgia.github.io./tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA内存模型-JMM</title>
    <link href="http://ppnostalgia.github.io./24598ec1.html"/>
    <id>http://ppnostalgia.github.io./24598ec1.html</id>
    <published>2022-06-05T07:29:34.000Z</published>
    <updated>2022-06-20T13:26:36.015Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><h2 id="1-现代计算机的内存模型"><a href="#1-现代计算机的内存模型" class="headerlink" title="1. 现代计算机的内存模型"></a>1. 现代计算机的内存模型</h2><p>早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，cpu的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。需要注意的是，加入了高速缓存的机制，并不是始终都能从缓存中取到数据，如果不是同一内存地址的数据，处理器还必须绕过缓存，从主内存中获取数据，这种现象称之为“缓存命中率”，类似application—redis—DB架构。</p><p>　　基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（MainMemory）。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，例如：共享变量在多个处理器中被进行写操作，导致高速缓存中的数据不一致。如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/82ab8c964f348e3424e0682027dcebb3.png" alt="img"></p><h2 id="2-JMM与JVM的关系"><a href="#2-JMM与JVM的关系" class="headerlink" title="2.  JMM与JVM的关系"></a>2.  <strong>JMM与JVM的关系</strong></h2><p>​        JVM虚拟机是一种抽象化的计算机，同计算机一样，它有着自己的一套完善的硬体架构，如处理器、堆栈、寄存器、操作指令等，而在JVM篇中也讲到过虚拟机栈，虚拟机栈是用于描述java方法执行的内存模型，因此JMM也是属于JVM的一部分，只是<strong>JAVA内存模型（Java Memory Model，JMM）是一种抽象的概念，是一组规则，并不实际存在。</strong>所不同的是，JMM模型是为了规定了<strong>线程和内存之间的一些关系</strong>。</p><p><img src="https://img-blog.csdn.net/20170513140412095?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTFpONTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>​        JMM约定将内存划分为工作区和公共内存（主内存）数据区域。工作区为线程私有，基本类型数据和对象引用的地址存储在工作区。当需要对主内存区域的数据进行读写时复制到工作区，修改完成后刷新到内存区供其他线程使用。这其中可能会产生数据不一致性的问题，使用Volatile和synchronized以及锁等机制来保证。编码规则，需要注意原子性、可见性、有序性。</p><p>​        JVM是对于JMM约定的<strong>具体实现方法</strong>，将内存分为五个部分，方法区，堆，JVM栈，本地方法栈，程序计数器。前两者属于线程共有，后三者属于线程私有。方法区存储类、常量、JIT即时编译的方法代码，类加载信息的引用等等。堆存储对象。JVM栈主要由方法栈帧组成，栈帧包含方法内的局部变量，操作数栈、动态链接和出口地址。本地方法是JVM本身运行的方法和调用其他语言的区域。程序计数器记录线程执行的地址，方便线程切换。</p><h2 id="3-JMM三大特性"><a href="#3-JMM三大特性" class="headerlink" title="3. JMM三大特性"></a>3. JMM三大特性</h2><h3 id="3-1-原子性"><a href="#3-1-原子性" class="headerlink" title="3.1 原子性"></a>3.1 原子性</h3><p>​    原子性指的是一个操作是<strong>不可中断</strong>的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。比如对于一个静态变量int i = 0，两条线程同时对他赋值，线程A操作为 i = 1，而线程B操作为 i = 2，不管线程如何运行，最终 i 的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。本质上原子性操作指的就是<strong>一组大操作要么就全部执行成功，要么就全部失败</strong>，举个例子：下单：{增加订单，减库存} 那么对于用户来说下单是一个操作，那么系统就必须保证下单操作的原子性，要么就增加订单和减库存全部成功，不存在增加订单成功，减库存失败，那么这个例子从宏观上来就就是一个原子性操作，非原子性操作反之，<strong>线程安全问题产生的根本原因也是由于多线程情况下对一个共享资源进行非原子性操作导致的。</strong><br>但是有个点在我们深入研究Java的并发编程以及在研究可见性之前时需要注意的，就是计算机在程序执行的时候对它的优化操作 — 指令重排。计算机在执行程序时，为了提高性能，编译器和处理器的常常会对指令做重排，一般分以下3种：<br><img src="https://img-blog.csdnimg.cn/img_convert/d4bb9789fb61115f837a670b58ce4687.png" alt="img"></p><p><strong>编译器优化的重排</strong>： 编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br><strong>指令并行的重排</strong>： 现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。<br><strong>内存系统的重排</strong>： 由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。<br>其中编译器优化的重排属于编译期重排，指令并行的重排和内存系统的重排属于处理器重排，在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题，下面分别阐明这两种重排优化可能带来的问题。</p><h4 id="编译器优化指令重排"><a href="#编译器优化指令重排" class="headerlink" title="编译器优化指令重排"></a>编译器优化指令重排</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程A                   线程B</span></span><br><span class="line">代码<span class="number">1</span>：<span class="keyword">int</span> x = a;         代码<span class="number">3</span>：<span class="keyword">int</span> y = b;</span><br><span class="line">代码<span class="number">2</span>：b = <span class="number">1</span>;             代码<span class="number">4</span>：a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>此时有4行代码1、2、3、4，其中1、2属于线程A，其中3、4属于线程B，两个线程同时执行，从程序的执行上来看由于并行执行的原因最终的结果 x = 0;y=0; 本质上是不会出现 x = 2;y = 1; 这种结果，但是实际上来说这种情况是有概率出现的，<strong>因为编译器一般会对一些代码前后不影响、耦合度为0的代码行进行编译器优化的指令重排</strong>，假设此时编译器对这段代码指令重排优化之后，可能会出现如下情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//线程A                   线程B</span></span><br><span class="line">代码<span class="number">2</span>：b = <span class="number">1</span>;         代码<span class="number">4</span>：a = <span class="number">2</span>;</span><br><span class="line">代码<span class="number">1</span>：<span class="keyword">int</span> x = a;     代码<span class="number">3</span>：<span class="keyword">int</span> y = b;   </span><br></pre></td></tr></table></figure><p>这种情况下再结合之前的<strong>线程安全</strong>问题一起理解，那么就可能出现 x = 2;y = 1; 这种结果，这也就说明在多线程环境下，由于编译器会对代码做指令重排的优化的操作（因为一般代码都是由上往下执行，指令重排是OS对单线程运行的优化），最终导致在多线程环境下时多个线程使用变量能否保证一致性是无法确定的。</p><h4 id="处理器指令重排"><a href="#处理器指令重排" class="headerlink" title="处理器指令重排"></a>处理器指令重排</h4><p>先了解一下指令重排的概念，处理器指令重排是对CPU的性能优化，从指令的执行角度来说一条指令可以分为多个步骤完成，如下：<br>·取指：IF<br>译码和取寄存器操作数：ID<br>执行或者有效地址计算：EX<br>存储器访问：MEM<br>写回：WB<br>CPU在工作时，需要将上述指令分为多个步骤依次执行(注意硬件不同有可能不一样),由于每一个步会使用到不同的硬件操作，比如取指时会只有PC寄存器和存储器，译码时会执行到指令寄存器组，执行时会执行ALU(算术逻辑单元)、写回时使用到寄存器组。为了提高硬件利用率，CPU指令是按流水线技术来执行的，如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f00aa059805e38d8a3137763fe2a2859.png" alt="img"></p><p>流水线技术：类似于工厂中的生产流水线，工人们各司其职，做完自己的就往后面传，然后开始一个新的，做完了再往后面传递…..而指令执行也是一样的，如果等到一条指令执行完毕之后再开始下一条的执行，就好比工厂的生产流水线，先等到一个产品生产完毕之后再开始下一个，效率非常低下并且浪费人工，这样一条流水线上同时只会有一个工人在做事，其他的看着，只有当这个产品走了最后一个人手上了并且最后一个工人完成了组装之后第一个工人再开始第二个产品的工作）<br>从图中可以看出当指令1还未执行完成时，第2条指令便利用空闲的硬件开始执行，这样做是有好处的，如果每个步骤花费1ms，那么如果第2条指令需要等待第1条指令执行完成后再执行的话，则需要等待5ms，但如果使用流水线技术的话，指令2只需等待1ms就可以开始执行了，这样就能大大提升CPU的执行性能。虽然流水线技术可以大大提升CPU的性能，但不幸的是一旦出现流水中断，所有硬件设备将会进入一轮停顿期，当再次弥补中断点可能需要几个周期，这样性能损失也会很大，就好比工厂组装手机的流水线，一旦某个零件组装中断，那么该零件往后的工人都有可能进入一轮或者几轮等待组装零件的过程。因此我们需要尽量阻止指令中断的情况，指令重排就是其中一种优化中断的手段，我们通过一个例子来阐明指令重排是如何阻止流水线技术中断的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = a + b;</span><br><span class="line">y = c - d;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/5bd28e4575906a985e7e770985cc0813.png" alt="img"></p><p>LW R1,a             LW指令表示 load，其中LW R1,a表示把a的值加载到寄存器R1中<br>LW R2,b             表示把b的值加载到寄存器R2中<br>ADD R3,R1,R2   ADD指令表示加法，把R1 、R2的值相加，并存入R3寄存器中。<br>SW i,R3              SW表示 store 即将 R3寄存器的值保持到变量i中<br>LW R4,c             表示把c的值加载到寄存器R4中<br>LW R5,d             表示把d的值加载到寄存器R5中<br>SUB R6,R4,R5   SUB指令表示减法，把R4 、R5的值相减，并存入R6寄存器中。<br>SW y,R6             表示将R6寄存器的值保持到变量y中<br>上述便是汇编指令的执行过程，在某些指令上存在X的标志，X代表中断的含义，也就是只要有X的地方就会导致指令流水线技术停顿，同时也会影响后续指令的执行，可能需要经过1个或几个指令周期才可能恢复正常，那为什么停顿呢？这是因为部分数据还没准备好，如执行ADD指令时，需要使用到前面指令的数据R1，R2，而此时R2的MEM操作没有完成，即未拷贝到存储器中，这样加法计算就无法进行，必须等到MEM操作完成后才能执行，也就因此而停顿了，其他指令也是类似的情况。前面讲过，停顿会造成CPU性能下降，因此我们应该想办法消除这些停顿，这时就需要使用到指令重排了，如下图，既然ADD指令需要等待，那我们就利用等待的时间做些别的事情，如把LW R4,c 和 LW R5,d 移动到前面执行，毕竟LW R4,c 和 LW R5,d执行并没有数据依赖关系，对他们有数据依赖关系的SUB R6,R5,R4指令在R4,R5加载完成后才执行的，没有影响，过程如下：<img src="https://img-blog.csdnimg.cn/img_convert/e09a3c520bce6cf8d7c42a47aba8f30a.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/33e39ee9eb1cdcc4efbc8e09a528f5cc.png" alt="img"></p><p>正如上图所示，所有的停顿都完美消除了，指令流水线也无需中断了，这样CPU的性能也能带来很好的提升，这就是处理器指令重排的作用。关于编译器重排以及指令重排(这两种重排我们后面统一称为指令重排)相关内容已阐述清晰了，我们必须意识到对于单线程而已指令重排几乎不会带来任何影响，比竟重排的前提是保证串行语义执行的一致性，但对于多线程环境而已，指令重排就可能导致严重的程序轮序执行问题，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> f = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        f = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = a + <span class="number">1</span>；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如上述代码，同时存在线程A和线程B对该实例对象进行操作，其中A线程调用methodA方法，而B线程调用methodB方法，由于指令重排等原因，可能导致程序执行顺序变为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">线程A                      线程B</span><br><span class="line"> methodA：                methodB：</span><br><span class="line"> 代码<span class="number">1</span>:f= <span class="keyword">true</span>;           代码<span class="number">1</span>:f= <span class="keyword">true</span>;</span><br><span class="line"> 代码<span class="number">2</span>:a = <span class="number">1</span>;             代码<span class="number">2</span>: a = <span class="number">0</span> ; <span class="comment">//读取到了未更新的a</span></span><br><span class="line">                          代码<span class="number">3</span>: i =  a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>由于指令重排的原因，线程A的f置为true被提前执行了，而线程A还在执行a=1，此时因为f=true了，所以线程B正好读取f的值为true，直接获取a的值，而此时线程A还在自己的工作内存中对当中拷贝过来的变量副本a进行赋值操作，结果还未刷写到主存，那么此时线程B读取到的a值还是为0，那么拷贝到线程B工作内存的a=0；然后并在自己的工作内存中执行了 i = a + 1操作，而此时线程B因为处理器的指令重排原因读取a是为0的，导致最终 i 结果的值为1，而不是预期的2，这就是多线程环境下，指令重排导致的程序乱序执行的结果。因此，请记住，指令重排只会保证单线程中串行语义的执行的一致性，能够在单线程环境下通过指令重排优化程序，消除CPU停顿，但是并不会关心多线程间的语义一致性。</p><h3 id="3-2-可见性"><a href="#3-2-可见性" class="headerlink" title="3.2 可见性"></a>3.2 可见性</h3><p>经过前面的阐述，如果真正理解了指令重排现象之后的小伙伴再来理解可见性容易了，可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改过的新值。但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量 i 的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量 i 进行操作，但此时A线程工作内存中共享变量 i 对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程序轮序执行的问题，从而也就导致可见性问题。</p><h3 id="3-3-有序性"><a href="#3-3-有序性" class="headerlink" title="3.3 有序性"></a>3.3 有序性</h3><p>有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样的理解如果是放在单线程环境下没有问题，毕竟对于单线程而言确实如此，代码由编码的顺序从上往下执行，但对于多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。</p><h2 id="4-如何解决JMM特性问题"><a href="#4-如何解决JMM特性问题" class="headerlink" title="4. 如何解决JMM特性问题"></a>4. 如何解决JMM特性问题</h2><p>对于原子性引起的安全问题，除了jvm提供的原子类型数据外，方法级或代码块级的，可以用synchronized关键字或者Lock锁接口的方法，来进行保证原子性；对于工作内存与主内存同步延迟现象导致的可见性问题，可以使用加锁或者Volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。对于指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化，关于volatile稍后会进一步分析。除了靠sychronized和volatile关键字（volatile关键字不能保证原子性，只能保证的是禁止指令重排与可见性问题）来保证原子性、可见性以及有序性外，JMM内部还定义一套happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性。</p><h3 id="4-1-as-if-serial"><a href="#4-1-as-if-serial" class="headerlink" title="4.1  as-if-serial"></a>4.1  as-if-serial</h3><p>　定义：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。所以编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">// A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> r = <span class="number">1.0</span>; <span class="comment">// B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> area = pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/e7493b8c85636f2270a5503f7254ce26.png" alt="img"></p><p> A和C、B和C都不存在数据的依赖，因此A和C、B和C不会进行重排，而A和B之间不存在数据的依赖，因此，以上执行顺序存在两种情形：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d0a886a1950ff09f7ce2326ea5db40a1.png" alt="img"></p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。</p><h3 id="4-2-Happens-Before"><a href="#4-2-Happens-Before" class="headerlink" title="4.2  Happens-Before"></a>4.2  Happens-Before</h3><p>从jdk5开始，java使用新的JSR-133内存模型，基于Happens-Before的概念来阐述操作之间的内存可见性。</p><p>定义：</p><p>如果一个操作Happens-Before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。<br>两个操作之间存在Happens-Before关系，并不意味着一定要按照Happens-Before原则制定的顺序来执行。如果重排序之后的执行结果与按照Happens-Before关系来执行的结果一致，那么这种重排序并不非法。<br>Happens-Before规则：</p><p>　　Happens-Before的八个规则（摘自《深入理解Java虚拟机》12.3.6章节）：</p><ol><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>管程锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；（此处后面指时间的先后）</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；（此处后面指时间的先后）</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li><li>传递性：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li></ol><h1 id="volatile-VS-synchronized"><a href="#volatile-VS-synchronized" class="headerlink" title="volatile VS synchronized"></a>volatile VS synchronized</h1><h2 id="2-1-volatile"><a href="#2-1-volatile" class="headerlink" title="2.1 volatile"></a>2.1 volatile</h2><h3 id="2-1-1-定义"><a href="#2-1-1-定义" class="headerlink" title="2.1.1 定义"></a>2.1.1 定义</h3><p>volatile用来修饰成员变量（静态变量和实例变量），被修饰的变量在被修改时能够保证每个线程获取该变量的最新值，从而避免出现数据脏读的现象，也就是我们说的保证数据的可见性。</p><h3 id="2-1-2-实现原理"><a href="#2-1-2-实现原理" class="headerlink" title="2.1.2 实现原理"></a>2.1.2 实现原理</h3><p>　在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送这一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。因此，volatile修饰的变量具有以下的特点：</p><ol><li>Lock前缀的指令会引起处理器缓存写回内存；</li><li>一个处理器的缓存回写到内存会导致其他处理器的缓存失效；</li><li>当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</li></ol><p>volatile可见性测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatitle可见性测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisibilityTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; start.....&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; loop end....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VisibilityTest test = <span class="keyword">new</span> VisibilityTest();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(test);</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        test.i = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + test.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对 i 变量不加volatile修饰，会发现这段代码可能会出现一直死循环，永不退出的情况。</p><h3 id="2-1-3-volatile的有序性"><a href="#2-1-3-volatile的有序性" class="headerlink" title="2.1.3 volatile的有序性"></a>2.1.3 volatile的有序性</h3><p>volatile的有序性是通过禁止指令重排来实现的。为了性能，在JMM中，在不影响正确语义的情况下，允许编译器和处理器对指令序列进行重排序。而禁止指令重排底层是通过设置内存屏障来实现。</p><p>JMM内存屏障分为四类：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4774036a5d5e2671094cd420d75f9e02.png" alt="img"></p><p>java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/50f32c1b1ceeca8b3b182eb70177f4cf.png" alt="img"></p><p>“NO”表示禁止重排序。为了实现volatile内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM采取了保守策略：</p><ol><li>在每个volatile写操作的前面插入一个StoreStore屏障；</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障；</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障；</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ol><p>需要注意的是：volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障</p><p>StoreStore屏障：禁止上面的普通写和下面的volatile写重排序；</p><p>StoreLoad屏障：防止上面的volatile写与下面可能有的volatile读/写重排序</p><p>LoadLoad屏障：禁止下面所有的普通读操作和上面的volatile读重排序</p><p>LoadStore屏障：禁止下面所有的普通写操作和上面的volatile读重排序<img src="https://img-blog.csdnimg.cn/img_convert/55b94a5f72bbfe840e2a47322b0d00cc.png" alt="img"></p><p> <img src="https://img-blog.csdnimg.cn/img_convert/ff2a17a88b18ad7b1d2309f520ab525f.png" alt="img"></p><h2 id="2-2-synchronized"><a href="#2-2-synchronized" class="headerlink" title="2.2  synchronized"></a>2.2  synchronized</h2><p>synchronized作为java关键字，可以用来修饰方法和代码块，修饰常规方法和代码块中this属于对象锁，修饰静态方法和代码块中Object.class属于类锁。</p><h3 id="2-2-1-synchronized的可见性"><a href="#2-2-1-synchronized的可见性" class="headerlink" title="2.2.1 synchronized的可见性"></a>2.2.1 synchronized的可见性</h3><p>JMM关于synchronized的两条规定：</p><p>　　1）线程解锁前，必须把共享变量的最新值刷新到主内存中</p><p>　　2）线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值</p><p>　　　（注意：加锁与解锁需要是同一把锁）</p><p> 线程A和B竞争锁资源，线程A先拿到锁进入方法修改共享变量，在解锁前会将当前工作内存的变量写会主内存，然后释放锁资源；线程B在获取锁后，会清空当前工作内存，重新从主内存中拷贝变量副本，从而实现可见性。</p><h3 id="2-2-2-synchronized的原子性"><a href="#2-2-2-synchronized的原子性" class="headerlink" title="2.2.2  synchronized的原子性"></a>2.2.2  synchronized的原子性</h3><p>原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束。synchronized底层由于采用了字节码指令monitorenter和monitorexit来隐式地使用这lock和unlock两个操作，使得其操作具有原子性。</p><h3 id="2-2-3-synchronized的有序性"><a href="#2-2-3-synchronized的有序性" class="headerlink" title="2.2.3  synchronized的有序性"></a>2.2.3  synchronized的有序性</h3><p>根据前面也知道，volatile的有序性表现在禁止指令重排。而synchronized有序性表现在as-if-serial语义，但as-if-serial语义不能确保多线程情况下的禁止指令重排。如单例中的双重检验锁写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckSingleton singleton = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;<span class="comment">// 第一重判断，实例为空，才允许进入获取锁资源，避免进入锁，减少性能消耗</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleton.class)&#123; <span class="comment">//利用锁的互斥性，每次只允许单线程进入创建实例</span></span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="keyword">null</span>)&#123;<span class="comment">//第二重判断，防止被实例化多次</span></span><br><span class="line">                    singleton = <span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">先看看这个 singleton = <span class="keyword">new</span> DoubleCheckSingleton()实际上是分三步：<span class="number">1</span>、在堆中分配内存；<span class="number">2</span>、调用构造器创建实例；<span class="number">3</span>、将当前引用指向该实例的内存，以上三步完成，这个实例就创建完毕，但由于编译器和处理器的指令重排，导致在多线程情况下，<span class="number">2</span>和<span class="number">3</span>会调换位置，从而产生性能问题。</span><br><span class="line">所以为禁止指令重排，在实例变量中引入<span class="keyword">volatile</span>进行修饰。</span><br><span class="line"> </span><br><span class="line">我们知道，<span class="keyword">synchronized</span>能使得线程像单线程的as-<span class="keyword">if</span>-serial语义一样，而步骤<span class="number">2</span>和<span class="number">3</span>之间是不存在依赖关系的，所以虽然遵循了as-<span class="keyword">if</span>-serial语义，<span class="number">2</span>和<span class="number">3</span>仍然存在指令重排现象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="JVM" scheme="http://ppnostalgia.github.io./categories/JVM/"/>
    
    
    <category term="JVM" scheme="http://ppnostalgia.github.io./tags/JVM/"/>
    
    <category term="JMM" scheme="http://ppnostalgia.github.io./tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统之网关</title>
    <link href="http://ppnostalgia.github.io./e229fb0a.html"/>
    <id>http://ppnostalgia.github.io./e229fb0a.html</id>
    <published>2022-05-31T13:09:34.000Z</published>
    <updated>2022-06-20T13:26:36.024Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>​    分布式系统的设计大体上分为中心化和非中心化，像现在流行的微服务模式，本质上是把各种业务拆分为独立的进程来实现业务的扩展性。伴随着业务的不断被拆分，整体的系统性能也有所提高，但是系统又往往面临着中心化的需求，这个世界就是这么有趣，我们不但要非中心化的优势，还要保证<strong>中心化的优势</strong>。</p><p>​    说到非中心化需求，最简单最常见的就是鉴权，简单来说就是判断用户是否有执行某种动作的权限。以鉴权为例，当有N个微服务有同样的鉴权需求的时候，有以下几种解决方案：</p><p>每个服务自己实现一遍写一个公共的服务接口，每个服务都调用这个接口写到统一的流量入口处，只需要实现一次有人说第一种方案没人用，是吗？在服务数量不是太多的情况下，据我所知有很多公司初期都是每个服务都实现自己的鉴权，不要说这种做法一无是处，首先在各个团队技术栈不同的情况下，这是一个团队可以快速实现功能的一种解决方案，而且不依赖于任何其他服务，这意味着这个服务不会受到别的服务的影响，这体现的是非中心化最核心的价值之一。</p><p>至于第二种解决方案是典型的集中式处理的方案之一，他按照业务功能把鉴权独立成单独的服务，所有使用鉴权服务的系统都依赖于这个服务，所以这个统一的鉴权服务需要保证高可用，而且对性能比较敏感，稍有不慎，流量高峰就有可能对整个系统造成致命打击。但是，还是有不少公司在用这种架构模式，你说奇怪不奇怪，正所谓，存在即合理。</p><p>至于第三种使用网关模式，可以说是目前市面上文章吹捧最多的解决方案。当然得到广大程序员的吹捧自然有它的优势，但是请记住，它并非没有劣势。</p><p><img src="https://pics1.baidu.com/feed/0b7b02087bf40ad15fec590547923dd7a8ecce16.jpeg?token=0bbc2515e9a3f10e4088778794415903&amp;s=5B843C62354BD147505574CE0000E0B2" alt="img"></p><p>从上图清晰的可以看到，来自于客户端的所有流量都经过网关，所以理论上来讲，所有统一化的需求都可以在网关进行实现，这样每个后端的业务服务代码都不会有任何的侵入性。至于这些需求最常见的有：</p><ol><li>网关可以<strong>屏蔽后端服务的协议细节</strong>，比如有的服务可能采用的rpc方式，有的服务采用的restful方式，有的甚至可能采用的比较古老的web Service，在网关这一层我们可以统一通信协议，这样客户端调用起来会方便很多。</li><li>可以统一整个系统的认证和授权功能，甚至可以统一不同的客户端采用的不同认证方式，比如Cookie认证，Session认证等。</li><li><p>可以统一设置后端服务的保护策略，比如：不同的服务可以设置不同的白名单系统，不同的服务可以采用不同的限流策略等。在网关这个统一的入口，更容易做日志的收集工作。虽然网关很香，但是一旦整个系统引入网关，就会随之带来一些问题：</p></li><li><p>增加了网关，在请求的整个过程中就至少多了一层转发，性能会有稍微下降。网关如果出现问题，将造成整个系统不稳定，甚至down机，这就是网关的单点问题。所以一般网关都会有多个节点。</p></li></ol><h1 id="二、引入网关"><a href="#二、引入网关" class="headerlink" title="二、引入网关"></a>二、引入网关</h1><p>在没有网关的时候，系统一般都会有一个无状态的web层，这一层的主要作用是根据业务组织后端服务结果来响应客户端的请求，例如：一个订单详情的请求，web层会同时请求订单服务来查询订单信息，请求用户服务来查询下单人信息，请求商户服务来查询商家信息，然后把这些信息组合成客户端想要的数据格式，然后返回客户端数据。</p><p><img src="https://pics2.baidu.com/feed/d1160924ab18972bd463913af67357819f510a2e.jpeg?token=82e53775313af6be2b11721044dc40e7&amp;s=5B843C6235CBC1474C5570CE0000E0B1" alt="img"></p><p>如果做鉴权，限流等操作，同样也是做在这个web层，在引入了网关之后，这个web层到底还要不要呢？不同的公司有不同的做法，不过我还是建议保留web层，用它来做服务的聚合层，这样整体架构就变成了这样</p><p><img src="https://pics2.baidu.com/feed/35a85edf8db1cb133ae8f968cdea7a4693584b0a.jpeg?token=4149269b5188baea45ca42b8c9ae9957&amp;s=39AC7C321953C5CE464931DA0000D0B1" alt="img"></p><h1 id="三、比较"><a href="#三、比较" class="headerlink" title="三、比较"></a>三、比较</h1><h2 id="3-1-网关和负载均衡"><a href="#3-1-网关和负载均衡" class="headerlink" title="3.1 网关和负载均衡"></a>3.1 网关和负载均衡</h2><p>通过以上阐述可以看到，网关在部署架构上和负载均衡器很像，但是它们其实是两种东西。虽然它们都会承载统一的入口流量，但是负载均衡器只是单纯地对请求的转发，而网关除了对请求的转发之外，更重要的职责是统一的业务处理，就像鉴权，限流，降级等。</p><p>所以从功能角度来说，网关几乎可以代替负载均衡器。</p><h2 id="3-2-常用网关对比"><a href="#3-2-常用网关对比" class="headerlink" title="3.2 常用网关对比"></a>3.2 常用网关对比</h2><ul><li><p>Zuul1的开源时间很早，Netflix、Riot、携程、拍拍贷等公司都已经在生产环境中使用，自身经受了实践考验，是生产级的API网关产品。</p></li><li><p>Gateway在2019年离开Spring Cloud孵化器，应用于生产的案例少，稳定性有待考证。</p></li></ul><p>  从性能方面比较，两种产品在流量小的场景下性能表现差不多；并发高的场景下Gateway性能要好很多。从开发方面比较，Zuul1编程模型简单，易于扩展；Gateway编程模型稍难，代码阅读难度要比Zuul高不少，扩展也稍复杂一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="微服务" scheme="http://ppnostalgia.github.io./categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="GateWay" scheme="http://ppnostalgia.github.io./tags/GateWay/"/>
    
  </entry>
  
  <entry>
    <title>常见注册中心</title>
    <link href="http://ppnostalgia.github.io./3f64b58a.html"/>
    <id>http://ppnostalgia.github.io./3f64b58a.html</id>
    <published>2022-05-25T00:52:34.000Z</published>
    <updated>2022-06-20T13:26:36.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​    随着数据量的增大，单一的服务器已经不能应对大量的用户服务调用。需要进行服务器扩容，多部署几个实例，那么问题来了，用户进行服务调用的时候该调用哪一个实例？</p><h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><p><img src="https://s2.loli.net/2022/05/25/9PxRkaQ5py8wDCo.png" alt="image-20220525090003237"></p><p>​    往往解决这类分布式问题都需要一块公共的区域（注册中心）来保存这些信息。常见的注册中心方案有ZooKeeper、Eureka、Nacos等。注册中心的基本流程如下：</p><ul><li>每个服务提供者启动时，将服务的信息(ip+port)写入公共区域</li><li>调用者订阅感兴趣的服务实例，通过注册中心获取服务实例信息列表后缓存在自己本地</li><li>服务消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从IP列表中取一个服务提供者的服务器调用服务。</li><li>服务实例停止或者 down 调后将公共区域自己的信息清除掉;</li><li>公共区域通知调用者你感兴趣的信息已经发生变更，请更新一下本地的缓存。</li></ul><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">官网</a></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><p><strong>服务发现和服务健康监测</strong></p></li><li><p><strong>动态配置服务</strong></p><p>消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</p></li><li><p><strong>动态 DNS 服务</strong></p></li><li><p><strong>服务及其元数据管理</strong></p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/25574784/1650771676187-d95a9e45-8656-4d1a-8b5b-ed63a23a816b.png" alt="nacos_sdk_class_relation"></p><h2 id="java-sdk"><a href="#java-sdk" class="headerlink" title="java sdk"></a>java sdk</h2><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getConfig</span><span class="params">(String dataId, String group, <span class="keyword">long</span> timeoutMs)</span> <span class="keyword">throws</span> NacosException</span></span><br><span class="line"><span class="function"><span class="comment">//监听配置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(String dataId, String group, Listener listener)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//删除监听</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeListener</span><span class="params">(String dataId, String group, Listener listener)</span></span></span><br><span class="line"><span class="function"><span class="comment">//发布配置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">publishConfig</span><span class="params">(String dataId, String group, String content, String type)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"><span class="comment">//删除配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeConfig</span><span class="params">(String dataId, String group)</span> <span class="keyword">throws</span> NacosException</span></span><br></pre></td></tr></table></figure><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, String ip, <span class="keyword">int</span> port, String clusterName)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerInstance</span><span class="params">(String serviceName, Instance instance)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line">NamingService naming = NamingFactory.createNamingService(System.getProperty(<span class="string">&quot;serveAddr&quot;</span>));</span><br><span class="line">naming.registerInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;11.11.11.11&quot;</span>, <span class="number">8888</span>, <span class="string">&quot;TEST1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注销实例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregisterInstance</span><span class="params">(String serviceName, String ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deregisterInstance</span><span class="params">(String serviceName, String ip, <span class="keyword">int</span> port, String clusterName)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line">NamingService naming = NamingFactory.createNamingService(System.getProperty(<span class="string">&quot;serveAddr&quot;</span>));</span><br><span class="line">naming.deregisterInstance(<span class="string">&quot;nacos.test.3&quot;</span>, <span class="string">&quot;11.11.11.11&quot;</span>, <span class="number">8888</span>, <span class="string">&quot;DEFAULT&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取服务下全部实例</span></span><br><span class="line"><span class="function">List&lt;Instance&gt; <span class="title">getAllInstances</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Instance&gt; <span class="title">getAllInstances</span><span class="params">(String serviceName, List&lt;String&gt; clusters)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取健康或不健康实例列表</span></span><br><span class="line"><span class="function">List&lt;Instance&gt; <span class="title">selectInstances</span><span class="params">(String serviceName, <span class="keyword">boolean</span> healthy)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;Instance&gt; <span class="title">selectInstances</span><span class="params">(String serviceName, List&lt;String&gt; clusters, <span class="keyword">boolean</span> healthy)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个健康实例</span></span><br><span class="line"><span class="function">Instance <span class="title">selectOneHealthyInstance</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Instance <span class="title">selectOneHealthyInstance</span><span class="params">(String serviceName, List&lt;String&gt; clusters)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String serviceName, EventListener listener)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String serviceName, List&lt;String&gt; clusters, EventListener listener)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line">NamingService naming = NamingFactory.createNamingService(System.getProperty(<span class="string">&quot;serveAddr&quot;</span>));</span><br><span class="line">naming.subscribe(<span class="string">&quot;nacos.test.3&quot;</span>, event -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> NamingEvent) &#123;</span><br><span class="line">        System.out.println(((NamingEvent) event).getServceName());</span><br><span class="line">        System.out.println(((NamingEvent) event).getInstances());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消监听服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(String serviceName, EventListener listener)</span> <span class="keyword">throws</span> NacosException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(String serviceName, List&lt;String&gt; clusters, EventListener listener)</span> <span class="keyword">throws</span> NacosException</span>;</span><br></pre></td></tr></table></figure><h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p><img src="https://s2.loli.net/2022/05/25/7I8vO5AxrGNwm3W.png" alt="在这里插入图片描述"></p><p>nacos和client之间采取推拉结合的交互方式，一方面client可以通过定时任务每隔10s向nacos发起查询请求，如果服务列表改变nacos就会返回新列表，另一方面当本地服务实例发生变化时（即server实例注册成功或者心跳停止断开链接），nacos会主动通过UDP协议推送到client，udp协议非常快，不需要保持长连接。在注册中心的场景中client数量往往多于server，如果每一次服务更新，nacos要和成千上万的服务消费者去建立Tcp的话性能肯定是不行的。而如果UDP通知失败，客户端每10秒还会主动去拉一次，客户端拉取和服务器推送是互补的，这样既能保证server实例更新的时效性，又能提高效率。</p><h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>Zookeeper是一个树状的文件目录结构，。树中每个节点可以称作为一个ZNode，每一个ZNode都可以通过其路径唯一标识，对服务进行注册销毁的过程就是对ZNode进行增删改查的过程</p><p><img src="https://zsrimg.ikafan.com/file_images/article/202107/202107310912315.png" alt="img"></p><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>节点类型分为四种：<strong>持久节点(Persistent)</strong>、<strong>持久有序节点(Persistent_sequential)</strong>、<strong>临时节点(Ephemeral)</strong>、<strong>临时有序节点(Ephemeral_sequential)</strong></p><ul><li>持久与临时的区别在于客户端与服务端断开连接后，所创建的节点是否被删除。临时节点下面不能创建子节点</li><li>在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。<br>在创建节点的时候只需要传入节点 “/test_”，这样之后，zookeeper自动会给”test_”后面补充数字。</li></ul><h2 id="节点监听"><a href="#节点监听" class="headerlink" title="节点监听"></a>节点监听</h2><p>zookeeper提供了“心跳检测”功能，它会定时向各个服务提供者发送一个请求（实际上建立的是一个 socket 长连接），如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除。比如100.100.0.237这台机器如果宕机了，那么zookeeper上的路径就会只剩/HelloWorldService/1.0.0/100.100.0.238:16888。</p><p>服务消费者会去监听相应路径（/HelloWorldService/1.0.0），一旦路径上的数据有任务变化（增加或减少），zookeeper都会通知服务消费方、服务提供者地址列表已经发生改变，从而进行更新。</p><h2 id="工具API：ZkClient"><a href="#工具API：ZkClient" class="headerlink" title="工具API：ZkClient"></a>工具API：ZkClient</h2><p>ZkClient是由Datameer的工程师开发的开源客户端，对Zookeeper的原生API进行了包装，实现了超时重连、Watcher反复注册等功能；目前已经应用到了很多项目中，比如Dubbo、Kafka、Helix。</p><ul><li><p>服务注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registry</span><span class="params">(String serviceName, String serviceAddress)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        zkClient = <span class="keyword">new</span> ZkClient(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建registry节点</span></span><br><span class="line">        String registryAddress = <span class="string">&quot;/services&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!zkClient.exists(registryAddress))&#123;</span><br><span class="line">            zkClient.createPersistent(registryAddress);</span><br><span class="line">            System.out.println(<span class="string">&quot;创建服务注册节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建service节点</span></span><br><span class="line">        String servicePath = registryAddress + <span class="string">&quot;/&quot;</span> + serviceName;</span><br><span class="line">        <span class="keyword">if</span>(!zkClient.exists(servicePath))&#123;</span><br><span class="line">            zkClient.createPersistent(servicePath);</span><br><span class="line">            System.out.println(<span class="string">&quot;创建服务节点，服务名：&quot;</span> + serviceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建address节点（临时）</span></span><br><span class="line">        String addressPath = servicePath + <span class="string">&quot;/address-&quot;</span>;</span><br><span class="line">        String addressNode = zkClient.createEphemeralSequential(addressPath, serviceAddress);</span><br><span class="line">        System.out.println(<span class="string">&quot;创建服务地址节点：&quot;</span> + addressNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkServiceDiscovery</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; addressCache = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ZkClient zkClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">discovery</span><span class="params">(String serviceName)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        zkClient= <span class="keyword">new</span> ZkClient(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String servicePath =  <span class="string">&quot;/services/&quot;</span> + serviceName;</span><br><span class="line">        <span class="keyword">if</span>(!zkClient.exists(servicePath))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;未发现服务节点：&quot;</span> + servicePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String address;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先从本地系统缓存中取</span></span><br><span class="line">        <span class="keyword">if</span>(addressCache.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            address = addressCache.get(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(addressCache.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            address = addressCache.get(ThreadLocalRandom.current().nextInt(addressCache.size()));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//从ZK注册中心中取</span></span><br><span class="line">            List&lt;String&gt; addressList = zkClient.getChildren(servicePath);</span><br><span class="line">            addressCache.clear();</span><br><span class="line">            addressCache.addAll(addressList);</span><br><span class="line"></span><br><span class="line">            zkClient.subscribeChildChanges(servicePath,(parentPath,currentChilds)-&gt;&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;监听服务节点发生变化：&quot;</span> + parentPath);</span><br><span class="line">                addressCache.clear();</span><br><span class="line">                addressCache.addAll(currentChilds);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(CollectionUtils.isEmpty(addressCache))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;未发现有效的服务节点&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(addressList.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                address = addressList.get(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                address = addressList.get(ThreadLocalRandom.current().nextInt(addressList.size()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取实际地址</span></span><br><span class="line">        String addressPath = servicePath + <span class="string">&quot;/&quot;</span> + address;</span><br><span class="line">        String hostAndPort = zkClient.readData(addressPath);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取到实际访问地址：&quot;</span> + hostAndPort);</span><br><span class="line">        zkClient.close();</span><br><span class="line">        <span class="keyword">return</span> hostAndPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String serviceName = <span class="string">&quot;test.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ZkServiceRegistry registry = <span class="keyword">new</span> ZkServiceRegistry();</span><br><span class="line">        registry.registry(serviceName,<span class="string">&quot;192.168.3.1:8080&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        ZkServiceDiscovery zkServiceDiscovery = <span class="keyword">new</span> ZkServiceDiscovery();</span><br><span class="line">        zkServiceDiscovery.discovery(serviceName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p><img src="https://s2.loli.net/2022/06/01/4vw1a7dgX6PDchk.png" alt="image-20220601101922749"></p><p>Eureka 实现服务注册与发现的流程如下：</p><ol><li>搭建一个 Eureka Server 作为服务注册中心；</li><li>服务提供者 Eureka Client 启动时，会把当前服务器的信息以服务名（spring.application.name）的方式注册到服务注册中心；</li><li>服务消费者 Eureka Client 启动时，也会向服务注册中心注册；</li><li>服务消费者还会获取一份可用服务列表，该列表中包含了所有注册到服务注册中心的服务信息（包括服务提供者和自身的信息）；</li><li>在获得了可用服务列表后，服务消费者通过 HTTP 或消息中间件远程调用服务提供者提供的服务。</li></ol><h2 id="搭建注册中心"><a href="#搭建注册中心" class="headerlink" title="搭建注册中心"></a>搭建注册中心</h2><p><strong>搭建 eureka-server</strong></p><p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>server</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>编写启动类</strong></p><p>注意要添加一个 <code>@EnableEurekaServer</code> <strong>注解</strong>，开启 eureka 的<strong>注册中心</strong>功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编写配置文件</strong></p><p>编写一个 application.yml 文件，内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>其中 <code>default-zone</code> 是因为前面配置类开启了注册中心所需要配置的 eureka 的<strong>地址信息</strong>，因为 eureka 本身也是一个微服务，这里也要将自己注册进来，当后面 eureka <strong>集群</strong>时，这里就可以填写多个，使用 “,” 隔开。</p><p>启动完成后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><a href="https://cdn.xn2001.com/img/2021/20210901090945.png"><img src="https://cdn.xn2001.com/img/2021/20210901090945.png" alt="img"></a></p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>将 user-service、order-service 都注册到 eureka</p><p>引入 SpringCloud 为 eureka 提供的 starter 依赖，注意这里是用 <strong>client</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在启动类上添加注解：<code>@EnableEurekaClient</code></p><p>在 application.yml 文件，添加下面的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">      <span class="comment">#name：orderservice</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http:127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>3个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><a href="https://cdn.xn2001.com/img/2021/20210901090958.png"><img src="https://cdn.xn2001.com/img/2021/20210901090958.png" alt="img"></a></p><p>这里另外再补充个小技巧，我们可以通过 idea 的多实例启动，来查看 Eureka 的集群效果。</p><p><a href="https://cdn.xn2001.com/img/2021/20210901091005.png"><img src="https://cdn.xn2001.com/img/2021/20210901091005.png" alt="img"></a></p><p>4个项目启动后，访问 <a href="http://localhost:10086/">http://localhost:10086/</a></p><p><a href="https://cdn.xn2001.com/img/2021/20210901091015.png"><img src="https://cdn.xn2001.com/img/2021/20210901091015.png" alt="img"></a></p><h2 id="服务拉取-Ribbon负载均衡"><a href="#服务拉取-Ribbon负载均衡" class="headerlink" title="服务拉取-Ribbon负载均衡"></a>服务拉取-Ribbon负载均衡</h2><p><img src="https://s2.loli.net/2022/06/01/cTFvjLz91aItXmD.png" alt="image-20220601145529026"></p><blockquote><p>在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</p></blockquote><p>下面我们让 order-service 向 eureka-server 拉取 user-service 的信息，实现服务发现。</p><p>首先给 <code>RestTemplate</code> 这个 Bean 添加一个 <code>@LoadBalanced</code> <strong>注解</strong>，用于开启<strong>负载均衡</strong>。</p><p><strong>标记RestTemplate发起的请求要被Ribbon拦截和处理</strong></p><p><img src="https://s2.loli.net/2022/06/01/wf8Lis5hyZEmH2I.png" alt="image-20220601145849877"></p><p><img src="https://s2.loli.net/2022/06/01/FYydxIQeSWzaGV6.png" alt="image-20220601145936900"></p><p><img src="https://s2.loli.net/2022/06/01/2GA4sBKkJvytZ5w.png" alt="image-20220601150223063"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 OrderService 访问的url路径，用<strong>服务名</strong>代替ip、端口：</p><p><a href="https://cdn.xn2001.com/img/2021/20210901091216.png"><img src="https://cdn.xn2001.com/img/2021/20210901091216.png" alt="img"></a></p><p><img src="https://s2.loli.net/2022/06/01/S3adkyuRTeW1cU8.png" alt="image-20220601150717457"></p><p>SpringCloud Ribbon 底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。</p><p>基本流程如下：</p><ul><li>拦截我们的 <code>RestTemplate</code> 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li><li><code>RibbonLoadBalancerClient</code> 会从请求url中获取服务名称，也就是 user-service</li><li><code>DynamicServerListLoadBalancer</code> 根据 user-service 到 eureka 拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li><code>IRule</code> 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li><code>RibbonLoadBalancerClient</code> 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1，发起真实请求">http://localhost:8081/user/1，发起真实请求</a></li></ul><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><a href="https://cdn.xn2001.com/img/2021/20210901091811.png"><img src="https://cdn.xn2001.com/img/2021/20210901091811.png" alt="img"></a></p><p>不同规则的含义如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>内置负载均衡规则类</strong></th><th style="text-align:left"><strong>规则描述</strong></th></tr></thead><tbody><tr><td style="text-align:left">RoundRobinRule</td><td style="text-align:left">简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td style="text-align:left">AvailabilityFilteringRule</td><td style="text-align:left">对以下两种服务器进行忽略：（1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端设置。</td></tr><tr><td style="text-align:left">WeightedResponseTimeRule</td><td style="text-align:left">为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td style="text-align:left"><strong>ZoneAvoidanceRule</strong></td><td style="text-align:left">以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮询。</td></tr><tr><td style="text-align:left">BestAvailableRule</td><td style="text-align:left">忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td style="text-align:left">RandomRule</td><td style="text-align:left">随机选择一个可用的服务器。</td></tr><tr><td style="text-align:left">RetryRule</td><td style="text-align:left">重试机制的选择逻辑</td></tr></tbody></table></div><p>默认的实现就是 <code>ZoneAvoidanceRule</code>，<strong>是一种轮询方案</strong>。</p><h3 id="自定义负载均衡"><a href="#自定义负载均衡" class="headerlink" title="自定义负载均衡"></a>自定义负载均衡</h3><ol><li>自定义负载均衡策略实现类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定制 Ribbon 负载均衡策略</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRandomRule</span> <span class="keyword">extends</span> <span class="title">AbstractLoadBalancerRule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;            <span class="comment">// 总共被调用的次数，目前要求每台被调用5次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentIndex = <span class="number">0</span>;    <span class="comment">// 当前提供服务的机器号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(ILoadBalancer lb, Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lb == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Server server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取所有有效的服务实例列表</span></span><br><span class="line">            List&lt;Server&gt; upList = lb.getReachableServers();</span><br><span class="line">            <span class="comment">//获取所有的服务实例的列表</span></span><br><span class="line">            List&lt;Server&gt; allList = lb.getAllServers();</span><br><span class="line">            <span class="comment">//如果没有任何的服务实例则返回 null</span></span><br><span class="line">            <span class="keyword">int</span> serverCount = allList.size();</span><br><span class="line">            <span class="keyword">if</span> (serverCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//与随机策略相似，但每个服务实例只有在调用 3 次之后，才会调用其他的服务实例</span></span><br><span class="line">            <span class="keyword">if</span> (total &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                server = upList.get(currentIndex);</span><br><span class="line">                total++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total = <span class="number">0</span>;</span><br><span class="line">                currentIndex++;</span><br><span class="line">                <span class="keyword">if</span> (currentIndex &gt;= upList.size()) &#123;</span><br><span class="line">                    currentIndex = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (server.isAlive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> (server);</span><br><span class="line">            &#125;</span><br><span class="line">            server = <span class="keyword">null</span>;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> choose(getLoadBalancer(), key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initWithNiwsConfig</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRibbonRuleConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义 Ribbon 负载均衡策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyRandomRule(); <span class="comment">//自定义，随机选择某一个微服务，执行五次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>主启动类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="comment">//自定义 Ribbon 负载均衡策略在主启动类上使用 RibbonClient 注解，在该微服务启动时，就能自动去加载我们自定义的 Ribbon 配置类，从而是配置生效</span></span><br><span class="line"><span class="comment">// name 为需要定制负载均衡策略的微服务名称（application name）</span></span><br><span class="line"><span class="comment">// configuration 为定制的负载均衡策略的配置类，</span></span><br><span class="line"><span class="comment">// 且官方文档中明确提出，该配置类不能在 ComponentScan 注解（SpringBootApplication 注解中包含了该注解）下的包或其子包中，即自定义负载均衡配置类不能在 net.biancheng.c 包及其子包下</span></span><br><span class="line"><span class="meta">@RibbonClient(name = &quot;MICROSERVICECLOUDPROVIDERDEPT&quot;, configuration = MySelfRibbonRuleConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MicroServiceCloudConsumerDept80Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MicroServiceCloudConsumerDept80Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，拉取集群地址，所以请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建 LoadBalanceClient，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment"># 项目启动时直接去拉取userservice的集群，多个用&quot;,&quot;隔开</span></span><br></pre></td></tr></table></figure><h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>CAP原则又称CAP定理，指的是在一个分布式系统中，<strong>一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）</strong>，但是CAP 原则指示3个要素<strong>最多只能同时实现两点</strong>，不可能三者兼顾，由于网络硬件肯定会出现延迟丢包等问题，但是在分布式系统中，我们必须保证部分网络通信问题不会导致整个服务器集群瘫痪，另外即使分成了多个区，当网络故障消除的时候，我们依然可以保证数据一致性，所以我们必须保证分区容错性；</p><p>CAP理论提出就是针对分布式数据库环境的，所以，P这个属性是必须具备的。<br>P就是在分布式环境中，由于网络的问题可能导致某个节点和其它节点失去联系，这时候就形成了P(partition)，也就是由于网络问题，将系统的成员隔离成了2个区域，互相无法知道对方的状态，这在分布式环境下是非常常见的。<br>因为P是必须的，那么我们需要选择的就是A和C。<br>大家知道，在分布式环境下，为了保证系统可用性，通常都采取了复制的方式，避免一个节点损坏，导致系统不可用。那么就出现了每个节点上的数据出现了很多个副本的情况，而数据从一个节点复制到另外的节点时需要时间和要求网络畅通的，所以，当P发生时，也就是无法向某个节点复制数据时，这时候你有两个选择：<br>选择可用性 A(Availability)，此时，那个失去联系的节点<strong>依然可以向系统提供服务（可能返回旧值）</strong>，不过它的数据就不能保证是同步的了（失去了C属性）。<br>选择一致性C(Consistency)，为了保证数据库的一致性，我们必须<strong>等待失去联系的节点恢复过来</strong>，在这个过程中，那个节点是不允许对外提供服务的，这时候系统处于不可用状态(失去了A属性)。</p><p>最常见的例子是读写分离，某个节点负责写入数据，然后将数据同步到其它节点，其它节点提供读取的服务，当两个节点出现通信问题时，你就面临着选择A（继续提供服务，但是数据不保证准确），C（用户处于等待状态，一直等到数据同步完成）。</p><h2 id="注册中心区别"><a href="#注册中心区别" class="headerlink" title="注册中心区别"></a>注册中心区别</h2><p>作为服务发现产品，可用性AP优先级较高，一致性的特点并不重要，宁可返回错误的数据，也比不反回结果要好得多。</p><ul><li><p>Zookeeper采⽤CP保证数据的⼀致性的问题，原理是采⽤ZAB原⼦⼴播协议。<br>当我们ZK领导者宕机或出现了故障，会⾃动重新实现选举新的领导⾓⾊，整个选举的过程中为了保证数据⼀致性的问题，整个微服务⽆法实现通讯（本地有缓存除外）。还有可运⾏的节点必须满⾜过半机制，整个zk才可以使⽤，要不然会奔溃。</p></li><li><p>Eureka采⽤AP设计理念架构注册中⼼，<strong>相互注册</strong>（你中有我，我中有你），完全去中⼼化，也就是没有主从之分，只要有⼀台Eureka节点存在整个微服务就可以实现通讯。</p></li><li><p>Nacos从1.0版本选择Ap和CP混合形式实现注册中⼼，默认情况下采⽤Ap保证服务可⽤性，CP形式底层采⽤Raft协议保证数据的⼀致性问题。如果选择为Ap模式，注册服务的实例仅⽀持临时模式，在⽹络分区的的情况允许注册服务实例。选择CP模式可以⽀持注册服务的实例为持久模式，在⽹络分区的产⽣了抖动情况下不允许注册服务实例。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="微服务" scheme="http://ppnostalgia.github.io./categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="Nacos" scheme="http://ppnostalgia.github.io./tags/Nacos/"/>
    
    <category term="ZooKeeper" scheme="http://ppnostalgia.github.io./tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Netty学习笔记</title>
    <link href="http://ppnostalgia.github.io./a3e6723a.html"/>
    <id>http://ppnostalgia.github.io./a3e6723a.html</id>
    <published>2022-03-30T02:01:34.000Z</published>
    <updated>2022-09-15T06:19:55.609Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NIO基础"><a href="#NIO基础" class="headerlink" title="NIO基础"></a>NIO基础</h1><p>non-blocking io  非阻塞IO</p><h2 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1. 三大组件"></a>1. 三大组件</h2><h3 id="1-1-Channel-amp-Buffer"><a href="#1-1-Channel-amp-Buffer" class="headerlink" title="1.1 Channel &amp; Buffer"></a>1.1 Channel &amp; Buffer</h3><p>channel: </p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li></ul><p>buffer：输入数据，临时存储在内存中，buffer就是暂存数据的缓存区。</p><p><strong>常见的Channel有以下四种</strong>，其中FileChannel主要用于文件传输，其余三种用于网络通信</p><ul><li>FileChannel</li><li>DatagramChannel(UDP)</li><li>SocketChannel（TCP）</li><li>ServerSocketChannel</li></ul><p><strong>Buffer有以下几种</strong>，其中使用较多的是ByteBuffer</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h3 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a>1.2 Selector</h3><p>在使用Selector之前，处理socket连接还有以下两种方法</p><p><strong>使用多线程技术</strong></p><p>为每个连接分别开辟一个线程，分别去处理对应的socket连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181918.png"><img src="https://s2.loli.net/2022/03/30/138TokbNFZmsDQx.png" alt="img"></a></p><p>这种方法存在以下几个问题</p><ul><li>内存占用高<ul><li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li></ul></li><li>线程上下文切换成本高</li><li>只适合连接数少的场景<ul><li>连接数过多，会导致创建很多线程，从而出现问题</li></ul></li></ul><p><strong>使用线程池技术</strong></p><p>使用线程池，让线程池中的线程去处理连接</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181933.png"><img src="https://s2.loli.net/2022/03/30/zMuDPFeq4HdBcCT.png" alt="img"></a></p><ul><li>阻塞模式下，线程仅能处理一个连接<ul><li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li><li>若socket连接一直未断开，则其对应的线程无法处理其他socket连接</li></ul></li><li>仅适合短连接场景<ul><li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li></ul></li></ul><p><strong>使用选择器</strong></p><p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个channel中没有执行任务时，可以去执行其他channel中的任务（轮询，不会空闲）。</p><p>serversocketchannel处理完accept事件之后，selector使线程继续处理其他socketchannel感兴趣的read、write事件等。</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418181947.png"><img src="https://s2.loli.net/2022/03/30/qjZgVmA4cnItk6f.png" alt="img"></a></p><p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理</p><p>适合连接数多，但流量较少的场景</p><p>若有某个通道流量大，线程会一直处理这个通道，所以适合流量较少的场景</p><h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//FileChannel</span></span><br><span class="line">        <span class="comment">//1. 输入输出流 2.RandomAccessFile</span></span><br><span class="line">        <span class="keyword">try</span>(FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;E:\\Practice\\JavaStudyTest\\1.txt&quot;</span>).getChannel())&#123;</span><br><span class="line">            <span class="comment">//获取缓冲区</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">20</span>);</span><br><span class="line">            <span class="comment">//读取数据,向buffer写入</span></span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            <span class="comment">//打印buffer内容</span></span><br><span class="line">            <span class="comment">//切换buffer读写模式</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">//无参：读一个字节</span></span><br><span class="line">            <span class="keyword">while</span>(buffer.hasRemaining())&#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1. 使用方式"></a>1. 使用方式</h4><ul><li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p></li><li><p>调用 flip() 切换至</p><p>读模式</p><ul><li><strong>flip会使得buffer中的limit变为position，position变为0</strong></li></ul></li><li><p>从 buffer 读取数据，例如调用 buffer.get()</p></li><li><p>调用 clear() 或者compact()切换至</p><p>写模式</p><ul><li>调用clear()方法时<strong>position=0，limit变为capacity</strong></li><li>调用compact()方法时，<strong>会将缓冲区中的未读数据压缩到缓冲区前面</strong></li></ul></li><li><p>重复以上步骤</p></li></ul><p><strong>使用ByteBuffer读取文件中的内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得FileChannel</span></span><br><span class="line">        <span class="keyword">try</span> (FileChannel channel = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;stu.txt&quot;</span>).getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 获得缓冲区</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">int</span> hasNext = <span class="number">0</span>;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span>((hasNext = channel.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 切换模式 limit=position, position=0</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// 当buffer中还有数据时，获取其中的数据</span></span><br><span class="line">                <span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">                    builder.append((<span class="keyword">char</span>)buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换模式 position=0, limit=capacity</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(builder.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-结构"><a href="#2-结构" class="headerlink" title="2. 结构"></a>2. 结构</h4><p>字节缓冲区的父类Buffer中有几个核心属性，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure><ul><li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li><li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li><li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li><li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li></ul><p><img src="https://s2.loli.net/2022/03/30/fRM8jYFvoKe3pyT.png" alt="image-20220330142341124"></p><p>以上四个属性必须满足以下要求</p><p><strong>mark &lt;= position &lt;= limit &lt;= capacity</strong></p><p><img src="https://s2.loli.net/2022/03/30/dzsC2MrhXYG8Iep.png" alt="image-20220330142618016"></p><h4 id="3-方法调用及展示"><a href="#3-方法调用及展示" class="headerlink" title="3. 方法调用及展示"></a>3. 方法调用及展示</h4><p>ByteBuffer调试工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.MathUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.StringUtil;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.internal.MathUtil.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Panwen Chen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/12 15:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> String[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> String[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> String[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = HEXPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">12</span>);</span><br><span class="line">            buf.append(StringUtil.NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> padding = BYTEPADDING.length - i;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="keyword">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugAll</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldlimit = buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        StringBuilder origin = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">debugRead</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MathUtil.isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        StringUtil.NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        StringUtil.NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> startIndex = offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fullRows = length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> remainder = length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> rowStartIndex = (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="keyword">int</span> rowEndIndex = rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(StringUtil.NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="keyword">int</span> row, <span class="keyword">int</span> rowStartIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(StringUtil.NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">short</span> <span class="title">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用ByteBuffer方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBuffer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 向buffer中写入1个字节的数据</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">97</span>);</span><br><span class="line">        <span class="comment">// 使用工具类，查看buffer状态</span></span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向buffer中写入4个字节的数据</span></span><br><span class="line">        buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">98</span>, <span class="number">99</span>, <span class="number">100</span>, <span class="number">101</span>&#125;);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">        System.out.println(buffer.get());</span><br><span class="line">        System.out.println(buffer.get());</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用compact切换模式</span></span><br><span class="line">        buffer.compact();</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次写入</span></span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">102</span>);</span><br><span class="line">        buffer.put((<span class="keyword">byte</span>)<span class="number">103</span>);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向缓冲区写入了一个字节的数据，此时postition为1</span></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">1</span>], limit: [<span class="number">10</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |a.........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓冲区写入四个字节的数据，此时position为5</span></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">5</span>], limit: [<span class="number">10</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |abcde.....      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用flip切换模式，此时position为0，表示从第0个数据开始读取</span></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">0</span>], limit: [<span class="number">5</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |abcde.....      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="comment">// 读取两个字节的数据             </span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">98</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// position变为2             </span></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">2</span>], limit: [<span class="number">5</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">62</span> <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |abcde.....      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">             </span><br><span class="line"><span class="comment">// 调用compact切换模式，此时position及其后面的数据被压缩到ByteBuffer前面去了</span></span><br><span class="line"><span class="comment">// 此时position为3，会覆盖之前的数据             </span></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">3</span>], limit: [<span class="number">10</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">64</span> <span class="number">65</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |cdede.....      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">             </span><br><span class="line"><span class="comment">// 再次写入两个字节的数据，之前的 0x64 0x65 被覆盖         </span></span><br><span class="line">+--------+-------------------- all ------------------------+----------------+</span><br><span class="line">position: [<span class="number">5</span>], limit: [<span class="number">10</span>]</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">63</span> <span class="number">64</span> <span class="number">65</span> <span class="number">66</span> <span class="number">67</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                   |cdefg.....      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h4 id="4-字符串与ByteBuffer互相转换"><a href="#4-字符串与ByteBuffer互相转换" class="headerlink" title="4. 字符串与ByteBuffer互相转换"></a>4. 字符串与ByteBuffer互相转换</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p><strong>编码</strong>：字符串调用getByte方法获得byte数组，将byte数组放入ByteBuffer中</p><p><strong>解码</strong>：<strong>先调用ByteBuffer的flip方法，然后通过StandardCharsets的decoder方法解码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备两个字符串</span></span><br><span class="line">        String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 通过字符串的getByte方法获得字节数组，放入缓冲区中</span></span><br><span class="line">        buffer1.put(str1.getBytes());</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓冲区中的数据转化为字符串</span></span><br><span class="line">        <span class="comment">// 切换模式</span></span><br><span class="line">        buffer1.flip();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span></span><br><span class="line">        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p><strong>编码</strong>：通过StandardCharsets的encode方法获得ByteBuffer，此时获得的ByteBuffer为读模式，无需通过flip切换模式</p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备两个字符串</span></span><br><span class="line">        String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过StandardCharsets的encode方法获得ByteBuffer</span></span><br><span class="line">        <span class="comment">// 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span></span><br><span class="line">        ByteBuffer buffer1 = StandardCharsets.UTF_8.encode(str1);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓冲区中的数据转化为字符串</span></span><br><span class="line">        <span class="comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span></span><br><span class="line">        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h5><p><strong>编码</strong>：字符串调用getByte()方法获得字节数组，将字节数组传给<strong>ByteBuffer的wrap()方法</strong>，通过该方法获得ByteBuffer。<strong>同样无需调用flip方法切换为读模式</strong></p><p><strong>解码</strong>：通过StandardCharsets的decoder方法解码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 准备两个字符串</span></span><br><span class="line">        String str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过StandardCharsets的encode方法获得ByteBuffer</span></span><br><span class="line">        <span class="comment">// 此时获得的ByteBuffer为读模式，无需通过flip切换模式</span></span><br><span class="line">        ByteBuffer buffer1 = ByteBuffer.wrap(str1.getBytes());</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将缓冲区中的数据转化为字符串</span></span><br><span class="line">        <span class="comment">// 通过StandardCharsets解码，获得CharBuffer，再通过toString获得字符串</span></span><br><span class="line">        str2 = StandardCharsets.UTF_8.decode(buffer1).toString();</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">        ByteBufferUtil.debugAll(buffer1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-粘包与半包"><a href="#5-粘包与半包" class="headerlink" title="5. 粘包与半包"></a>5. 粘包与半包</h4><h5 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h5><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p><ul><li>Hello,world\n</li><li>I’m Nyima\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer (粘包，半包)</p><ul><li>Hello,world\nI’m Nyima\nHo</li><li>w are you?\n</li></ul><h5 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h5><p><strong>粘包</strong></p><p>发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p><p><strong>半包</strong></p><p>接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p><p>解决办法</p><ul><li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。</p><p>注意</p><p>：get(index)不会改变position的值</p><ul><li>记录该段数据长度，以便于申请对应大小的缓冲区</li><li>将缓冲区的数据通过get()方法写入到target中</li></ul></li><li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">        <span class="comment">// 模拟粘包+半包</span></span><br><span class="line">        buffer.put(<span class="string">&quot;Hello,world\nI&#x27;m Nyima\nHo&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 调用split函数处理</span></span><br><span class="line">        split(buffer);</span><br><span class="line">        buffer.put(<span class="string">&quot;w are you?\n&quot;</span>.getBytes());</span><br><span class="line">        split(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer buffer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 切换为读模式</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.limit(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历寻找分隔符</span></span><br><span class="line">            <span class="comment">// get(i)不会移动position</span></span><br><span class="line">            <span class="keyword">if</span> (buffer.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 缓冲区长度</span></span><br><span class="line">                <span class="keyword">int</span> length = i+<span class="number">1</span>-buffer.position();</span><br><span class="line">                ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">                <span class="comment">// 将前面的内容写入target缓冲区</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                    <span class="comment">// 将buffer中的数据写入target中</span></span><br><span class="line">                    target.put(buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打印查看结果</span></span><br><span class="line">                ByteBufferUtil.debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 切换为写模式，但是缓冲区可能未读完，这里需要使用compact</span></span><br><span class="line">        buffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3. 文件编程"></a>3. 文件编程</h2><h3 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h3><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>FileChannel<strong>只能在阻塞模式下工作</strong>，所以无法搭配Selector</p><h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>不能直接打开 FileChannel，<strong>必须</strong>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li><li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li><li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li></ul><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</p><p>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readBytes = channel.read(buffer);</span><br></pre></td></tr></table></figure><p><strong>可根据返回值判断是否读取完毕</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(channel.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 进行对应操作</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>因为<strong>channel也是有大小的</strong>，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须<strong>需要按照以下规则进行写入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中</span><br><span class="line">while(buffer.hasRemaining()) &#123;</span><br><span class="line">channel.write(buffer);</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>通道需要close，一般情况通过try-with-resource(语法糖，编译期自动加finally关闭)进行关闭，<strong>最好使用以下方法获取stream以及channel，避免某些原因使得资源未被关闭</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestChannel &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        try (FileInputStream fis = new FileInputStream(&quot;stu.txt&quot;);</span><br><span class="line">             FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;);</span><br><span class="line">             FileChannel inputChannel = fis.getChannel();</span><br><span class="line">             FileChannel outputChannel = fos.getChannel()) &#123;</span><br><span class="line">            </span><br><span class="line">            // 执行对应操作</span><br><span class="line">            ...</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure><h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p><strong>position</strong></p><p>channel也拥有一个保存读取数据位置的属性，即position</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br></pre></td></tr></table></figure><p>可以通过position(int pos)设置channel中position的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> newPos = ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1</li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h4 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 <strong>force(true)</strong> 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h3 id="3-2-两个Channel传输数据"><a href="#3-2-两个Channel传输数据" class="headerlink" title="3.2 两个Channel传输数据"></a>3.2 两个Channel传输数据</h3><p><strong>transferTo方法</strong></p><p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p><p>transferTo底层使用了<strong>零拷贝</strong>技术，效率高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class TestChannel &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try (FileInputStream fis = new FileInputStream(&quot;stu.txt&quot;);</span><br><span class="line">             FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;);</span><br><span class="line">             FileChannel inputChannel = fis.getChannel();</span><br><span class="line">             FileChannel outputChannel = fos.getChannel()) &#123;</span><br><span class="line">            // 参数：inputChannel的起始位置，传输数据的大小，目的channel</span><br><span class="line">            // 返回值为传输的数据的字节数</span><br><span class="line">            // transferTo一次只能传输2G的数据</span><br><span class="line">            inputChannel.transferTo(0, inputChannel.size(), outputChannel);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure><p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestChannel &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        try (FileInputStream fis = new FileInputStream(&quot;stu.txt&quot;);</span><br><span class="line">             FileOutputStream fos = new FileOutputStream(&quot;student.txt&quot;);</span><br><span class="line">             FileChannel inputChannel = fis.getChannel();</span><br><span class="line">             FileChannel outputChannel = fos.getChannel()) &#123;</span><br><span class="line">            long size = inputChannel.size();</span><br><span class="line">            long capacity = inputChannel.size();</span><br><span class="line">            // 分多次传输</span><br><span class="line">            while (capacity &gt; 0) &#123;</span><br><span class="line">                // transferTo返回值为传输了的字节数</span><br><span class="line">                capacity -= inputChannel.transferTo(size-capacity, capacity, outputChannel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure><h3 id="3-3-Path与Paths"><a href="#3-3-Path与Paths" class="headerlink" title="3.3 Path与Paths"></a>3.3 Path与Paths</h3><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path source = Paths.get(&quot;1.txt&quot;); // 相对路径 不带盘符 使用 user.dir 环境变量来定位 1.txt</span><br><span class="line"></span><br><span class="line">Path source = Paths.get(&quot;d:\\1.txt&quot;); // 绝对路径 代表了  d:\1.txt 反斜杠需要转义</span><br><span class="line"></span><br><span class="line">Path source = Paths.get(&quot;d:/1.txt&quot;); // 绝对路径 同样代表了  d:\1.txt</span><br><span class="line"></span><br><span class="line">Path projects = Paths.get(&quot;d:\\data&quot;, &quot;projects&quot;); // 代表了  d:\data\projectsCopy</span><br></pre></td></tr></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">|- data</span><br><span class="line">|- projects</span><br><span class="line">|- a</span><br><span class="line">|- bCopy</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;d:\\data\\projects\\a\\..\\b&quot;);</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize()); // 正常化路径 会去除 . 以及 ..Copy</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\data\projects\a\..\b</span><br><span class="line">d:\data\projects\bCopy</span><br></pre></td></tr></table></figure><h3 id="3-4-Files"><a href="#3-4-Files" class="headerlink" title="3.4 Files"></a>3.4 Files</h3><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>检查文件是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;helloword/data.txt&quot;);</span><br><span class="line">System.out.println(Files.exists(path));Copy</span><br></pre></td></tr></table></figure><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建<strong>一级目录</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;helloword/d1&quot;);</span><br><span class="line">Files.createDirectory(path);Copy</span><br></pre></td></tr></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建<strong>多级目录用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;helloword/d1/d2&quot;);</span><br><span class="line">Files.createDirectories(path);Copy</span><br></pre></td></tr></table></figure><h4 id="拷贝及移动"><a href="#拷贝及移动" class="headerlink" title="拷贝及移动"></a>拷贝及移动</h4><p><strong>拷贝文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Path source = Paths.get(&quot;helloword/data.txt&quot;);</span><br><span class="line">Path target = Paths.get(&quot;helloword/target.txt&quot;);</span><br><span class="line"></span><br><span class="line">Files.copy(source, target);Copy</span><br></pre></td></tr></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source <strong>覆盖</strong>掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);Copy</span><br></pre></td></tr></table></figure><p>移动文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Path source = Paths.get(&quot;helloword/data.txt&quot;);</span><br><span class="line">Path target = Paths.get(&quot;helloword/data.txt&quot;);</span><br><span class="line"></span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);Copy</span><br></pre></td></tr></table></figure><ul><li><strong>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</strong></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path target = Paths.get(&quot;helloword/target.txt&quot;);</span><br><span class="line"></span><br><span class="line">Files.delete(target);Copy</span><br></pre></td></tr></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path target = Paths.get(&quot;helloword/d1&quot;);</span><br><span class="line"></span><br><span class="line">Files.delete(target);Copy</span><br></pre></td></tr></table></figure><ul><li>如果<strong>目录还有内容</strong>，会抛异常 DirectoryNotEmptyException</li></ul><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>可以<strong>使用Files工具类中的walkFileTree(Path, FileVisitor)方法</strong>，其中需要传入两个参数</p><ul><li><p>Path：文件起始路径</p></li><li><p>FileVisitor：文件访问器，</p><p>使用访问者模式</p><ul><li><p>接口的实现类</p><p>SimpleFileVisitor</p><p>有四个方法</p><ul><li>preVisitDirectory：访问目录前的操作</li><li>visitFile：访问文件的操作</li><li>visitFileFailed：访问文件失败时的操作</li><li>postVisitDirectory：访问目录后的操作</li></ul></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class TestWalkFileTree &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Path path = Paths.get(&quot;F:\\JDK 8&quot;);</span><br><span class="line">        // 文件目录数目</span><br><span class="line">        AtomicInteger dirCount = new AtomicInteger();</span><br><span class="line">        // 文件数目</span><br><span class="line">        AtomicInteger fileCount = new AtomicInteger();</span><br><span class="line">        Files.walkFileTree(path, new SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">                System.out.println(&quot;===&gt;&quot;+dir);</span><br><span class="line">                // 增加文件目录数</span><br><span class="line">                dirCount.incrementAndGet();</span><br><span class="line">                return super.preVisitDirectory(dir, attrs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">                System.out.println(file);</span><br><span class="line">                // 增加文件数</span><br><span class="line">                fileCount.incrementAndGet();</span><br><span class="line">                return super.visitFile(file, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 打印数目</span><br><span class="line">        System.out.println(&quot;文件目录数:&quot;+dirCount.get());</span><br><span class="line">        System.out.println(&quot;文件数:&quot;+fileCount.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">===&gt;F:\JDK 8\lib\security\policy\unlimited</span><br><span class="line">F:\JDK 8\lib\security\policy\unlimited\local_policy.jar</span><br><span class="line">F:\JDK 8\lib\security\policy\unlimited\US_export_policy.jar</span><br><span class="line">F:\JDK 8\lib\security\trusted.libraries</span><br><span class="line">F:\JDK 8\lib\sound.properties</span><br><span class="line">F:\JDK 8\lib\tzdb.dat</span><br><span class="line">F:\JDK 8\lib\tzmappings</span><br><span class="line">F:\JDK 8\LICENSE</span><br><span class="line">F:\JDK 8\README.txt</span><br><span class="line">F:\JDK 8\release</span><br><span class="line">F:\JDK 8\THIRDPARTYLICENSEREADME-JAVAFX.txt</span><br><span class="line">F:\JDK 8\THIRDPARTYLICENSEREADME.txt</span><br><span class="line">F:\JDK 8\Welcome.html</span><br><span class="line">文件目录数:23</span><br><span class="line">文件数:279</span><br></pre></td></tr></table></figure><h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4. 网络编程"></a>4. 网络编程</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>网络编程就是如何在程序中实现两台计算机的通信。</p><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p><p>网络由下往上分为物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 通过初步的了解，我知道IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性，socket则是对 TCP/IP协议的封装和应用(程序员层面上)。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要 解决如何包装数据。<strong>socket是对TCP/IP协议的封装</strong>，Socket本身并不是协议，而是一个调用接口(API)。 通过Socket，我们才能使用TCP/IP协议。<br>    建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><p><img src="https://s2.loli.net/2022/04/03/8hEpI6Rg7OL1bSW.jpg" alt="img"></p><p><strong>Socket、Socketchannel的区别</strong></p><p>Socket、SocketChannel二者的实质都是一样的，都是为了实现客户端与服务器端的连接而存在的，但是在使用上，却有很大的区别。具体如下：<br>1.所属包不同<br>Socket在java.net包中，而SocketChannel在java.nio包中。<br>2.异步方式不同<br>从包的不同，我们大体可以推断出他们主要的区别：Socket是阻塞连接（当然我们可以自己实现非阻塞），SocketChannel可以设置非阻塞连接。<br>使用ServerSocket、Socket类时，服务端Socket往往要为每一个客户端Socket分配一个线程，而每一个线程都有可能处于长时间的阻塞状态中。过多的线程也会影响服务器的性能（可以使用线程池优化，具体看这里：如何编写多线程Socket程序）。而使用SocketChannel、ServerSocketChannel类可以非阻塞通信，这样使得服务器端只需要一个线程就能处理所有客户端socket的请求。<br>3.性能不同<br>一般来说使用SocketChannel会有更好的性能。其实，Socket实际应该比SocketChannel更高效，不过由于使用者设计等原因，效率反而比直接使用SocketChannel低。<br>4.使用方式不同<br>Socket、ServerSocket类可以传入不同参数直接实例化对象并绑定ip和端口，如：<br>Socket socket = new Socket(“127.0.0.1”, “8000”);<br>ServerSocket serverSocket = new ServerSocket(“8000”);</p><p>而SocketChannel、ServerSocketChannel类需要借助Selector类控制<br>下面是SocketChannel方式需要用到的几个核心类：</p><ul><li><p>ServerSocketChannel<br>   <strong>ServerSocket的替代类, 支持阻塞通信与非阻塞通信。</strong></p></li><li><p>SocketChannel<br>​    Socket的替代类, 支持阻塞通信与非阻塞通信。</p></li><li><p>Selector<br><strong>为ServerSocketChannel监控接收客户端连接就绪事件, 为SocketChannel监控连接服务器读就绪和写就绪事件。</strong></p></li><li><p>SelectionKey<br>代表ServerSocketChannel及SocketChannel向Selector注册事件的句柄。当一个<br>SelectionKey对象位于Selector对象的selected-keys集合中时，就表示与这个SelectionKey对象相关的事件发生了。<br>在SelectionKey类中有几个静态常量：<br>SelectionKey.OP_ACCEPT，客户端连接就绪事件，等于监听serversocket.accept()，返回一个socket。<br>SelectionKey.OP_CONNECT，准备连接服务器就绪，跟上面类似，只不过是对于socket的 相当于监听了socket.connect()。<br>SelectionKey.OP_READ，读就绪事件, 表示输入流中已经有了可读数据, 可以执行读操作。<br>SelectionKey.OP_WRITE，写就绪事件, 表示可以执行写操作。</p></li></ul><h3 id="4-1-非阻塞-amp-阻塞"><a href="#4-1-非阻塞-amp-阻塞" class="headerlink" title="4.1 非阻塞 &amp; 阻塞"></a>4.1 非阻塞 &amp; 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li><li>SocketChannel.read 会在<strong>通道中没有数据可读时</strong>让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><p>测试代码</p><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 获得服务器通道</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 为服务器通道绑定端口</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 用户存放连接的集合</span></span><br><span class="line">            ArrayList&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 循环接收连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before connecting...&quot;</span>);</span><br><span class="line">                <span class="comment">// 没有连接时，会阻塞线程,线程停止运行</span></span><br><span class="line">                SocketChannel socketChannel = server.accept();</span><br><span class="line">                System.out.println(<span class="string">&quot;after connecting...&quot;</span>);</span><br><span class="line">                channels.add(socketChannel);</span><br><span class="line">                <span class="comment">// 循环遍历集合中的连接</span></span><br><span class="line">                <span class="keyword">for</span>(SocketChannel channel : channels) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;before reading&quot;</span>);</span><br><span class="line">                    <span class="comment">// 处理通道中的数据</span></span><br><span class="line">                    <span class="comment">// 当通道中没有数据可读时，会阻塞线程</span></span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(<span class="string">&quot;after reading&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (SocketChannel socketChannel = SocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 建立连接</span></span><br><span class="line">            socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><ul><li><p>客户端-服务器建立连接前：服务器端因accept阻塞</p></li><li><p>客户端-服务器建立连接后，客户端发送消息前：服务器端因通道为空被阻塞</p></li><li><p>客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞</p><p><img src="https://s2.loli.net/2022/04/03/cRLEgw5BVp1YCij.png" alt="image-20220403095916431"></p></li><li><p>之前的客户端再次发送消息<strong>，服务器端因为被accept阻塞</strong>，无法处理之前客户端发送到通道中的信息</p></li></ul><h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul><li>可以通过ServerSocketChannel的configureBlocking(<strong>false</strong>)方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li><li>可以通过SocketChannel的configureBlocking(<strong>false</strong>)方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li></ul><p>服务器端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 获得服务器通道</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 为服务器通道绑定端口</span></span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 用户存放连接的集合</span></span><br><span class="line">            ArrayList&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">// 循环接收连接</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置为非阻塞模式，没有连接时返回null，不会阻塞线程,线程还会继续运行 </span></span><br><span class="line">                server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//ServerSocketChannel 的 accept()方法会返回 SocketChannel 类型对象，SocketChannel 可以在非阻塞模式下运行。</span></span><br><span class="line">                <span class="comment">//ServerSocketChannel的accept方法返回SocketChannel套接字通道，用于读取请求数据和写入响应数据。</span></span><br><span class="line">                SocketChannel socketChannel = server.accept();</span><br><span class="line">                <span class="comment">// 通道不为空时才将连接放入到集合中</span></span><br><span class="line">                <span class="keyword">if</span> (socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;after connecting...&quot;</span>);</span><br><span class="line">                    channels.add(socketChannel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 循环遍历集合中的连接</span></span><br><span class="line">                <span class="keyword">for</span>(SocketChannel channel : channels) &#123;</span><br><span class="line">                    <span class="comment">// 处理通道中的数据</span></span><br><span class="line">                    <span class="comment">// 设置为非阻塞模式，若通道中没有数据，会返回0，不会阻塞线程</span></span><br><span class="line">                    channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">int</span> read = channel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span>(read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        System.out.println(<span class="string">&quot;after reading&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写存在一个问题，因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</p><h3 id="4-2-Selector-amp-accept事件"><a href="#4-2-Selector-amp-accept事件" class="headerlink" title="4.2 Selector &amp; accept事件"></a>4.2 Selector &amp; accept事件</h3><p><strong>多路复用</strong></p><p><strong>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</strong></p><ul><li><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</li><li>如果不用 Selector 的非阻塞模式，<strong>线程大部分时间都在做无用功，而 Selector 能够保证</strong><ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 获得服务器通道</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 创建选择器</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通道必须设置为非阻塞模式</span></span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将通道注册到选择器中，并设置感兴趣的事件</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 若没有事件就绪，线程会被阻塞不会继续向下运行，反之不会被阻塞。从而避免了CPU空转</span></span><br><span class="line">                <span class="comment">//select在事件未处理时，不会阻塞</span></span><br><span class="line">                <span class="comment">// 返回值为就绪的事件个数</span></span><br><span class="line">                <span class="keyword">int</span> ready = selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;selector ready counts : &quot;</span> + ready);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 获取所有事件，包含所有发生的事件和哪个channel的事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用迭代器遍历事件</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 判断key的类型</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 获得key对应的channel</span></span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                        System.out.println(<span class="string">&quot;before accepting...&quot;</span>);</span><br><span class="line">                        </span><br><span class="line">        <span class="comment">// 获取连接并处理，而且是必须处理，否则需要取消</span></span><br><span class="line">                        SocketChannel socketChannel = channel.accept();</span><br><span class="line">                        System.out.println(<span class="string">&quot;after accepting...&quot;</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 处理完毕后移除</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤解析</strong></p><ul><li>获得选择器Selector</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ul><li>将通道设置为非阻塞模式，并注册到选择器中，并设置感兴趣的事件<ul><li>channel 必须工作在非阻塞模式</li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接收连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通道必须设置为非阻塞模式</span></span><br><span class="line">server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 将通道注册到选择器中，并设置感兴趣的事件</span></span><br><span class="line">server.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><ul><li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p><ul><li><p>阻塞直到绑定事件发生</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = selector.select();</span><br></pre></td></tr></table></figure></li><li><p>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = selector.select(long timeout);</span><br></pre></td></tr></table></figure></li><li><p><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int count = selector.selectNow();</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://s2.loli.net/2022/04/25/9st48SwqGvPYpWz.png" alt="image-20220425210815905"></p></li><li><p>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有事件</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                </span><br><span class="line">// 使用迭代器遍历事件</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line"></span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">                    </span><br><span class="line">// 判断key的类型，此处为Accept类型</span><br><span class="line">if(key.isAcceptable()) &#123;</span><br><span class="line">        // 获得key对应的channel</span><br><span class="line">        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">        // 获取连接并处理，而且是必须处理，否则需要取消</span><br><span class="line">        SocketChannel socketChannel = channel.accept();</span><br><span class="line"></span><br><span class="line">        // 处理完毕后移除</span><br><span class="line">        iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事件发生后能否不处理</strong></p><p>事件发生后，<strong>要么处理，要么取消（cancel）</strong>，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p><h3 id="4-3-Read事件"><a href="#4-3-Read事件" class="headerlink" title="4.3 Read事件"></a>4.3 Read事件</h3><ul><li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li><li>添加Read事件，触发后进行读取操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">// 获得服务器通道</span></span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 创建选择器</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            <span class="comment">// 通道必须设置为非阻塞模式</span></span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将通道注册到选择器中，并设置感兴趣的事件</span></span><br><span class="line">            <span class="comment">//selectionKey就是事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">            <span class="comment">//SelectionKey sscKey = server.register(selector,0,null);</span></span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="comment">// 为serverKey设置感兴趣的事件</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span></span><br><span class="line">                <span class="comment">// 返回值为就绪的事件个数</span></span><br><span class="line">                <span class="keyword">int</span> ready = selector.select();</span><br><span class="line">                System.out.println(<span class="string">&quot;selector ready counts : &quot;</span> + ready);</span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                <span class="comment">// 使用迭代器遍历事件</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="comment">// 判断key的类型,区分事件类型</span></span><br><span class="line">                    <span class="comment">//如果是accept事件</span></span><br><span class="line">                    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 获得key对应的channel</span></span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                        System.out.println(<span class="string">&quot;before accepting...&quot;</span>);</span><br><span class="line">                        <span class="comment">// 获取连接</span></span><br><span class="line">                        SocketChannel socketChannel = channel.accept();</span><br><span class="line">                        System.out.println(<span class="string">&quot;after accepting...&quot;</span>);</span><br><span class="line">                        <span class="comment">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中</span></span><br><span class="line">                        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        <span class="comment">// 处理完毕后移除</span></span><br><span class="line">                        <span class="comment">//因为appcept只需执行一次，selector会在发生事件时，只会向selectionkey（另一个集合）中加入key,但不会删除</span></span><br><span class="line">                        <span class="comment">//下次重新循环时，因为selectionkey中还有accept对应的key，所以还会执行，因为有连接了返回null，null无法设置非阻塞</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        System.out.println(<span class="string">&quot;before reading...&quot;</span>);</span><br><span class="line">                        channel.read(buffer);</span><br><span class="line">                        System.out.println(<span class="string">&quot;after reading...&quot;</span>);</span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        ByteBufferUtil.debugRead(buffer);</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        <span class="comment">// 处理完毕后移除</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除事件</strong></p><p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。原因如下</p><p>以我们上面的 <strong>Read事件</strong> 的代码为例</p><ul><li><p>当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// WindowsSelectorImpl 中的 SelectionKeyImpl数组</span><br><span class="line">private SelectionKeyImpl[] channelArray = new SelectionKeyImpl[8];</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionKeyImpl extends AbstractSelectionKey &#123;</span><br><span class="line">    // Key对应的通道</span><br><span class="line">    final SelChImpl channel;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414192429.png"><img src="https://s2.loli.net/2022/04/24/p4ujIbgxv8V3Sze.png" alt="img"></a></p></li><li><p>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210414193143.png"><img src="https://s2.loli.net/2022/04/24/B7Epfzq61bmvwhO.png" alt="img"></a></p></li></ul><h4 id="断开处理"><a href="#断开处理" class="headerlink" title="断开处理"></a>断开处理</h4><p>当客户端与服务器之间的连接<strong>断开时，会给服务器端发送一个读事件</strong>，对异常断开和正常断开需要加以不同的方式进行处理</p><ul><li><p><strong>正常断开</strong></p><ul><li><p>正常断开时，服务器端的channel.read(buffer)方法的返回值为-1，<strong>所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int read = channel.read(buffer);</span><br><span class="line">// 断开连接时，客户端会向服务器发送一个写事件，此时read的返回值为-1</span><br><span class="line">if(read == -1) &#123;</span><br><span class="line">    // 取消该事件的处理</span><br><span class="line">key.cancel();</span><br><span class="line">    channel.close();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">// 取消或者处理，都需要移除key</span><br><span class="line">iterator.remove();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>异常断开</p><ul><li>异常断开时，会抛出IOException异常， 在try-catch的<strong>catch块中捕获异常并调用key的cancel方法即可</strong></li></ul></li></ul><h4 id="处理消息边界"><a href="#处理消息边界" class="headerlink" title="处理消息边界"></a>处理消息边界</h4><p>传输的文本可能有以下三种情况</p><ul><li>文本大于缓冲区大小<ul><li>此时需要将缓冲区进行扩容</li></ul></li><li>发生半包现象（时刻2）</li><li>发生粘包现象（时刻3，同一个bytebuffer存在两个消息）</li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103442.png"><img src="https://s2.loli.net/2022/04/25/KHFvug8UQeJEnxI.png" alt="img"></a></p><p><strong>产生原因</strong></p><p>因为<strong>TCP是面向连接的传输协议，TCP传输的数据是以流的形式</strong>，而流数据是没有明确的开始结尾边界，所以TCP也没办法判断哪一段流属于一个消息。而UDP是没有半包、粘包的问题，因为<strong>UDP是面向消息的，它有边界协议</strong>，可以根据消息的格式区分消息的开始和结尾，UDP和TCP两个发送消息就好像一个用桶运水，一个用水管运水，用水管运水的你是没办法区分那部分的水是属于哪一桶的。</p><p><strong>TCP发送数据原因：</strong></p><p>因为TCP本身传输的数据包大小就有限制，所以应用发出的消息包过大，TCP会把应用消息包拆分为多个TCP数据包发送出去。（半包）</p><p>Negal算法的优化，当应用发送数据包太小，TCP为了减少网络请求次数的开销，它会等待多个消息包一起，打成一个TCP数据包一次发送出去。（粘包）</p><p><strong>TCP接收方的原因</strong></p><p>因为TCP缓冲区里的数据都是字符流的形式，没有明确的边界，因为数据没边界，所以应用从TCP缓冲区中读取数据时就没办法指定一个或几个消息一起读，而只能选择一次读取多大的数据流，而这个数据流中就可能包含着某个消息包的一部分数据。</p><p>解决思路大致有以下三种</p><ul><li><p><strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</p></li><li><p>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</p></li><li><p>TLV 格式，即 Type 类型、Length 长度、Value 数据</p><p>（也就是在消息开头</p><p>用一些空间存放后面数据的长度</p><p>），如HTTP请求头中的Content-Type与</p><p>Content-Length</p><p>。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量</p><ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式<a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210415103926.png"><img src="https://s2.loli.net/2022/04/25/RwB42K1izlSxQbD.png" alt="img"></a></li></ul></li></ul><h4 id="附件与扩容"><a href="#附件与扩容" class="headerlink" title="附件与扩容"></a><strong>附件与扩容</strong></h4><p>Channel的register方法还有<strong>第三个参数</strong>：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final SelectionKey register(Selector sel, int ops, Object att)</span><br></pre></td></tr></table></figure><p>之后可通过SelectionKey的<strong>attachment()方法获得附件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br></pre></td></tr></table></figure><p>我们需要在Accept事件发生后，将通道注册到Selector中时，<strong>对每个通道添加一个ByteBuffer附件</strong>，<strong>让每个通道发生读事件时都使用自己的通道</strong>，避免与其他通道发生冲突而导致问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class="line">// 添加通道对应的Buffer附件</span><br><span class="line">socketChannel.register(selector, SelectionKey.OP_READ, buffer);</span><br></pre></td></tr></table></figure><p>当Channel中的数据大于缓冲区时，需要对缓冲区进行<strong>扩容</strong>操作。此代码中的扩容的判定方法：<strong>Channel调用compact方法后，的position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 如果缓冲区太小，就进行扩容</span><br><span class="line">if (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">    ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity()*2);</span><br><span class="line">    // 将旧buffer中的内容放入新的buffer中</span><br><span class="line">    ewBuffer.put(buffer);</span><br><span class="line">    // 将新buffer作为附件放到key中</span><br><span class="line">    key.attach(newBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改造后的服务器代码如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public class SelectServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获得服务器通道</span><br><span class="line">        try(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            server.bind(new InetSocketAddress(8080));</span><br><span class="line">            // 创建选择器</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            // 通道必须设置为非阻塞模式</span><br><span class="line">            server.configureBlocking(false);</span><br><span class="line">            // 将通道注册到选择器中，并设置感兴趣的事件</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            // 为serverKey设置感兴趣的事件</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                // 若没有事件就绪，线程会被阻塞，反之不会被阻塞。从而避免了CPU空转</span><br><span class="line">                // 返回值为就绪的事件个数</span><br><span class="line">                int ready = selector.select();</span><br><span class="line">                System.out.println(&quot;selector ready counts : &quot; + ready);</span><br><span class="line">                // 获取所有事件</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                // 使用迭代器遍历事件</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                while (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    // 判断key的类型</span><br><span class="line">                    if(key.isAcceptable()) &#123;</span><br><span class="line">                        // 获得key对应的channel</span><br><span class="line">                        ServerSocketChannel channel = (ServerSocketChannel) key.channel();</span><br><span class="line">                        System.out.println(&quot;before accepting...&quot;);</span><br><span class="line">                        // 获取连接</span><br><span class="line">                        SocketChannel socketChannel = channel.accept();</span><br><span class="line">                        System.out.println(&quot;after accepting...&quot;);</span><br><span class="line">                        // 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件</span><br><span class="line">                        socketChannel.configureBlocking(false);</span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(16);</span><br><span class="line">                        socketChannel.register(selector, SelectionKey.OP_READ, buffer);</span><br><span class="line">                        // 处理完毕后移除</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125; else if (key.isReadable()) &#123;</span><br><span class="line">                        SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                        System.out.println(&quot;before reading...&quot;);</span><br><span class="line">                        // 通过key获得附件（buffer）</span><br><span class="line">                        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                        int read = channel.read(buffer);</span><br><span class="line">                        if(read == -1) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            channel.close();</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            // 通过分隔符来分隔buffer中的数据</span><br><span class="line">                            split(buffer);</span><br><span class="line">                            // 如果缓冲区太小，就进行扩容</span><br><span class="line">                            if (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                                ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity()*2);</span><br><span class="line">                                // 将旧buffer中的内容放入新的buffer中</span><br><span class="line">                                buffer.flip();</span><br><span class="line">                                newBuffer.put(buffer);</span><br><span class="line">                                // 将新buffer放到key中作为附件</span><br><span class="line">                                key.attach(newBuffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(&quot;after reading...&quot;);</span><br><span class="line">                        // 处理完毕后移除</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void split(ByteBuffer buffer) &#123;</span><br><span class="line">        buffer.flip();</span><br><span class="line">        for(int i = 0; i &lt; buffer.limit(); i++) &#123;</span><br><span class="line">            // 遍历寻找分隔符</span><br><span class="line">            // get(i)不会移动position</span><br><span class="line">            if (buffer.get(i) == &#x27;\n&#x27;) &#123;</span><br><span class="line">                // 缓冲区长度</span><br><span class="line">                int length = i+1-buffer.position();</span><br><span class="line">                ByteBuffer target = ByteBuffer.allocate(length);</span><br><span class="line">                // 将前面的内容写入target缓冲区</span><br><span class="line">                for(int j = 0; j &lt; length; j++) &#123;</span><br><span class="line">                    // 将buffer中的数据写入target中</span><br><span class="line">                    target.put(buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                // 打印结果</span><br><span class="line">                ByteBufferUtil.debugAll(target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 切换为写模式，但是缓冲区可能未读完，这里需要使用compact</span><br><span class="line">        buffer.compact();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ByteBuffer的大小分配"><a href="#ByteBuffer的大小分配" class="headerlink" title="ByteBuffer的大小分配"></a>ByteBuffer的大小分配</h4><ul><li>每个 channel 都需要记录可能被切分的消息，因为 <strong>ByteBuffer 不能被多个 channel 共同使用</strong>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</li><li>分配思路可以参考<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能<ul><li>参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li></ul></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h3 id="4-4-Write事件"><a href="#4-4-Write事件" class="headerlink" title="4.4 Write事件"></a>4.4 Write事件</h3><p>服务器通过Buffer向通道中写入数据时，<strong>可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到Channel中，这时便需要分多次写入</strong>，具体步骤如下</p><ul><li><p>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</p></li><li><p>若Buffer中还有数据，则<strong>需要将SocketChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> int write = socket.write(buffer);</span><br><span class="line">// 通道中可能无法放入缓冲区中的所有数据</span><br><span class="line">if (buffer.hasRemaining()) &#123;</span><br><span class="line">    // 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span><br><span class="line">    socket.configureBlocking(false);</span><br><span class="line">    socket.register(selector, SelectionKey.OP_WRITE, buffer);</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure></li><li><p>添加写事件的相关操作<code>key.isWritable()</code>，对Buffer再次进行写操作</p><ul><li>每次写后需要判断Buffer中是否还有数据（是否写完）。<strong>若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socket = (SocketChannel) key.channel();</span><br><span class="line">// 获得buffer</span><br><span class="line">ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">// 执行写操作</span><br><span class="line">int write = socket.write(buffer);</span><br><span class="line">System.out.println(write);</span><br><span class="line">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span><br><span class="line">if (!buffer.hasRemaining()) &#123;</span><br><span class="line">    key.attach(null);</span><br><span class="line">    key.interestOps(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>整体代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="comment">// 处理后就移除事件</span></span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 获得客户端的通道</span></span><br><span class="line">                        SocketChannel socket = server.accept();</span><br><span class="line">                        <span class="comment">// 写入数据</span></span><br><span class="line">                        StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000000</span>; i++) &#123;</span><br><span class="line">                            builder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        ByteBuffer buffer = StandardCharsets.UTF_8.encode(builder.toString());</span><br><span class="line">                        <span class="comment">// 先执行一次Buffer-&gt;Channel的写入，如果未写完，就添加一个可写事件</span></span><br><span class="line">                        <span class="keyword">int</span> write = socket.write(buffer);</span><br><span class="line">                        System.out.println(write);</span><br><span class="line">                        <span class="comment">// 通道中可能无法放入缓冲区中的所有数据</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                            <span class="comment">// 注册到Selector中，关注可写事件，并将buffer添加到key的附件中</span></span><br><span class="line">                            socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            socket.register(selector, SelectionKey.OP_WRITE, buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                        SocketChannel socket = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 获得buffer</span></span><br><span class="line">                        ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                        <span class="comment">// 执行写操作</span></span><br><span class="line">                        <span class="keyword">int</span> write = socket.write(buffer);</span><br><span class="line">                        System.out.println(write);</span><br><span class="line">                        <span class="comment">// 如果已经完成了写操作，需要移除key中的附件，同时不再对写事件感兴趣</span></span><br><span class="line">                        <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                            <span class="comment">//没有再引用bytebuffer（位于堆中）了，会被垃圾回收掉</span></span><br><span class="line">                            key.attach(<span class="keyword">null</span>);</span><br><span class="line">                            key.interestOps(<span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-优化"><a href="#4-5-优化" class="headerlink" title="4.5 优化"></a>4.5 优化</h3><h4 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h4><p>充分利用多核CPU，分两组选择器</p><ul><li>单线程配一个选择器（Boss），<strong>专门处理 accept 事件</strong></li><li>创建 cpu 核心数的线程（Worker），<strong>每个线程配一个选择器，轮流处理 read 事件</strong></li></ul><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul><li><p>创建<strong>一个</strong>负责处理Accept事件的Boss线程，与<strong>多个</strong>负责处理Read事件的Worker线程</p></li><li><p><strong>Boss线程</strong>执行的操作</p><ul><li><p>接受并处理Accept事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要<strong>根据标识robin去判断将任务分配给哪个Worker</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建固定数量的Worker</span></span><br><span class="line">Worker[] workers = <span class="keyword">new</span> Worker[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 用于负载均衡的原子整数</span></span><br><span class="line">AtomicInteger robin = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 负载均衡，轮询分配Worker</span></span><br><span class="line">workers[robin.getAndIncrement()% workers.length].register(socket);</span><br></pre></td></tr></table></figure></li><li><p>register(SocketChannel socket)方法会<strong>通过同步队列完成Boss线程与Worker线程之间的通信</strong>，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> SocketChannel socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 只启动一次</span></span><br><span class="line">    <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">       <span class="comment">// 初始化操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向同步队列中添加SocketChannel的注册事件</span></span><br><span class="line">    <span class="comment">// 在Worker线程中执行注册事件</span></span><br><span class="line">    queue.add(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 唤醒被阻塞的Selector</span></span><br><span class="line">    <span class="comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span></span><br><span class="line">    selector.wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Worker线程执行</strong>的操作</p><ul><li><strong>从同步队列中获取注册任务，并处理Read事件</strong></li></ul></li></ul><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadsServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (ServerSocketChannel server = ServerSocketChannel.open()) &#123;</span><br><span class="line">            <span class="comment">// 当前线程为Boss线程</span></span><br><span class="line">            Thread.currentThread().setName(<span class="string">&quot;Boss&quot;</span>);</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">            <span class="comment">// 负责轮询Accept事件的Selector</span></span><br><span class="line">            Selector boss = Selector.open();</span><br><span class="line">            server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            server.register(boss, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="comment">// 创建固定数量的Worker</span></span><br><span class="line">            Worker[] workers = <span class="keyword">new</span> Worker[<span class="number">4</span>];</span><br><span class="line">            <span class="comment">// 用于负载均衡的原子整数</span></span><br><span class="line">            AtomicInteger robin = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">                workers[i] = <span class="keyword">new</span> Worker(<span class="string">&quot;worker-&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                boss.select();</span><br><span class="line">                Set&lt;SelectionKey&gt; selectionKeys = boss.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                    <span class="comment">// BossSelector负责Accept事件</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="comment">// 建立连接</span></span><br><span class="line">                        SocketChannel socket = server.accept();</span><br><span class="line">                        System.out.println(<span class="string">&quot;connected...&quot;</span>);</span><br><span class="line">                        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                        <span class="comment">// socket注册到Worker的Selector中</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;before read...&quot;</span>);</span><br><span class="line">                        <span class="comment">// 负载均衡，轮询分配Worker</span></span><br><span class="line">                        workers[robin.getAndIncrement()% workers.length].register(socket);</span><br><span class="line">                        System.out.println(<span class="string">&quot;after read...&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 同步队列，用于Boss线程与Worker线程之间的通信</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(<span class="keyword">final</span> SocketChannel socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">// 只启动一次</span></span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, name);</span><br><span class="line">                selector = Selector.open();</span><br><span class="line">                queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line">                thread.start();</span><br><span class="line">                started = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 向同步队列中添加SocketChannel的注册事件</span></span><br><span class="line">            <span class="comment">// 在Worker线程中执行注册事件</span></span><br><span class="line">            queue.add(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        socket.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 唤醒被阻塞的Selector</span></span><br><span class="line">            <span class="comment">// select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark</span></span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    <span class="comment">// 通过同步队列获得任务并运行</span></span><br><span class="line">                    Runnable task = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获得任务，执行注册操作</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">                    <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="comment">// Worker只负责Read事件</span></span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">// 简化处理，省略细节</span></span><br><span class="line">                            SocketChannel socket = (SocketChannel) key.channel();</span><br><span class="line">                            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                            socket.read(buffer);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            ByteBufferUtil.debugAll(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-NIO-amp-BIO"><a href="#5-NIO-amp-BIO" class="headerlink" title="5. NIO &amp; BIO"></a>5. NIO &amp; BIO</h2><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p>操作系统本身也是一个程序，我们平时写的程序都跑在操作系统之上，计算机的硬件资源都是由操作系统内核进行管理的。假如我们需要使用某一硬件的资源，是不能直接访问的。因为为了提高操作系统的稳定性和安全性，应用程序需要和系统程序分开。CPU将程序执行的状态分为了不同的级别，从0到3，数字越小，访问级别越高。<strong>0代表内核态，在该特权级别下，所有内存上的数据都是可见的，可访问的</strong>。<strong>3代表用户态，在这个特权级下，程序只能访问一部分的内存区域，只能执行一些限定的指令。</strong>这就把内存分为了用户态和内核态。<br>由于内存分为用户态和内核态，当我们需要访问操作系统的内部函数时，就需要使用系统调用了，为了规范操作系统提供的系统调用，IEEE制定了一个标准接口族，被称为POSIX（Portable Operating System Interface of Unix）。比如一些常用的接口：fork、pthread_create、open等。</p><p>BIO: 阻塞IO  NIO：非阻塞IO</p><h3 id="1、Stream与Channel"><a href="#1、Stream与Channel" class="headerlink" title="1、Stream与Channel"></a>1、Stream与Channel</h3><ul><li><p>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</p></li><li><p>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></p></li><li><p>二者</p><p>均为全双工</p><p>，即读写可以同时进行</p><ul><li>虽然Stream是单向流动的，但是它也是全双工的</li></ul></li></ul><h3 id="2、IO模型"><a href="#2、IO模型" class="headerlink" title="2、IO模型"></a>2、IO模型</h3><ul><li><p>同步</p><p>：<strong>线程自己去获取结果（一个线程）</strong></p><ul><li>例如：线程调用一个方法 后，需要等待方法返回结果</li></ul></li><li><p>异步</p><p>：<strong>线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</strong></p><ul><li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li></ul></li></ul><p>当一个read操作发生时，它会经历两个阶段：</p><ul><li>第一阶段：等待数据准备 (Waiting for the data to be ready)。</li><li>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</li></ul><p>对于socket流而言，</p><ul><li>第一步：等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。</li><li>第二步：把数据从内核缓冲区复制到应用进程缓冲区。</li></ul><p>当调用一次 channel.<strong>read</strong> 或 stream.<strong>read</strong> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li><p>等待数据阶段</p></li><li><p>复制数据阶段 </p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151243.png"><img src="https://s2.loli.net/2022/04/26/5Sbz1JXkGTUimW2.png" alt="img"></a></p></li></ul><p>根据UNIX 网络编程 - 卷 I，IO模型主要有以下几种</p><h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418151605.png"><img src="https://s2.loli.net/2022/04/26/cL17OFviBjlDRkM.png" alt="img"></a></p><ul><li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li></ul><h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418152137.png"><img src="https://s2.loli.net/2022/04/26/7zRWfaIqnK6FODs.png" alt="img"></a></p><ul><li><p>用户线程</p><p>在一个循环中一直调用read方法</p><p>，若内核空间中还没有数据可读，立即返回</p><ul><li><strong>只是在等待阶段非阻塞,复制阶段还是会阻塞</strong></li></ul></li><li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p></li></ul><p>缺点：多次切换用户态内核态，消耗性能</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418154208.png"><img src="https://s2.loli.net/2022/04/26/VQkC5fpNUljLGxz.png" alt="img"></a></p><p><strong>Java中通过Selector实现多路复用</strong></p><ul><li>当没有事件时，调用select方法会被阻塞住</li><li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li></ul><p><strong>多路复用与阻塞IO的区别</strong></p><ul><li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li><li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li></ul><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418160106.png"><img src="https://s2.loli.net/2022/04/26/zHvkMNT9K8mCWon.png" alt="img"></a></p><ul><li>线程1调用方法后立即返回，<strong>不会被阻塞也不需要立即获取结果</strong></li><li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li></ul><h3 id="3、零拷贝"><a href="#3、零拷贝" class="headerlink" title="3、零拷贝"></a>3、零拷贝</h3><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li><strong>零拷贝适合小文件传输</strong></li></ul><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line">Socket socket = ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure><p><strong>内部工作流如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162306.png"><img src="https://s2.loli.net/2022/04/26/e9MbwXHrkRINmJl.png" alt="img"></a></p><ul><li><p><strong>Java 本身并不具备 IO 读写能力</strong>，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU</p><p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p></li><li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p></li></ul><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 <strong>DirectByteBuf</strong></p><ul><li>ByteBuffer.allocate(10)<ul><li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li></ul></li><li>ByteBuffer.allocateDirect (10)<ul><li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162410.png"><img src="https://s2.loli.net/2022/04/26/k4CXzt6RWwpj7an.png" alt="img"></a></p><p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p><ul><li>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列<ul><li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li></ul></li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li></ul><h4 id="进一步优化1"><a href="#进一步优化1" class="headerlink" title="进一步优化1"></a>进一步优化1</h4><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p><p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo/transferFrom</strong> 方法拷贝数据</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418162750.png"><img src="https://s2.loli.net/2022/04/26/wbsrved1c7RWAoY.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p>这种方法下</p><ul><li>只发生了1次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><h4 id="进一步优化2"><a href="#进一步优化2" class="headerlink" title="进一步优化2"></a>进一步优化2</h4><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210418163033.png"><img src="https://s2.loli.net/2022/04/26/HTCoS8pska3bwIr.png" alt="img"></a></p><ul><li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li></ul><p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p><h3 id="4、AIO"><a href="#4、AIO" class="headerlink" title="4、AIO"></a>4、AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li><li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li></ul></blockquote><h1 id="Netty入门"><a href="#Netty入门" class="headerlink" title="Netty入门"></a>Netty入门</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1、什么是Netty"><a href="#1、什么是Netty" class="headerlink" title="1、什么是Netty"></a>1、什么是Netty</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Netty is an asynchronous event-driven network application framework</span><br><span class="line">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></table></figure><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2、Netty的优势"><a href="#2、Netty的优势" class="headerlink" title="2、Netty的优势"></a>2、Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug 多</p><ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>因为bug的存在，epoll 空轮询导致 CPU 100%</li></ul><p>Netty 对 API 进行增强，使之更易用，如</p><ul><li>FastThreadLocal =&gt; ThreadLocal</li><li>ByteBuf =&gt; ByteBuffer</li></ul><h1 id="二、入门案例"><a href="#二、入门案例" class="headerlink" title="二、入门案例"></a>二、入门案例</h1><h2 id="1、服务器端代码"><a href="#1、服务器端代码" class="headerlink" title="1、服务器端代码"></a>1、服务器端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 启动器，负责组装netty组件，启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                <span class="comment">//2. BossEventLoop, WorkerEventLoop(selector+thread),循环处理事件的组</span></span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())<span class="comment">// accept、read</span></span><br><span class="line">                <span class="comment">//3. 选择服务器的Serversocketchannel实现，支持多种实现 0I0 BIO epollserversocketchannel</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//4. boss负责连接，worker（child）负责读写，决定了worker能执行哪些操作（handler）-读写解码等</span></span><br><span class="line">                .childHandler(</span><br><span class="line">                        <span class="comment">//5.代表和客户端进行数据读写的通道 Initializer初始化、负责添加其他handler</span></span><br><span class="line">                        <span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">//连接建立（accept）后调用初始化方法</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">//6. 添加具体handler</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder()); <span class="comment">//将Bytebuf转换成字符串</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123; <span class="comment">//自定义handler</span></span><br><span class="line">                            <span class="meta">@Override</span> <span class="comment">//channelRead为读事件</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//7. 绑定监听端口</span></span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、客户端代码"><a href="#2、客户端代码" class="headerlink" title="2、客户端代码"></a>2、客户端代码</h2><p>单EventLoop模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建启动器</span></span><br><span class="line">        <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                <span class="comment">//2. 添加Eventloop</span></span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                <span class="comment">//3. 选择客户端channel的实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//4. 添加处理器</span></span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">//连接建立后调用</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());<span class="comment">//把hello字符串转为bytebuf</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//5. 连接到服务器</span></span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>))</span><br><span class="line">                .sync() <span class="comment">//阻塞方法，直到连接建立</span></span><br><span class="line">                .channel() <span class="comment">//客户端和服务器端之间的socketchannel,代表连接对象</span></span><br><span class="line">                <span class="comment">//6. 向服务器发送数据</span></span><br><span class="line">                .writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、运行流程"><a href="#3、运行流程" class="headerlink" title="3、运行流程"></a>3、运行流程</h2><p><strong>左：客户端 右：服务器端</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210420132155.png"><img src="https://s2.loli.net/2022/05/03/w94A8GuXzFDCx13.png" alt="img"></a></p><p><img src="https://s2.loli.net/2022/05/03/ZPvrG8ND3HzTj5s.png" alt="image-20220503153528782"></p><h3 id="组件解释"><a href="#组件解释" class="headerlink" title="组件解释"></a>组件解释</h3><ul><li><p>channel 可以理解为数据的通道</p></li><li><p>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</p></li><li><p>handler 可以理解为数据的处理工序</p><ul><li><p>工序有多道，合在一起就是 pipeline（流水线、传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</p><ul><li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li></ul></li><li><p>handler 分 Inbound 和 Outbound 两类</p><ul><li>Inbound 入站</li><li>Outbound 出站</li></ul></li></ul></li><li><p>eventLoop 可以理解为处理数据的工人</p><ul><li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li><li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>eventLoop 按照 <strong>pipeline 顺序</strong>，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li></ul></li></ul><h1 id="三、组件"><a href="#三、组件" class="headerlink" title="三、组件"></a>三、组件</h1><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>事件处理模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The reactor design pattern is an event handling pattern for handling service requests delivered concurrently to a service handler by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to the associated request handlers.</span><br><span class="line"></span><br><span class="line">1.事件驱动（event handling）</span><br><span class="line"></span><br><span class="line">2.可以处理一个或多个输入源（one or more inputs）</span><br><span class="line"></span><br><span class="line">3.通过Service Handler同步的将输入事件（Event）采用多路复用分发给相应的Request Handler（多个）处理</span><br></pre></td></tr></table></figure><p>根据Reactor的数量和线程池的数量，又将Reactor分为三种模型:</p><ul><li><p>单线程模型 (单Reactor单线程)</p><p><img src="https://s2.loli.net/2022/05/07/bRXgHZu3MrqChnt.png" alt="img"></p><p>所谓单线程, 即Acceptor 处理和handler 处理都在同一个线程中处理。这个模型的坏处显而易见：当其中某个Handler阻塞时, 会导致其他所有的Client 的Handler 都得不到执行，并且更严重的是，Handler 的阻塞也会导致整个服务不能接收新的Client 请求(因为Acceptor 也被阻塞了)。因为有这么多的缺陷，因此单线程Reactor 模型应用场景比较少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">server.group(bossGroup);</span><br></pre></td></tr></table></figure><p>ServerBootstrap 重写了 group 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> group(group, group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此当传入一个 group 时, 那么 bossGroup 和 workerGroup 就是同一个 NioEventLoopGroup 了. 这时候呢, 因为 bossGroup 和 workerGroup 就是同一个 NioEventLoopGroup, 并且这个 NioEventLoopGroup 只有一个线程, 这样就会导致 Netty 中的 acceptor 和后续的所有客户端连接的 IO 操作都是在一个线程中处理的。那么对应到 Reactor 的线程模型中, 我们这样设置 NioEventLoopGroup 时, 就相当于 Reactor 单线程模型。</p></li><li><p>多线程模型 (单Reactor多线程)</p><p><img src="https://s2.loli.net/2022/05/07/rdInsaLOkXAqmCu.png" alt="img"></p></li></ul><p>  Reactor 多线程模型有如下特点:</p><ol><li>有专门一个线程，即Acceptor 线程用于监听客户端的TCP 连接请求。</li><li>客户端连接的IO 操作都由一个特定的NIO 线程池负责.每个客户端连接都与一个特定的NIO 线程绑定,因此在这个客户端连接中的所有IO 操作都是在同一个线程中完成的。</li><li>客户端连接有很多，但是NIO 线程数是比较少的，因此一个NIO 线程可以同时绑定到多个客户端连接中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">128</span>);</span><br><span class="line">ServerBootstrap server = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">server.group(bossGroup);</span><br></pre></td></tr></table></figure><p>我们只需要将bossGroup 的参数就设置为大于1 的数，其实就是Reactor 多线程模型。</p><p> 一般情况下, Reactor 的多线程模式已经可以很好的工作了，但是我们想象一个这样的场景：如果我们的服务器需要同时<strong>处理大量的客户端连接请求或我们需要在客户端连接时，进行一些权限的校验，那么单线程的Acceptor 很有可能就处理不过来</strong>，造成了大量的客户端不能连接到服务器。Reactor 的主从多线程模型就是在这样的情况下提出来的，它的特点是：服务器端接收客户端的连接请求不再是一个线程，而是由一个独立的线程池组成。其线程模型如下图所示：</p><ul><li><p>主从多线程模型 (多Reactor多线程)</p><p><img src="https://s2.loli.net/2022/05/07/2oIUZY5gDqvrEMK.png" alt="img"></p></li></ul><p>Reactor 的主从多线程模型和Reactor 多线程模型很类似，只不过Reactor 的主从多线程模型的Acceptor使用了<strong>线程池</strong>来处理大量的客户端请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup);</span><br></pre></td></tr></table></figure><p>bossGroup 为主线程，而workerGroup 中的线程是<strong>CPU 核心数乘以2</strong>，因此对应的到Reactor 线程模型中，我们知道, 这样设置的NioEventLoopGroup 其实就是Reactor 主从多线程模型。</p><h2 id="1、EventLoop"><a href="#1、EventLoop" class="headerlink" title="1、EventLoop"></a>1、EventLoop</h2><p><img src="https://s2.loli.net/2022/05/03/DxJWsH8vdoeQni6.png" alt="image-20220503202018203"></p><ul><li>BossEventLoopGroup 和 WorkerEventLoopGroup 包含一个或者多个 NioEventLoop。BossEventLoopGroup 负责监听客户端的 Accept 事件，当事件触发时，将事件注册至 WorkerEventLoopGroup 中的一个 NioEventLoop 上。每新建一个 Channel， 只选择一个 NioEventLoop 与其绑定。所以说 Channel 生命周期的所有事件处理都是线程独立的，不同的 NioEventLoop 线程之间不会发生任何交集。</li><li>BossEventLoop循环执行步骤<ol><li>轮询accept事件</li><li>处理accept事件，与客户端建立连接，生成NioSocketChannel,并将其注册到某个worker NioEventLoop的selector</li><li>处理任务队列中的任务，即runAllTasks</li></ol></li><li>NioEventLoop 完成数据读取后，会调用绑定的 ChannelPipeline 进行事件传播，ChannelPipeline 也是线程安全的，数据会被传递到 ChannelPipeline 的第一个 ChannelHandler 中。数据处理完成后，将加工完成的数据再传递给下一个 ChannelHandler，整个过程是串行化执行，不会发生线程上下文切换的问题。</li></ul><p><strong>事件循环对象</strong> NioEventLoop</p><p><img src="https://s2.loli.net/2022/05/07/Ap9TaCniSbl5gE3.png" alt="img"></p><p>表示<strong>一个不断循环的执行处理任务的线程</strong>， 每个NioEventLoop 都有一个selector , 用于监听绑定在其上的socket的网络通讯</p><p>它运行在一个<strong>循环</strong>中，直到它停止。网络框架需要需要在一个循环中为一个特定的连接运行事件, 伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!terminated) &#123;</span><br><span class="line">    List&lt;Runnable&gt; readyEvents = blockUntilEventsReady(); <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span> (Runnable ev: readyEvents) &#123;</span><br><span class="line">        ev.run(); <span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    NioEventLoop 继承自SingleThreadEventLoop，而SingleThreadEventLoop 又继承自SingleThreadEventExecutor。而SingleThreadEventExecutor 是Netty 中对本地线程的抽象，它内部有一个Thread thread 属性，存储了一个本地Java线程。因此我们可以简单地认为，<strong>一个NioEventLoop 其实就是和一个特定的线程绑定，并且在其生命周期内，绑定的线程都不会再改变。</strong></p><p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p><p>它的继承关系如下</p><ul><li>继承自AbstractScheduledEventExecutor，实现了NioEventLoop的<strong>schedule</strong>功能，可以通过调用一个NioEventLoop 实例的schedule 方法来运行一些定时任务</li><li><p>继承自SingleThreadEventLoop，实现了<strong>任务队列</strong>的功能，可以调用一个NioEventLoop 实例的<strong>execute()方法来向任务队列中添加一个task,并由NioEventLoop进行调度执行。</strong></p></li><li><p>继承自 j.u.c.ScheduledExecutorService 因此包含了<strong>线程池中所有的方法</strong></p></li><li>继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p><strong>主要任务</strong></p><ol><li>作为IO 线程，执行与Channel 相关的IO 操作，包括调用Selector 等待就绪的IO 事件、读写数据与数据的处理等；</li><li>作为任务队列，执行taskQueue 中的任务，例如用户调用eventLoop.schedule 提交的定时任务也是这个线程执行的。</li></ol><p><strong>事件循环组</strong> EventLoopGroup</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEventLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程</span></span><br><span class="line">        <span class="comment">//EventLoopGroup groups = new DefaultEventLoopGroup(2); //普通任务，定时任务  </span></span><br><span class="line">        </span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>); <span class="comment">// io事件，普通任务，定时任务    </span></span><br><span class="line">        <span class="comment">// 通过next方法可以获得下一个 EventLoop</span></span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过EventLoop执行普通任务</span></span><br><span class="line">        group.next().execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过EventLoop执行定时任务</span></span><br><span class="line">        group.next().scheduleAtFixedRate(()-&gt;&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; hello2&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 优雅地关闭</span></span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.nio.NioEventLoop@7bb11784</span><br><span class="line">io.netty.channel.nio.NioEventLoop@33a10788</span><br><span class="line">nioEventLoopGroup-2-1 hello</span><br><span class="line">nioEventLoopGroup-2-2 hello2</span><br><span class="line">nioEventLoopGroup-2-2 hello2</span><br><span class="line">nioEventLoopGroup-2-2 hello2</span><br></pre></td></tr></table></figure><p><strong>关闭 EventLoopGroup</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="comment">//msg:bytebuf类型 </span></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .childhandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>))</span><br><span class="line">                .sync()</span><br><span class="line">                .channel();</span><br><span class="line">        System.out.println(channel);</span><br><span class="line">        <span class="comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps: netty debug时需要注意的问题   netty是多线程，debug默认会把所有线程悬停，导致无法发送数据，设为thread会把主线程暂停，不会影响其他线程 ，执行write方法的线程不是主线程</p><p><img src="https://s2.loli.net/2022/05/04/ryUMH8KfPGiAR19.png" alt="image-20220504094830821"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nioEventLoopGroup-2-2 hello</span><br><span class="line">nioEventLoopGroup-2-2 world</span><br><span class="line">nioEventLoopGroup-2-2 ccc</span><br></pre></td></tr></table></figure><p>由此可见<strong>channel与服务器建立连接后，服务器始终拿同一个eventloop来处理客户端</strong></p><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new ServerBootstrap()</span><br><span class="line">            // 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件</span><br><span class="line">                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))</span><br><span class="line">            </span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个客户端分别发送 <code>hello</code> 结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nioEventLoopGroup-3-1 hello1</span><br><span class="line">nioEventLoopGroup-3-2 hello2</span><br><span class="line">nioEventLoopGroup-3-1 hello3</span><br><span class="line">nioEventLoopGroup-3-2 hello4</span><br><span class="line">nioEventLoopGroup-3-2 hello4</span><br></pre></td></tr></table></figure><p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel(多路复用)，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png"><img src="https://s2.loli.net/2022/05/03/buzMBO9fDknjUid.png" alt="img"></a></p><h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 增加自定义的非NioEventLoopGroup</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> DefaultEventLoopGroup();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;nioHandler&quot;</span>,<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                                <span class="comment">// 调用下一个handler</span></span><br><span class="line">                                ctx.fireChannelRead(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        <span class="comment">// 该handler绑定自定义的Group</span></span><br><span class="line">                        .addLast(group, <span class="string">&quot;myHandler&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动四个客户端发送数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nioEventLoopGroup-4-1 hello1</span><br><span class="line">defaultEventLoopGroup-2-1 hello1</span><br><span class="line">nioEventLoopGroup-4-2 hello2</span><br><span class="line">defaultEventLoopGroup-2-2 hello2</span><br><span class="line">nioEventLoopGroup-4-1 hello3</span><br><span class="line">defaultEventLoopGroup-2-3 hello3</span><br><span class="line">nioEventLoopGroup-4-2 hello4</span><br><span class="line">defaultEventLoopGroup-2-4 hello4</span><br></pre></td></tr></table></figure><p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103607.png"><img src="https://s2.loli.net/2022/05/03/uiRemrxjLqHYMbN.png" alt="img"></a></p><h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p><p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span></span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span></span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li></ul><h2 id="2、Channel"><a href="#2、Channel" class="headerlink" title="2、Channel"></a>2、Channel</h2><p>Channel 的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li><strong>sync</strong> 方法作用是<strong>同步</strong>等待 Channel 关闭</li><li>而 <strong>addListener</strong> 方法是<strong>异步</strong>等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write() 方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>ps:  带有future、promise的类型都是和异步方法配套使用，用来处理结果</p><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p><strong>拆分客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span></span><br><span class="line">            <span class="comment">// NIO线程：NioEventLoop 中的线程</span></span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));<span class="comment">//返回channelFuture对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 该方法用于等待连接真正建立</span></span><br><span class="line">        channelFuture.sync();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取客户端-服务器之间的Channel对象</span></span><br><span class="line">        <span class="comment">//若不sync，则无阻塞向下执行获取channel,该channel还未建立连接则无法发送数据</span></span><br><span class="line">        Channel channel = channelFuture.channel();</span><br><span class="line">        channel.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的主线程是<strong>异步非阻塞</strong>的，真正执行connect是nioeventloopgroup的一个线程，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><p><strong>addListener方法</strong></p><p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span></span><br><span class="line">                <span class="comment">// NIO线程：NioEventLoop 中的线程</span></span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 当connect方法执行完毕后，也就是连接真正建立后</span></span><br><span class="line">        <span class="comment">// 会在NIO线程中调用operationComplete方法</span></span><br><span class="line">        channelFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="comment">//nio线程连接建立之后，调用该方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Channel channel = channelFuture.channel();</span><br><span class="line">                channel.writeAndFlush(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建EventLoopGroup，使用完毕后关闭</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        </span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        channelFuture.sync();</span><br><span class="line"></span><br><span class="line">        Channel channel = channelFuture.channel();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程用于输入并向服务器发送</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                String msg = scanner.next();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(msg)) &#123;</span><br><span class="line">                    <span class="comment">// 关闭操作是异步的，在NIO线程中执行</span></span><br><span class="line">                    channel.close();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;inputThread&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得closeFuture对象</span></span><br><span class="line">        ChannelFuture closeFuture = channel.closeFuture();</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting close...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 同步等待NIO线程执行完close操作</span></span><br><span class="line">        closeFuture.sync();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;关闭之后执行一些额外操作...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭EventLoopGroup</span></span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关闭channel</strong></p><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p><ul><li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，<strong>等待channel真正关闭后，再执行其他操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得closeFuture对象</span></span><br><span class="line">ChannelFuture closeFuture = channel.closeFuture();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步等待NIO线程执行完close操作</span></span><br><span class="line">closeFuture.sync();</span><br></pre></td></tr></table></figure></li><li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">closeFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 等待channel关闭后才执行的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;关闭之后执行一些额外操作...&quot;</span>);</span><br><span class="line">        <span class="comment">// 关闭EventLoopGroup</span></span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="3、Future与Promise"><a href="#3、Future与Promise" class="headerlink" title="3、Future与Promise"></a>3、Future与Promise</h2><p>netty为什么要异步？提升效率。图2是图1的4倍 </p><p><img src="https://s2.loli.net/2022/05/05/MFcU6SARsToxfzp.png" alt="image-20220505151711909"></p><p><img src="https://s2.loli.net/2022/05/05/vgU6CoKwqG87rHf.png" alt="image-20220505151635029"></p><p>要点：</p><ul><li>单线程没法异步提升效率，必须配合<strong>多线程、多核cpu</strong>才能发挥异步优势</li><li>异步并没有缩短响应时间，反而有所增加（<strong>每个请求的响应时间变长，增加的是吞吐量</strong>）</li><li>合理进行任务拆分，也是异步的关键</li></ul><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future <strong>继承自 jdk 的 Future</strong>，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><div class="table-container"><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table></div><h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ThreadFactory factory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">&quot;JdkFuture&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>,<span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>), factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得Future对象，通过该对象将结果交给主线程 submit代替execute（没有返回结果）</span></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过阻塞的方式，获得运行结果 （同步等待）</span></span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK-CompletableFuture"><a href="#JDK-CompletableFuture" class="headerlink" title="JDK CompletableFuture"></a>JDK CompletableFuture</h3><p>java8</p><ul><li><p>Future虽然可以实现获取异步执行结果的需求，但是它没有提供通知的机制，我们无法得知Future什么时候完成。</p></li><li><p>要么使用阻塞，在future.get()的地方等待future返回的结果，这时又变成同步操作。要么使用isDone()轮询地判断Future是否完成，这样会耗费CPU的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个异步任务</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(()-&gt;&#123;</span><br><span class="line">       Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//轮询获取结果</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(future.isDone()) &#123;</span><br><span class="line">         System.out.println(future.get());</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>CompletableFuture能够将回调放到与任务不同的线程中执行，也能将回调作为继续执行的同步函数，在与任务相同的线程中执行。它避免了传统回调最大的问题，那就是能够将控制流分离到不同的事件处理器中。</p><p>CompletableFuture弥补了Future模式的缺点。在异步的任务完成后，需要用其结果继续操作时，无需等待。可以直接通过thenAccept、thenApply、thenCompose等方式将前面异步处理的结果交给另外一个异步事件处理线程来处理。</p><p>CompletableFuture提供了四个静态方法用来创建CompletableFuture对象：<br><img src="https://img-blog.csdnimg.cn/2019113016212652.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YXh1bjY2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 EventLoop 对象</span></span><br><span class="line">        EventLoop eventLoop = group.next();</span><br><span class="line">        Future&lt;Integer&gt; future = eventLoop.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程中获取结果</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取结果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;getNow &quot;</span> + future.getNow());</span><br><span class="line">        System.out.println(<span class="string">&quot;get &quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// NIO线程中异步获取结果</span></span><br><span class="line">        future.addListener(<span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Integer&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取结果&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;getNow &quot;</span> + future.getNow());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main 获取结果</span><br><span class="line">getNow null</span><br><span class="line">get 50</span><br><span class="line">nioEventLoopGroup-2-1 获取结果</span><br><span class="line">getNow 50</span><br></pre></td></tr></table></figure><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li><li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li></ul><h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个<strong>容器</strong>，可以用于<strong>存放各个线程中的结果</strong>，然后让其他线程去获取该结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyPromise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建EventLoop</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoop eventLoop = group.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Promise对象，用于存放结果</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自定义线程向Promise中存放结果</span></span><br><span class="line">            promise.setSuccess(<span class="number">50</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程从Promise中获取结果</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + promise.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Handler与Pipeline"><a href="#4、Handler与Pipeline" class="headerlink" title="4、Handler与Pipeline"></a>4、Handler与Pipeline</h2><p>ChannelHandler用来处理Channel上的各种事件，分为入站、出站两种。所有ChannelHandler被连成一串，就是pipeline。</p><ul><li>入站处理器通常是ChannelInboundHandlerAdapter的子类，主要用来读取客户端数据，写回结果</li><li>出站处理器通常是ChannelOutboundHandlerAdapter的子类, 用来对写回结果进行加工</li></ul><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipeLineServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 在socketChannel的pipeline中添加handler</span></span><br><span class="line">                        <span class="comment">// pipeline中handler是带有head与tail节点的双向链表，的实际结构为</span></span><br><span class="line">     <span class="comment">// head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail</span></span><br><span class="line">                        <span class="comment">// Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法</span></span><br><span class="line">                        <span class="comment">// 入站时，handler是从head向后调用的</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;handler1&quot;</span> ,<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Inbound handler 1&quot;</span>);</span><br><span class="line">                                <span class="comment">// 父类该方法内部会调用fireChannelRead</span></span><br><span class="line">                                <span class="comment">// 将数据传递给下一个handler</span></span><br><span class="line">                                <span class="comment">//或者直接调用ctx.firechannelread</span></span><br><span class="line">                                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;handler2&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Inbound handler 2&quot;</span>);</span><br><span class="line">                                <span class="comment">// 执行write操作，使得Outbound的方法能够得到调用</span></span><br><span class="line">          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="string">&quot;Server...&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">                                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="comment">// Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法</span></span><br><span class="line">                        <span class="comment">// 出站时，handler的调用是从tail向前调用的</span></span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;handler3&quot;</span> ,<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Outbound handler 1&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        socketChannel.pipeline().addLast(<span class="string">&quot;handler4&quot;</span> ,<span class="keyword">new</span> ChannelOutboundHandlerAdapter()&#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Outbound handler 2&quot;</span>);</span><br><span class="line">                                <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nioEventLoopGroup-2-2 Inbound handler 1</span><br><span class="line">nioEventLoopGroup-2-2 Inbound handler 2</span><br><span class="line">nioEventLoopGroup-2-2 Outbound handler 2</span><br><span class="line">nioEventLoopGroup-2-2 Outbound handler 1</span><br></pre></td></tr></table></figure><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><strong>具体结构如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423102354.png"><img src="https://s2.loli.net/2022/05/05/PQc67H3OhAxMvrR.png" alt="img"></a></p><p><strong>调用顺序如下</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423105200.png"><img src="https://s2.loli.net/2022/05/05/YfpjRLCTik1tmXx.png" alt="img"></a></p><h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122010.png"><img src="https://s2.loli.net/2022/05/05/GoJ4haliAW86L2w.png" alt="img"></a></p><h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423122050.png"><img src="https://s2.loli.net/2022/05/05/vHcJzqyNoSKfIBx.png" alt="img"></a></p><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEmbeddedChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChannelInboundHandlerAdapter h1 = <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChannelInboundHandlerAdapter h2 = <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChannelOutboundHandlerAdapter h3 = <span class="keyword">new</span> ChannelOutboundHandlerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ChannelOutboundHandlerAdapter h4 = <span class="keyword">new</span> ChannelOutboundHandlerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">                <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于测试Handler的Channel</span></span><br><span class="line">        EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(h1, h2, h3, h4);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行Inbound操作 </span></span><br><span class="line">        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        <span class="comment">// 执行Outbound操作</span></span><br><span class="line">        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、ByteBuf"><a href="#5、ByteBuf" class="headerlink" title="5、ByteBuf"></a>5、ByteBuf</h2><p><strong>调试工具方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(ByteBuf buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = buffer.readableBytes();</span><br><span class="line">    <span class="keyword">int</span> rows = length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法可以帮助我们更为详细地查看ByteBuf中的内容</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ByteBuf</span></span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">16</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向buffer中写入数据</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看写入结果</span></span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:0 capacity:16</span><br><span class="line"></span><br><span class="line">read index:0 write index:20 capacity:64</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|</span><br><span class="line">|00000010| 61 61 61 61                                     |aaaa            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+Copy</span><br></pre></td></tr></table></figure><p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p><p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p><p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>(系统内存)的ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>验证</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ByteBufStudy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(16);</span><br><span class="line">        System.out.println(buffer.getClass());</span><br><span class="line"></span><br><span class="line">        buffer = ByteBufAllocator.DEFAULT.heapBuffer(16);</span><br><span class="line">        System.out.println(buffer.getClass());</span><br><span class="line"></span><br><span class="line">        buffer = ByteBufAllocator.DEFAULT.directBuffer(16);</span><br><span class="line">        System.out.println(buffer.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 使用池化的直接内存</span><br><span class="line">class io.netty.buffer.PooledUnsafeDirectByteBuf</span><br><span class="line">    </span><br><span class="line">// 使用池化的堆内存    </span><br><span class="line">class io.netty.buffer.PooledUnsafeHeapByteBuf</span><br><span class="line">    </span><br><span class="line">// 使用池化的直接内存    </span><br><span class="line">class io.netty.buffer.PooledUnsafeDirectByteBuf</span><br></pre></td></tr></table></figure><h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更<strong>节约内存，减少内存溢出</strong>的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><p><img src="https://s2.loli.net/2022/05/07/Ynbz8AIxQi2To6O.png" alt="image-20220507154153893"></p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p><ul><li><p>最大容量与当前容量</p><ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li><p>读写操作不同于ByteBuffer只用position进行控制，</p><p>ByteBuf分别由读指针和写指针两个指针控制</p><p>。进行读写操作时，无需进行模式的切换</p><ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423143030.png"><img src="https://s2.loli.net/2022/05/07/Nq6me3Fw1Mf7CSY.png" alt="img"></a></p><h3 id="写入-1"><a href="#写入-1" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p><div class="table-container"><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>**用一字节 01\</td><td>00 代表 true\</td><td>false**</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td></tr></tbody></table></div><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ByteBuf</span></span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向buffer中写入数据</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        buffer.writeIntLE(<span class="number">6</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        buffer.writeLong(<span class="number">7</span>);</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">read index:<span class="number">0</span> write index:<span class="number">0</span> capacity:<span class="number">16</span></span><br><span class="line"></span><br><span class="line">read index:<span class="number">0</span> write index:<span class="number">4</span> capacity:<span class="number">16</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">read index:<span class="number">0</span> write index:<span class="number">8</span> capacity:<span class="number">16</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">read index:<span class="number">0</span> write index:<span class="number">12</span> capacity:<span class="number">16</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">read index:<span class="number">0</span> write index:<span class="number">20</span> capacity:<span class="number">20</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |................|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">07</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeLong(<span class="number">7</span>);</span><br><span class="line">ByteBufUtil.log(buffer);</span><br><span class="line"><span class="comment">// 扩容前</span></span><br><span class="line">read index:<span class="number">0</span> write index:<span class="number">12</span> capacity:<span class="number">16</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容后</span></span><br><span class="line">read index:<span class="number">0</span> write index:<span class="number">20</span> capacity:<span class="number">20</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> <span class="number">06</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |................|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">07</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul><li>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容<ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li>如果写入后数据大小超过 512 字节，则选择下一个 2n<ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 210=1024 字节（29=512 已经不够了）</li></ul></li><li>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20/20)</span><br><span class="line">...Copy</span><br></pre></td></tr></table></figure><h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ByteBuf</span></span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向buffer中写入数据</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        buffer.writeInt(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取4个字节</span></span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        System.out.println(buffer.readByte());</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过mark与reset实现重复读取</span></span><br><span class="line">        buffer.markReaderIndex();</span><br><span class="line">        System.out.println(buffer.readInt());</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复到mark标记处</span></span><br><span class="line">        buffer.resetReaderIndex();</span><br><span class="line">        ByteBufUtil.log(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">read index:<span class="number">4</span> write index:<span class="number">8</span> capacity:<span class="number">16</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"><span class="number">5</span></span><br><span class="line">read index:<span class="number">8</span> write index:<span class="number">8</span> capacity:<span class="number">16</span></span><br><span class="line"></span><br><span class="line">read index:<span class="number">4</span> write index:<span class="number">8</span> capacity:<span class="number">16</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了<strong>引用计数法</strong>来控制回收内存，每个 ByteBuf 都实现了 <strong>ReferenceCounted</strong> 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!buffer.release()) &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 具体的释放方法</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> msg <span class="keyword">instanceof</span> ReferenceCounted ? ((ReferenceCounted)msg).release() : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210423154059.png"><img src="https://s2.loli.net/2022/05/07/rJ2gbazqDWOfjM9.png" alt="img"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSlice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建ByteBuf</span></span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(<span class="number">16</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向buffer中写入数据</span></span><br><span class="line">        buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将buffer分成两部分</span></span><br><span class="line">        ByteBuf slice1 = buffer.slice(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        ByteBuf slice2 = buffer.slice(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要让分片的buffer引用计数加一</span></span><br><span class="line">        <span class="comment">// 避免原Buffer释放导致分片buffer无法使用</span></span><br><span class="line">        slice1.retain();</span><br><span class="line">        slice2.retain();</span><br><span class="line">        </span><br><span class="line">        ByteBufUtil.log(slice1);</span><br><span class="line">        ByteBufUtil.log(slice2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改原始buffer中的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========修改原buffer中的值===========&quot;</span>);</span><br><span class="line">        buffer.setByte(<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===========打印slice1===========&quot;</span>);</span><br><span class="line">        ByteBufUtil.log(slice1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">read index:<span class="number">0</span> write index:<span class="number">5</span> capacity:<span class="number">5</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span>                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">read index:<span class="number">0</span> write index:<span class="number">5</span> capacity:<span class="number">5</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">06</span> <span class="number">07</span> 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">===========修改原buffer中的值===========</span><br><span class="line">===========打印slice1===========</span><br><span class="line">read index:<span class="number">0</span> write index:<span class="number">5</span> capacity:<span class="number">5</span></span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">05</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span>                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>切片后不允许再添加内容</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h1 id="四、应用"><a href="#四、应用" class="headerlink" title="四、应用"></a>四、应用</h1><h2 id="1、粘包与半包"><a href="#1、粘包与半包" class="headerlink" title="1、粘包与半包"></a>1、粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用时统一通过slf4j-api包中的类org.slf4j.LoggerFactory来获取具体的Logger对象。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//netty自带日志框架</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 连接建立时会执行该方法</span></span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 连接断开时会执行该方法</span></span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="keyword">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            <span class="comment">// 关闭channel</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stopped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> StudyServer().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(StudyClient.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connected...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 每次发送16个字节的数据，共发送10次</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                                buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器接收结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7999</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x5b43ecb0</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">53797</span>] READ: 160B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000030</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000040</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000050</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000060</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000070</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|00000080| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|00000090| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p><p><strong>服务器代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调整channel的容量</span></span><br><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote><p><strong>服务器接收结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5901</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0xc73284f3</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">49679</span>] READ: 36B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">5901</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0xc73284f3</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">49679</span>] READ: 40B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> |................|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> |................|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">5901</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0xc73284f3</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">49679</span>] READ: 40B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| 0c <span class="number">0d</span> 0e <span class="number">0f</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b |................|</span><br><span class="line">|<span class="number">00000010</span>| 0c <span class="number">0d</span> 0e <span class="number">0f</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b |................|</span><br><span class="line">|<span class="number">00000020</span>| 0c <span class="number">0d</span> 0e <span class="number">0f</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span>                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">5901</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0xc73284f3</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">49679</span>] READ: 40B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> |................|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> |................|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">5901</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0xc73284f3</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">49679</span>] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| 0c <span class="number">0d</span> 0e <span class="number">0f</span>                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+Copy</span><br></pre></td></tr></table></figure><p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><p>只要用tcp协议进行处理，都会有半包粘包现象 (NIO基础 4.3 处理消息边界）</p><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><blockquote><p>滑动窗口</p><ul><li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p><p><img src="E:/JavaDocument/学习笔记/netty/讲义/img/0049.png" alt=""></p></li></ul><ul><li><p>为了解决此问题，引入了窗口概念，窗口大小即<strong>决定了无需等待应答而可以继续发送的数据最大值</strong></p><p><img src="E:/JavaDocument/学习笔记/netty/讲义/img/0051.png" alt=""></p></li><li><p>窗口实际就起到一个<strong>缓冲区</strong>的作用，同时也能起到<strong>流量控制</strong>的作用</p><ul><li>图中深色的部分即要发送的数据，高亮的部分即窗口</li><li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li><li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li><li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li></ul></li></ul><p> MSS 限制</p><ul><li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p><ul><li>以太网的 MTU 是 1500</li><li>FDDI（光纤分布式数据接口）的 MTU 是 4352</li><li>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</li></ul></li><li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p><ul><li>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460</li><li>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</li><li>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</li></ul><p><img src="https://s2.loli.net/2022/05/09/lpFaBDNvPhZoSGn.jpg" style="zoom:50%;" /></p></li></ul><p>Nagle 算法</p><ul><li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li><li>该算法是指<strong>发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送</strong><ul><li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li><li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li><li>如果 TCP_NODELAY = true，则需要发送</li><li>已发送的数据都收到 ack 时，则需要发送</li><li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li><li>除上述情况，延迟发送</li></ul></li></ul></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改channelActive方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">    ByteBuf buffer = ctx.alloc().buffer(<span class="number">16</span>);</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">    ctx.writeAndFlush(buffer);</span><br><span class="line">    <span class="comment">// 使用短链接，每次发送完毕后就断开连接</span></span><br><span class="line">    ctx.channel().close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 发送10次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6452</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x3eb6a684</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">65024</span>] ACTIVE</span><br><span class="line"></span><br><span class="line"><span class="number">6468</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x3eb6a684</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">65024</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">6468</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x3eb6a684</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">65024</span>] INACTIVE</span><br><span class="line"></span><br><span class="line"><span class="number">6483</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x7dcc31ff</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">65057</span>] ACTIVE</span><br><span class="line"></span><br><span class="line"><span class="number">6483</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x7dcc31ff</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">65057</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">00</span> <span class="number">01</span> <span class="number">02</span> <span class="number">03</span> <span class="number">04</span> <span class="number">05</span> <span class="number">06</span> <span class="number">07</span> 08 09 0a 0b 0c <span class="number">0d</span> 0e <span class="number">0f</span> |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">6483</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x7dcc31ff</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> ! R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">65057</span>] INACTIVE</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">16</span>));</span><br></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约定最大长度为16</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxLength = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 被发送的数据</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">// 向服务器发送10个报文</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    ByteBuf buffer = ctx.alloc().buffer(maxLength);</span><br><span class="line">    <span class="comment">// 定长byte数组，未使用部分会以0进行填充</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[maxLength];</span><br><span class="line">    <span class="comment">// 生成长度为0~15的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)(Math.random()*(maxLength-<span class="number">1</span>)); j++) &#123;</span><br><span class="line">        bytes[j] = (<span class="keyword">byte</span>) c;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.writeBytes(bytes);</span><br><span class="line">    c++;</span><br><span class="line">    <span class="comment">// 将数据发送给服务器</span></span><br><span class="line">    ctx.writeAndFlush(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过定长解码器对粘包数据进行拆分</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">16</span>));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8222</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0xbc122d07</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">52954</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |aaaa............|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">8222</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0xbc122d07</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">52954</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |bbb.............|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8222</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0xbc122d07</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">52954</span>] READ: 16B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">63</span> <span class="number">63</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> |cc..............|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)</strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来<strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 约定最大长度为 64</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxLength = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 被发送的数据</span></span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    ByteBuf buffer = ctx.alloc().buffer(maxLength);</span><br><span class="line">    <span class="comment">// 生成长度为0~62的数据</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)(random.nextInt(maxLength-<span class="number">2</span>)); j++) &#123;</span><br><span class="line">        sb.append(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据以 \n 结尾</span></span><br><span class="line">    sb.append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    c++;</span><br><span class="line">    <span class="comment">// 将数据发送给服务器</span></span><br><span class="line">    ctx.writeAndFlush(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过行解码器对粘包数据进行拆分，以 \n 为分隔符</span></span><br><span class="line"><span class="comment">// 需要指定最大长度</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">64</span>));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4184</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x9d6ac701</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58282</span>] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>                   |aaaaaaaaaa      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">4184</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x9d6ac701</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58282</span>] READ: 11B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span>                |bbbbbbbbbbb     |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">4184</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x9d6ac701</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58282</span>] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">63</span> <span class="number">63</span>                                           |cc              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 数据以 \c 结尾</span></span><br><span class="line">sb.append(<span class="string">&quot;\\c&quot;</span>);</span><br><span class="line">buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分隔符放入ByteBuf中</span></span><br><span class="line">ByteBuf bufSet = ch.alloc().buffer().writeBytes(<span class="string">&quot;\\c&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"><span class="comment">// 通过行解码器对粘包数据进行拆分，以 \c 为分隔符</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">64</span>, ch.alloc().buffer().writeBytes(bufSet)));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 14B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62                                        |bbb             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line">...Copy</span><br></pre></td></tr></table></figure><h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LengthFieldBasedFrameDecoder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> maxFrameLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> lengthFieldOffset, <span class="keyword">int</span> lengthFieldLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> lengthAdjustment, <span class="keyword">int</span> initialBytesToStrip)</span></span></span><br></pre></td></tr></table></figure><p><strong>参数解析</strong></p><ul><li>maxFrameLength 数据最大长度<ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li>initialBytesToStrip <strong>数据读取起点</strong><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210425200007.png"><img src="https://s2.loli.net/2022/05/08/qsU7G3u4ZIhyjB8.png" alt="img"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lengthFieldOffset   = <span class="number">0</span></span><br><span class="line">lengthFieldLength   = <span class="number">2</span></span><br><span class="line">lengthAdjustment    = <span class="number">0</span></span><br><span class="line">initialBytesToStrip = <span class="number">0</span> (= <span class="keyword">do</span> not strip header)</span><br><span class="line">  </span><br><span class="line"><span class="function">BEFORE <span class="title">DECODE</span> <span class="params">(<span class="number">14</span> bytes)</span>         AFTER <span class="title">DECODE</span> <span class="params">(<span class="number">14</span> bytes)</span></span></span><br><span class="line"><span class="function">+--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="function">| Length | Actual Content |-----&gt;| Length | Actual Content |</span></span><br><span class="line"><span class="function">| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |</span></span><br><span class="line"><span class="function">+--------+----------------+      +--------+----------------+</span></span><br></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lengthFieldOffset   = <span class="number">0</span></span><br><span class="line">lengthFieldLength   = <span class="number">2</span></span><br><span class="line">lengthAdjustment    = <span class="number">0</span></span><br><span class="line">initialBytesToStrip = <span class="number">2</span> (= the length of the Length field)</span><br><span class="line">  </span><br><span class="line"><span class="function">BEFORE <span class="title">DECODE</span> <span class="params">(<span class="number">14</span> bytes)</span>         AFTER <span class="title">DECODE</span> <span class="params">(<span class="number">12</span> bytes)</span></span></span><br><span class="line"><span class="function">+--------+----------------+      +----------------+</span></span><br><span class="line"><span class="function">| Length | Actual Content |-----&gt;| Actual Content |</span></span><br><span class="line"><span class="function">| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |</span></span><br><span class="line"><span class="function">+--------+----------------+      +----------------+</span></span><br></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lengthFieldOffset   = 2 (= the length of Header 1)</span><br><span class="line">lengthFieldLength   = 3</span><br><span class="line">lengthAdjustment    = 0</span><br><span class="line">initialBytesToStrip = 0</span><br><span class="line">  </span><br><span class="line">BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)</span><br><span class="line">+----------+----------+----------------+      +----------+----------+----------------+</span><br><span class="line">| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |</span><br><span class="line">|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |</span><br><span class="line">+----------+----------+----------------+      +----------+----------+----------------+</span><br></pre></td></tr></table></figure><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lengthFieldOffset   = 0</span><br><span class="line">lengthFieldLength   = 3</span><br><span class="line">lengthAdjustment    = 2 (= the length of Header 1)</span><br><span class="line">initialBytesToStrip = 0</span><br><span class="line">  </span><br><span class="line">BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)</span><br><span class="line">+----------+----------+----------------+      +----------+----------+----------------+</span><br><span class="line">|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |</span><br><span class="line">| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |</span><br><span class="line">+----------+----------+----------------+      +----------+----------+----------------+</span><br></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p><p>长度标识(0x00000C)表示的是<strong>从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code></strong>，不包括0xCAFE</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lengthFieldOffset   = 1 (= the length of HDR1)</span><br><span class="line">lengthFieldLength   = 2</span><br><span class="line">lengthAdjustment    = 1 (= the length of HDR2)</span><br><span class="line">initialBytesToStrip = 3 (= the length of HDR1 + LEN)</span><br><span class="line">  </span><br><span class="line">BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)</span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br><span class="line">| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |</span><br><span class="line">| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |</span><br><span class="line">+------+--------+------+----------------+      +------+----------------+</span><br></pre></td></tr></table></figure><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p><hr><p><strong>使用</strong></p><p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncoderStudy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟服务器</span></span><br><span class="line">        <span class="comment">// 使用EmbeddedChannel测试handler</span></span><br><span class="line">        EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">                <span class="comment">// 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）</span></span><br><span class="line">                <span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">                <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟客户端，写入数据</span></span><br><span class="line">        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        send(buffer, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        channel.writeInbound(buffer);</span><br><span class="line">        send(buffer, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">        channel.writeInbound(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(ByteBuf buf, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到数据的长度</span></span><br><span class="line">        <span class="keyword">int</span> length = msg.length();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = msg.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="comment">// 将数据信息写入buf</span></span><br><span class="line">        <span class="comment">// 写入长度标识前的其他信息</span></span><br><span class="line">        buf.writeByte(<span class="number">0xCA</span>);</span><br><span class="line">        <span class="comment">// 写入数据长度标识</span></span><br><span class="line">        buf.writeInt(length);</span><br><span class="line">        <span class="comment">// 写入长度标识后的其他信息</span></span><br><span class="line">        buf.writeByte(<span class="number">0xFE</span>);</span><br><span class="line">        <span class="comment">// 写入具体的数据</span></span><br><span class="line">        buf.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">146</span>  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| ca <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> fe <span class="number">48</span> <span class="number">65</span> 6c 6c <span class="number">6f</span>                |......Hello     |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line"></span><br><span class="line"><span class="number">146</span>  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| ca <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">05</span> fe <span class="number">57</span> <span class="number">6f</span> <span class="number">72</span> 6c <span class="number">64</span>                |......World     |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h2 id="2、协议设计与解析"><a href="#2、协议设计与解析" class="headerlink" title="2、协议设计与解析"></a>2、协议设计与解析</h2><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP/IP 中消息传输基于流的方式，没有边界</p><p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该指令一共有3部分，每条指令之后都要添加回车与换行符</span></span><br><span class="line">*<span class="number">3</span>\r\n</span><br><span class="line"><span class="comment">// 第一个指令的长度是3</span></span><br><span class="line">$<span class="number">3</span>\r\n</span><br><span class="line"><span class="comment">// 第一个指令是set指令</span></span><br><span class="line">set\r\n</span><br><span class="line"><span class="comment">// 下面的指令以此类推</span></span><br><span class="line">$<span class="number">4</span>\r\n</span><br><span class="line">name\r\n</span><br><span class="line">$<span class="number">5</span>\r\n</span><br><span class="line">Nyima\r\n</span><br></pre></td></tr></table></figure><p><strong>客户端代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group =  <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                            <span class="comment">// 打印日志</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                    <span class="comment">// 回车与换行符</span></span><br><span class="line">                                    <span class="keyword">final</span> <span class="keyword">byte</span>[] LINE = &#123;<span class="string">&#x27;\r&#x27;</span>,<span class="string">&#x27;\n&#x27;</span>&#125;;</span><br><span class="line">                                    <span class="comment">// 获得ByteBuf</span></span><br><span class="line">                                    ByteBuf buffer = ctx.alloc().buffer();</span><br><span class="line">                                    <span class="comment">// 连接建立后，向Redis中发送一条指令，注意添加回车与换行</span></span><br><span class="line">                                    <span class="comment">// set name Nyima</span></span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    <span class="comment">//长度:4个字节</span></span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;$4&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;name&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);                                 </span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;$5&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    buffer.writeBytes(<span class="string">&quot;Nyima&quot;</span>.getBytes());</span><br><span class="line">                                    buffer.writeBytes(LINE);</span><br><span class="line">                                    ctx.writeAndFlush(buffer);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>));</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            <span class="comment">// 关闭channel</span></span><br><span class="line">            channelFuture.channel().close().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭group</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>控制台打印结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1600 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x28c994f1, L:/127.0.0.1:60792 - R:localhost/127.0.0.1:6379] WRITE: 34B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|</span><br><span class="line">|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 4e 79 69 6d 61 |.name..$5..Nyima|</span><br><span class="line">|00000020| 0d 0a                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+Copy</span><br></pre></td></tr></table></figure><p><strong>Redis中查询执行结果</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png" alt="img"></a></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder</span></span><br><span class="line"><span class="comment">// Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServerCodec</span> <span class="keyword">extends</span> <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">HttpRequestDecoder</span>, <span class="title">HttpResponseEncoder</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">HttpServerUpgradeHandler</span>.<span class="title">SourceCodecCopy</span></span></span><br></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(StudyServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">                        <span class="comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">                        <span class="comment">// 服务器只处理HTTPRequest,对上一步编解码器的结果（HttpRequest类型）进行处理</span></span><br><span class="line">                        <span class="comment">//SimpleChannelInboundHandler:只关心某种类型的消息</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> </span>&#123;</span><br><span class="line">                                <span class="comment">// 获得请求uri</span></span><br><span class="line">                                log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 获得完整响应，设置版本号与状态码</span></span><br><span class="line">                                DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line">                                <span class="comment">// 设置响应内容</span></span><br><span class="line">                                <span class="keyword">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">                                <span class="comment">// 设置响应体长度，避免浏览器一直接收响应内容</span></span><br><span class="line">                                response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line">                                <span class="comment">// 设置响应体</span></span><br><span class="line">                                response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 写回响应</span></span><br><span class="line">                                ctx.writeAndFlush(response);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        <span class="comment">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125; else if (msg instanceof HttpContent) &#123; //请求体</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);*/</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器只处理HTTPRequest</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;HttpRequest&gt;()</span><br></pre></td></tr></table></figure><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得完整响应，设置版本号与状态码</span></span><br><span class="line">DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"><span class="comment">// 设置响应内容</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">// 设置响应体长度，避免浏览器一直接收响应内容</span></span><br><span class="line">response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line"><span class="comment">// 设置响应体</span></span><br><span class="line">response.content().writeBytes(bytes);</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>浏览器</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png"><img src="https://s2.loli.net/2022/05/09/GLwBcozgS5IsdW4.png" alt="img"></a></p><p>控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求内容</span></span><br><span class="line"><span class="number">1714</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x72630ef7</span>, L:/<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span>:<span class="number">8080</span> - R:/<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span>:<span class="number">55503</span>] READ: 688B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">47</span> <span class="number">45</span> <span class="number">54</span> <span class="number">20</span> <span class="number">2f</span> <span class="number">66</span> <span class="number">61</span> <span class="number">76</span> <span class="number">69</span> <span class="number">63</span> <span class="number">6f</span> 6e 2e <span class="number">69</span> <span class="number">63</span> <span class="number">6f</span> |GET /favicon.ico|</span><br><span class="line">|<span class="number">00000010</span>| <span class="number">20</span> <span class="number">48</span> <span class="number">54</span> <span class="number">54</span> <span class="number">50</span> <span class="number">2f</span> <span class="number">31</span> 2e <span class="number">31</span> <span class="number">0d</span> 0a <span class="number">48</span> <span class="number">6f</span> <span class="number">73</span> <span class="number">74</span> 3a | HTTP/<span class="number">1.1</span>..Host:|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">20</span> 6c <span class="number">6f</span> <span class="number">63</span> <span class="number">61</span> 6c <span class="number">68</span> <span class="number">6f</span> <span class="number">73</span> <span class="number">74</span> 3a <span class="number">38</span> <span class="number">30</span> <span class="number">38</span> <span class="number">30</span> <span class="number">0d</span> | localhost:<span class="number">8080.</span>|</span><br><span class="line">|<span class="number">00000030</span>| 0a <span class="number">43</span> <span class="number">6f</span> 6e 6e <span class="number">65</span> <span class="number">63</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6f</span> 6e 3a <span class="number">20</span> 6b <span class="number">65</span> <span class="number">65</span> |.Connection: kee|</span><br><span class="line">|<span class="number">00000040</span>| <span class="number">70</span> <span class="number">2d</span> <span class="number">61</span> 6c <span class="number">69</span> <span class="number">76</span> <span class="number">65</span> <span class="number">0d</span> 0a <span class="number">50</span> <span class="number">72</span> <span class="number">61</span> <span class="number">67</span> <span class="number">6d</span> <span class="number">61</span> 3a |p-alive..Pragma:|</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应内容</span></span><br><span class="line"><span class="number">1716</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">2</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x72630ef7</span>, L:/<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span>:<span class="number">8080</span> - R:/<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">1</span>:<span class="number">55503</span>] WRITE: 61B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| <span class="number">48</span> <span class="number">54</span> <span class="number">54</span> <span class="number">50</span> <span class="number">2f</span> <span class="number">31</span> 2e <span class="number">31</span> <span class="number">20</span> <span class="number">32</span> <span class="number">30</span> <span class="number">30</span> <span class="number">20</span> <span class="number">4f</span> 4b <span class="number">0d</span> |HTTP/<span class="number">1.1</span> <span class="number">200</span> OK.|</span><br><span class="line">|<span class="number">00000010</span>| 0a <span class="number">43</span> <span class="number">6f</span> 6e <span class="number">74</span> <span class="number">65</span> 6e <span class="number">74</span> <span class="number">2d</span> 4c <span class="number">65</span> 6e <span class="number">67</span> <span class="number">74</span> <span class="number">68</span> 3a |.Content-Length:|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">20</span> <span class="number">32</span> <span class="number">32</span> <span class="number">0d</span> 0a <span class="number">0d</span> 0a 3c <span class="number">68</span> <span class="number">31</span> 3e <span class="number">48</span> <span class="number">65</span> 6c 6c <span class="number">6f</span> | <span class="number">22.</span>...&lt;h1&gt;Hello|</span><br><span class="line">|<span class="number">00000030</span>| 2c <span class="number">20</span> <span class="number">57</span> <span class="number">6f</span> <span class="number">72</span> 6c <span class="number">64</span> <span class="number">21</span> 3c <span class="number">2f</span> <span class="number">68</span> <span class="number">31</span> 3e          |, World!&lt;/h1&gt;   |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul><li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p></li><li><p><strong>版本号</strong>：可以支持协议的升级</p></li><li><p>序列化算法</p><p>：消息正文到底采用哪种序列化反序列化方式</p><ul><li>如：json、protobuf、hessian、jdk</li></ul></li><li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p></li><li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p></li><li><p><strong>正文长度</strong></p></li><li><p><strong>消息正文</strong></p></li></ul><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Message 自定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//将message按照协议写到bytebuf中</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 设置魔数 4个字节</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;M&#x27;</span>&#125;);</span><br><span class="line">        <span class="comment">// 设置版本号 1个字节</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置序列化方式 1个字节， eg:0 jdk 1json。。。</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置指令类型 1个字节 每个继承message的子类都知道自己的消息类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 设置请求序号 4个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 为了补齐为16个字节，填充1个字节的数据</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// message对象转字节数组，获得序列化后的msg</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得并设置正文长度 长度用4个字节标识</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 设置消息正文</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用read，get指针不会后移</span></span><br><span class="line">        <span class="comment">// 获取魔数</span></span><br><span class="line">        <span class="keyword">int</span> magic = in.readInt();</span><br><span class="line">        <span class="comment">// 获取版本号</span></span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="comment">// 获得序列化方式</span></span><br><span class="line">        <span class="keyword">byte</span> seqType = in.readByte();</span><br><span class="line">        <span class="comment">// 获得指令类型</span></span><br><span class="line">        <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line">        <span class="comment">// 获得请求序号</span></span><br><span class="line">        <span class="keyword">int</span> sequenceId = in.readInt();</span><br><span class="line">        <span class="comment">// 移除补齐字节</span></span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="comment">// 获得正文长度</span></span><br><span class="line">        <span class="keyword">int</span> length = in.readInt();</span><br><span class="line">        <span class="comment">// 获得正文</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        Message message = (Message) ois.readObject();</span><br><span class="line"><span class="comment">// 将信息放入List中，传递给下一个handler</span></span><br><span class="line">        out.add(message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 打印获得的信息正文</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========魔数===========&quot;</span>);</span><br><span class="line">        System.out.println(magic);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========版本号===========&quot;</span>);</span><br><span class="line">        System.out.println(version);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========序列化方法===========&quot;</span>);</span><br><span class="line">        System.out.println(seqType);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========指令类型===========&quot;</span>);</span><br><span class="line">        System.out.println(messageType);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========请求序号===========&quot;</span>);</span><br><span class="line">        System.out.println(sequenceId);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========正文长度===========&quot;</span>);</span><br><span class="line">        System.out.println(length);</span><br><span class="line">        System.out.println(<span class="string">&quot;===========正文===========&quot;</span>);</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCodec</span> <span class="keyword">extends</span> <span class="title">ByteToMessageCodec</span>&lt;<span class="title">Message</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p></li><li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p></li></ul><p><strong>编写测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCodec</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.Logger log = LoggerFactory.getLogger(StudyServer.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel();</span><br><span class="line">        <span class="comment">// 添加解码器（帧解码器），避免粘包半包问题</span></span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG));</span><br><span class="line">        channel.pipeline().addLast(<span class="keyword">new</span> MessageCodec());</span><br><span class="line">        LoginRequestMessage user = <span class="keyword">new</span> LoginRequestMessage(<span class="string">&quot;Nyima&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试编码与解码</span></span><br><span class="line">        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        <span class="keyword">new</span> MessageCodec().encode(<span class="keyword">null</span>, user, byteBuf);</span><br><span class="line">        channel.writeInbound(byteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li><li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li></ul><p>运行结果</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427111344.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427134513.png" alt="img"></a></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line"><span class="comment">// 不同的channel中使用同一个handler对象，提高复用率</span></span><br><span class="line">channel1.pipeline().addLast(loggingHandler);</span><br><span class="line">channel2.pipeline().addLast(loggingHandler);</span><br></pre></td></tr></table></figure><p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li></ul><p>ps:一般 handler如果没有记录状态,像logginghandler直接输出 的，一般可以共享</p><p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p><p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p><h4 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p><p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p><p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p><ul><li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210427144049.png" alt="img"></a></p><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p><ul><li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li></ul></li></ul><p><strong>如果想要共享，需要怎么办呢？</strong></p><p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSharableCodec</span> <span class="keyword">extends</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">ByteBuf</span>, <span class="title">Message</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、在线聊天室"><a href="#3、在线聊天室" class="headerlink" title="3、在线聊天室"></a>3、在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 会话绑定用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bind</span><span class="params">(Channel channel, String username)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unbind</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Object <span class="title">getAttribute</span><span class="params">(Channel channel, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(Channel channel, String name, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Channel <span class="title">getChannel</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroupSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> members 成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">createGroup</span><span class="params">(String name, Set&lt;String&gt; members)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">joinMember</span><span class="params">(String name, String member)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">removeMember</span><span class="params">(String name, String member)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Group <span class="title">removeGroup</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员集合, 如果群不存在或没有成员会返回 empty set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">getMembers</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员 channel 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Channel&gt; <span class="title">getMembersChannel</span><span class="params">(String name)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断群聊是否一被创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 群聊名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCreated</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154749.png"><img src="https://s2.loli.net/2022/05/10/ZxoVPUOj1gXY52n.png" alt="img"></a></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428154801.png"><img src="https://s2.loli.net/2022/05/10/9EFBTC1oQamOqHd.png" alt="img"></a></p><ul><li>client包：存放客户端相关类</li><li>message包：存放各种类型的消息</li><li>protocol包：存放自定义协议</li><li>server包：存放服务器相关类<ul><li>service包：存放用户相关类</li><li>session包：单聊及群聊相关会话类</li></ul></li></ul><h4 id="客户端代码结构"><a href="#客户端代码结构" class="headerlink" title="客户端代码结构"></a>客户端代码结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(ChatClient.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageSharableCodec messageSharableCodec = <span class="keyword">new</span> MessageSharableCodec();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProtocolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(loggingHandler);</span><br><span class="line">                    ch.pipeline().addLast(messageSharableCodec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect().sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务器代码结构"><a href="#服务器代码结构" class="headerlink" title="服务器代码结构"></a>服务器代码结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageSharableCodec messageSharableCodec = <span class="keyword">new</span> MessageSharableCodec();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(boss, worker);</span><br><span class="line">            bootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProtocolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(loggingHandler);</span><br><span class="line">                    ch.pipeline().addLast(messageSharableCodec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler LOGGING_HANDLER = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageCodecSharable MESSAGE_CODEC = <span class="keyword">new</span> MessageCodecSharable();</span><br><span class="line">        <span class="comment">//计数为0，则可以继续向下运行</span></span><br><span class="line">        CountDownLatch WAIT_FOR_LOGIN = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        AtomicBoolean LOGIN = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProcotolFrameDecoder());</span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span></span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="comment">// 接收响应消息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;msg: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">                            <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                LoginResponseMessage response = (LoginResponseMessage) msg;</span><br><span class="line">                                <span class="keyword">if</span> (response.isSuccess()) &#123;</span><br><span class="line">                                    <span class="comment">// 如果登录成功</span></span><br><span class="line">                                    LOGIN.set(<span class="keyword">true</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 唤醒 system in 线程</span></span><br><span class="line">                                WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在连接建立后触发 active 事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span></span><br><span class="line">                            <span class="comment">//// 开辟额外线程，用于用户登陆及后续操作, scanner会阻塞nioeventgroup的一个eventloopgroup</span></span><br><span class="line">                            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                                Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">                                String username = scanner.nextLine();</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">                                String password = scanner.nextLine();</span><br><span class="line">                                <span class="comment">// 构造消息对象</span></span><br><span class="line">                                LoginRequestMessage message = <span class="keyword">new</span> LoginRequestMessage(username, password);</span><br><span class="line">                                <span class="comment">// 写入内容触发出栈操作，向上找handler（遇到编码器）发送到channel中</span></span><br><span class="line">                                <span class="comment">// 发送消息</span></span><br><span class="line">                                ctx.writeAndFlush(message);</span><br><span class="line">                                System.out.println(<span class="string">&quot;等待后续操作...&quot;</span>);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    WAIT_FOR_LOGIN.await();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果登录失败</span></span><br><span class="line">                                <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                    ctx.channel().close();</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;send [username] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gsend [group name] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gmembers [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gjoin [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gquit [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    String command = scanner.nextLine();</span><br><span class="line">                                    String[] s = command.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                                    <span class="keyword">switch</span> (s[<span class="number">0</span>])&#123;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;send&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> ChatRequestMessage(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gsend&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupChatRequestMessage(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gcreate&quot;</span>:</span><br><span class="line">                                            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(s[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">                                            set.add(username); <span class="comment">// 加入自己</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupCreateRequestMessage(s[<span class="number">1</span>], set));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gmembers&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupMembersRequestMessage(s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gjoin&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinRequestMessage(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gquit&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> GroupQuitRequestMessage(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, <span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable <span class="comment">// 必须添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LoginRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得登录信息</span></span><br><span class="line">        String username = msg.getUsername();</span><br><span class="line">        String password = msg.getPassword();</span><br><span class="line">        <span class="comment">// 校验登录信息</span></span><br><span class="line">        <span class="keyword">boolean</span> login = UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">        LoginResponseMessage message;</span><br><span class="line">        <span class="keyword">if</span> (login) &#123;</span><br><span class="line">            message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;登陆成功&quot;</span>);</span><br><span class="line">            <span class="comment">// 绑定channel与user</span></span><br><span class="line">            SessionFactory.getSession().bind(ctx.channel(), username);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message = <span class="keyword">new</span> LoginResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;登陆失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line"><span class="comment">// 该handler处理登录请求</span></span><br><span class="line">LoginRequestMessageHandler loginRequestMessageHandler = <span class="keyword">new</span> LoginRequestMessageHandler();</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> LoginRequestMessageHandler());</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5665</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - <span class="number">1314474317</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">279</span></span><br><span class="line"><span class="number">5667</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:AbstractResponseMessage&#123;success=<span class="keyword">true</span>, reason=<span class="string">&#x27;登陆成功&#x27;</span>&#125;</span><br><span class="line"><span class="number">5667</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">true</span>, reason=<span class="string">&#x27;登陆成功&#x27;</span>&#125;</span><br><span class="line">success</span><br></pre></td></tr></table></figure><p><strong>服务器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11919</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - <span class="number">1314474317</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">217</span></span><br><span class="line"><span class="number">11919</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.protocol.MessageSharableCodec  - message:LoginRequestMessage&#123;username=<span class="string">&#x27;Nyima&#x27;</span>, password=<span class="string">&#x27;123&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">7946</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler  - [id: <span class="number">0x8e7c07f6</span>, L:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span> - R:/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">60572</span>] WRITE: 295B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|<span class="number">00000000</span>| 4e <span class="number">59</span> <span class="number">49</span> <span class="number">4d</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> ff <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">17</span> |NYIM............|</span><br><span class="line">|<span class="number">00000010</span>| ac ed <span class="number">00</span> <span class="number">05</span> <span class="number">73</span> <span class="number">72</span> <span class="number">00</span> <span class="number">31</span> <span class="number">63</span> 6e 2e 6e <span class="number">79</span> <span class="number">69</span> <span class="number">6d</span> <span class="number">61</span> |....sr.1cn.nyima|</span><br><span class="line">|<span class="number">00000020</span>| <span class="number">63</span> 2e <span class="number">73</span> <span class="number">74</span> <span class="number">75</span> <span class="number">64</span> <span class="number">79</span> 2e <span class="number">64</span> <span class="number">61</span> <span class="number">79</span> <span class="number">38</span> 2e <span class="number">6d</span> <span class="number">65</span> <span class="number">73</span> |c.study.day8.mes|</span><br><span class="line">|<span class="number">00000030</span>| <span class="number">73</span> <span class="number">61</span> <span class="number">67</span> <span class="number">65</span> 2e 4c <span class="number">6f</span> <span class="number">67</span> <span class="number">69</span> 6e <span class="number">52</span> <span class="number">65</span> <span class="number">73</span> <span class="number">70</span> <span class="number">6f</span> 6e |sage.LoginRespon|</span><br><span class="line">|<span class="number">00000040</span>| <span class="number">73</span> <span class="number">65</span> <span class="number">4d</span> <span class="number">65</span> <span class="number">73</span> <span class="number">73</span> <span class="number">61</span> <span class="number">67</span> <span class="number">65</span> e2 <span class="number">34</span> <span class="number">49</span> <span class="number">24</span> <span class="number">72</span> <span class="number">52</span> f3 |seMessage.4I$rR.|</span><br><span class="line">|<span class="number">00000050</span>| <span class="number">07</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">78</span> <span class="number">72</span> <span class="number">00</span> <span class="number">34</span> <span class="number">63</span> 6e 2e 6e <span class="number">79</span> <span class="number">69</span> <span class="number">6d</span> <span class="number">61</span> |....xr.4cn.nyima|</span><br><span class="line">|<span class="number">00000060</span>| <span class="number">63</span> 2e <span class="number">73</span> <span class="number">74</span> <span class="number">75</span> <span class="number">64</span> <span class="number">79</span> 2e <span class="number">64</span> <span class="number">61</span> <span class="number">79</span> <span class="number">38</span> 2e <span class="number">6d</span> <span class="number">65</span> <span class="number">73</span> |c.study.day8.mes|</span><br><span class="line">|<span class="number">00000070</span>| <span class="number">73</span> <span class="number">61</span> <span class="number">67</span> <span class="number">65</span> 2e <span class="number">41</span> <span class="number">62</span> <span class="number">73</span> <span class="number">74</span> <span class="number">72</span> <span class="number">61</span> <span class="number">63</span> <span class="number">74</span> <span class="number">52</span> <span class="number">65</span> <span class="number">73</span> |sage.AbstractRes|</span><br><span class="line">|00000080| <span class="number">70</span> <span class="number">6f</span> 6e <span class="number">73</span> <span class="number">65</span> <span class="number">4d</span> <span class="number">65</span> <span class="number">73</span> <span class="number">73</span> <span class="number">61</span> <span class="number">67</span> <span class="number">65</span> b3 7e <span class="number">19</span> <span class="number">32</span> |ponseMessage.~<span class="number">.2</span>|</span><br><span class="line">|00000090| 9b <span class="number">88</span> <span class="number">4d</span> 7b <span class="number">02</span> <span class="number">00</span> <span class="number">02</span> 5a <span class="number">00</span> <span class="number">07</span> <span class="number">73</span> <span class="number">75</span> <span class="number">63</span> <span class="number">63</span> <span class="number">65</span> <span class="number">73</span> |..M&#123;...Z..succes|</span><br><span class="line">|000000a0| <span class="number">73</span> 4c <span class="number">00</span> <span class="number">06</span> <span class="number">72</span> <span class="number">65</span> <span class="number">61</span> <span class="number">73</span> <span class="number">6f</span> 6e <span class="number">74</span> <span class="number">00</span> <span class="number">12</span> 4c 6a <span class="number">61</span> |sL..reasont..Lja|</span><br><span class="line">|000000b0| <span class="number">76</span> <span class="number">61</span> <span class="number">2f</span> 6c <span class="number">61</span> 6e <span class="number">67</span> <span class="number">2f</span> <span class="number">53</span> <span class="number">74</span> <span class="number">72</span> <span class="number">69</span> 6e <span class="number">67</span> 3b <span class="number">78</span> |va/lang/String;x|</span><br><span class="line">|000000c0| <span class="number">72</span> <span class="number">00</span> <span class="number">24</span> <span class="number">63</span> 6e 2e 6e <span class="number">79</span> <span class="number">69</span> <span class="number">6d</span> <span class="number">61</span> <span class="number">63</span> 2e <span class="number">73</span> <span class="number">74</span> <span class="number">75</span> |r.$cn.nyimac.stu|</span><br><span class="line">|000000d0| <span class="number">64</span> <span class="number">79</span> 2e <span class="number">64</span> <span class="number">61</span> <span class="number">79</span> <span class="number">38</span> 2e <span class="number">6d</span> <span class="number">65</span> <span class="number">73</span> <span class="number">73</span> <span class="number">61</span> <span class="number">67</span> <span class="number">65</span> 2e |dy.day8.message.|</span><br><span class="line">|<span class="number">000000e0</span>| <span class="number">4d</span> <span class="number">65</span> <span class="number">73</span> <span class="number">73</span> <span class="number">61</span> <span class="number">67</span> <span class="number">65</span> dd e9 <span class="number">84</span> b7 <span class="number">21</span> db <span class="number">18</span> <span class="number">52</span> <span class="number">02</span> |Message....!..R.|</span><br><span class="line">|000000f0| <span class="number">00</span> <span class="number">02</span> <span class="number">49</span> <span class="number">00</span> 0b <span class="number">6d</span> <span class="number">65</span> <span class="number">73</span> <span class="number">73</span> <span class="number">61</span> <span class="number">67</span> <span class="number">65</span> <span class="number">54</span> <span class="number">79</span> <span class="number">70</span> <span class="number">65</span> |..I..messageType|</span><br><span class="line">|<span class="number">00000100</span>| <span class="number">49</span> <span class="number">00</span> 0a <span class="number">73</span> <span class="number">65</span> <span class="number">71</span> <span class="number">75</span> <span class="number">65</span> 6e <span class="number">63</span> <span class="number">65</span> <span class="number">49</span> <span class="number">64</span> <span class="number">78</span> <span class="number">70</span> <span class="number">00</span> |I..sequenceIdxp.|</span><br><span class="line">|<span class="number">00000110</span>| <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span> <span class="number">74</span> <span class="number">00</span> 0c e7 <span class="number">99</span> bb e9 <span class="number">99</span> |........t.......|</span><br><span class="line">|<span class="number">00000120</span>| <span class="number">86</span> e6 <span class="number">88</span> <span class="number">90</span> e5 8a <span class="number">9f</span>                            |.......         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable <span class="comment">// 必须添加该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ChatRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得user所在的channel</span></span><br><span class="line">        Channel channel = SessionFactory.getSession().getChannel(msg.getTo());</span><br><span class="line">        <span class="comment">// 如果双方都在线</span></span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通过接收方与服务器之间的channel发送信息</span></span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> ChatResponseMessage(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 通过发送方与服务器之间的channel发送消息</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> ChatResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;对方用户不存在或离线，发送失败&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line"><span class="comment">// 该handler处理单聊请求</span></span><br><span class="line">ChatRequestMessageHandler chatRequestMessageHandler = <span class="keyword">new</span> ChatRequestMessageHandler();</span><br><span class="line">ch.pipeline().addLast(chatRequestMessageHandler);</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（zhangsan）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send Nyima hello</span><br></pre></td></tr></table></figure><p>接收方（Nyima）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到zhangsan发来的消息</span></span><br><span class="line"><span class="number">20230</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - ChatResponseMessage&#123;from=<span class="string">&#x27;zhangsan&#x27;</span>, content=<span class="string">&#x27;hello&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><p>添加处理<code>GroupCreateRequestMessage</code>的handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupCreateMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupCreateRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得要创建的群聊名</span></span><br><span class="line">        String groupName = msg.getGroupName();</span><br><span class="line">        <span class="comment">// 获得要创建的群聊的成员组</span></span><br><span class="line">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class="line">        <span class="comment">// 判断该群聊是否创建过，未创建返回null并创建群聊</span></span><br><span class="line">        Group group = GroupSessionFactory.getGroupSession().createGroup(groupName, members);</span><br><span class="line">        <span class="keyword">if</span> (group == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 发送创建成功消息</span></span><br><span class="line">            GroupCreateResponseMessage groupCreateResponseMessage = <span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">true</span>, groupName + <span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">            ctx.writeAndFlush(groupCreateResponseMessage);</span><br><span class="line">            <span class="comment">// 获得在线群员的channel，给群员发送入群聊消息</span></span><br><span class="line">            List&lt;Channel&gt; membersChannel = GroupSessionFactory.getGroupSession().getMembersChannel(groupName);</span><br><span class="line">            groupCreateResponseMessage = <span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;您已被拉入&quot;</span>+groupName);</span><br><span class="line">            <span class="comment">// 给每个在线群员发送消息</span></span><br><span class="line">            <span class="keyword">for</span>(Channel channel : membersChannel) &#123;</span><br><span class="line">                channel.writeAndFlush(groupCreateResponseMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送失败消息</span></span><br><span class="line">            GroupCreateResponseMessage groupCreateResponseMessage = <span class="keyword">new</span> GroupCreateResponseMessage(<span class="keyword">false</span>, groupName + <span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">            ctx.writeAndFlush(groupCreateResponseMessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该handler处理创建群聊请求</span></span><br><span class="line">GroupCreateMessageHandler groupCreateMessageHandler = <span class="keyword">new</span> GroupCreateMessageHandler();</span><br><span class="line">ch.pipeline().addLast(groupCreateMessageHandler);</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>创建者客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次创建</span></span><br><span class="line">gcreate Netty学习 zhangsan,lisi</span><br><span class="line"></span><br><span class="line"><span class="number">31649</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">true</span>, reason=<span class="string">&#x27;Netty学习创建成功&#x27;</span>&#125;</span><br><span class="line"><span class="number">15244</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">true</span>, reason=<span class="string">&#x27;您已被拉入Netty学习&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次创建</span></span><br><span class="line">gcreate Netty学习 zhangsan,lisi</span><br><span class="line"><span class="number">40771</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">false</span>, reason=<span class="string">&#x27;Netty学习已存在&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>群员客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">28788</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">true</span>, reason=<span class="string">&#x27;您已被拉入Netty学习&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupChatRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String groupName = msg.getGroupName();</span><br><span class="line">        GroupSession groupSession = GroupSessionFactory.getGroupSession();</span><br><span class="line">        <span class="comment">// 判断群聊是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> isCreated = groupSession.isCreated(groupName);</span><br><span class="line">        <span class="keyword">if</span> (isCreated) &#123;</span><br><span class="line">            <span class="comment">// 给群员发送信息</span></span><br><span class="line">            List&lt;Channel&gt; membersChannel = groupSession.getMembersChannel(groupName);</span><br><span class="line">            <span class="keyword">for</span>(Channel channel : membersChannel) &#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> GroupChatResponseMessage(msg.getFrom(), msg.getContent()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupChatResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;群聊不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line"><span class="comment">// 该handler处理群聊聊天</span></span><br><span class="line">GroupChatMessageHandler groupChatMessageHandler = <span class="keyword">new</span> GroupChatMessageHandler();</span><br><span class="line">ch.pipeline().addLast(groupChatMessageHandler);</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（群聊存在）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsend Netty学习 你们好</span><br><span class="line"></span><br><span class="line"><span class="number">45408</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=<span class="string">&#x27;zhangsan&#x27;</span>, content=<span class="string">&#x27;你们好&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>接收方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">48082</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupChatResponseMessage&#123;from=<span class="string">&#x27;zhangsan&#x27;</span>, content=<span class="string">&#x27;你们好&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>发送方（群聊不存在）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsend Spring学习 你们好</span><br><span class="line"></span><br><span class="line"><span class="number">25140</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">false</span>, reason=<span class="string">&#x27;群聊不存在&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupJoinMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupJoinRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroupSession groupSession = GroupSessionFactory.getGroupSession();</span><br><span class="line">        <span class="comment">// 判断该用户是否在群聊中</span></span><br><span class="line">        Set&lt;String&gt; members = groupSession.getMembers(msg.getGroupName());</span><br><span class="line">        <span class="keyword">boolean</span> joinFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 群聊存在且用户未加入，才能加入</span></span><br><span class="line">        <span class="keyword">if</span> (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;</span><br><span class="line">            joinFlag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (joinFlag) &#123;</span><br><span class="line">            <span class="comment">// 加入群聊</span></span><br><span class="line">            groupSession.joinMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">true</span>,<span class="string">&quot;加入&quot;</span>+msg.getGroupName()+<span class="string">&quot;成功&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupJoinResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;加入失败，群聊未存在或您已加入该群聊&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line"><span class="comment">// 该handler处理加入群聊</span></span><br><span class="line">GroupJoinMessageHandler groupJoinMessageHandler = <span class="keyword">new</span> GroupJoinMessageHandler();</span><br><span class="line">ch.pipeline().addLast(groupJoinMessageHandler);</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>正常加入群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">94921</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">true</span>, reason=<span class="string">&#x27;加入Netty学习成功&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>加入不能存在或已加入的群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">44025</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">false</span>, reason=<span class="string">&#x27;加入失败，群聊未存在或您已加入该群聊&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupQuitMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupQuitRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        GroupSession groupSession = GroupSessionFactory.getGroupSession();</span><br><span class="line">        String groupName = msg.getGroupName();</span><br><span class="line">        Set&lt;String&gt; members = groupSession.getMembers(groupName);</span><br><span class="line">        String username = msg.getUsername();</span><br><span class="line">        <span class="comment">// 判断用户是否在群聊中以及群聊是否存在</span></span><br><span class="line">        <span class="keyword">boolean</span> joinFlag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (groupSession.isCreated(groupName) &amp;&amp; members.contains(username)) &#123;</span><br><span class="line">            <span class="comment">// 可以退出</span></span><br><span class="line">            joinFlag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (joinFlag) &#123;</span><br><span class="line">            <span class="comment">// 退出成功</span></span><br><span class="line">            groupSession.removeMember(groupName, username);</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupQuitResponseMessage(<span class="keyword">true</span>, <span class="string">&quot;退出&quot;</span>+groupName+<span class="string">&quot;成功&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 退出失败</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> GroupQuitResponseMessage(<span class="keyword">false</span>, <span class="string">&quot;群聊不存在或您未加入该群，退出&quot;</span>+groupName+<span class="string">&quot;失败&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line"><span class="comment">// 该handler处理退出群聊</span></span><br><span class="line">GroupQuitMessageHandler groupQuitMessageHandler = <span class="keyword">new</span> GroupQuitMessageHandler();</span><br><span class="line">ch.pipeline().addLast(groupQuitMessageHandler);</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>正常退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">32282</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">true</span>, reason=<span class="string">&#x27;退出Netty学习成功&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>退出不存在或未加入的群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">67404</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - AbstractResponseMessage&#123;success=<span class="keyword">false</span>, reason=<span class="string">&#x27;群聊不存在或您未加入该群，退出Netty失败&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupMembersMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">GroupMembersRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> GroupMembersResponseMessage(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line"><span class="comment">// 该handler处理查看成员</span></span><br><span class="line">GroupMembersMessageHandler groupMembersMessageHandler = <span class="keyword">new</span> GroupMembersMessageHandler();</span><br><span class="line">ch.pipeline().addLast(groupMembersMessageHandler);</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">46557</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.client.ChatClient  - GroupMembersResponseMessage&#123;members=[zhangsan, Nyima]&#125;</span><br></pre></td></tr></table></figure><h3 id="退出聊天室"><a href="#退出聊天室" class="headerlink" title="退出聊天室"></a>退出聊天室</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuitHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 断开连接时触发 Inactive事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解绑</span></span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常退出，需要解绑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 解绑</span></span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line"><span class="comment">// 该handler处理退出聊天室</span></span><br><span class="line">ch.pipeline().addLast(quitHandler);</span><br><span class="line">GroupMembersMessageHandler groupMembersMessageHandler = <span class="keyword">new</span> GroupMembersMessageHandler();</span><br></pre></td></tr></table></figure><p><strong>退出时，客户端会关闭channel并返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>:</span><br><span class="line"><span class="comment">// 关闭channel并返回</span></span><br><span class="line">    ctx.channel().close();</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h3 id="空闲检测"><a href="#空闲检测" class="headerlink" title="空闲检测"></a>空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>原因</strong></p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p><strong>问题</strong></p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p><ul><li>readerIdleTimeSeconds 读空闲经过的秒数</li><li>writerIdleTimeSeconds 写空闲经过的秒数</li><li>allIdleTimeSeconds 读和写空闲经过的秒数</li></ul><p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210428132848.png"><img src="https://s2.loli.net/2022/05/10/5oUJsaYmvMWbqTl.png" alt="img"></a></p><ul><li>读空闲会触发<code>READER_IDLE</code></li><li>写空闲会触发<code>WRITE_IDLE</code></li><li>读和写空闲会触发<code>ALL_IDEL</code></li></ul><p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p><p><strong>服务器端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 添加双向处理器（入出站操作都能处理），负责处理READER_IDLE事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ChannelDuplexHandler() &#123;</span><br><span class="line">    <span class="comment">//用来触发特殊事件的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获得事件</span></span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            <span class="comment">// 断开连接</span></span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>使用<code>IdleStateHandler</code>进行空闲检测</p></li><li><p>使用双向处理器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelDuplexHandler</span><br></pre></td></tr></table></figure><p>对入站与出站事件进行处理</p><ul><li><code>IdleStateHandler</code>中的事件为特殊事件，需要实现<code>ChannelDuplexHandler</code>的<code>userEventTriggered</code>方法，判断事件类型并自定义处理方式，来对事件进行处理</li></ul></li></ul><p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p><p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送心跳包，让服务器知道客户端在线</span></span><br><span class="line"><span class="comment">// 3s未发生WRITER_IDLE向服务器写数据，触发IdleStateEvent事件，就向服务器发送心跳包，</span></span><br><span class="line"><span class="comment">// 该值为服务器端设置的READER_IDLE触发时间的一半左右</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ChannelDuplexHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            <span class="comment">// 发送心跳包</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> PingMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h1><h2 id="1、拓展序列化算法"><a href="#1、拓展序列化算法" class="headerlink" title="1、拓展序列化算法"></a>1、拓展序列化算法</h2><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object 被序列化的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 被序列化对象类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 序列化后的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 反序列化的目标类的Class对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 被反序列化的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 反序列化目标类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 反序列化后的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Java的序列化和反序列化</span></span><br><span class="line">    Java &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="comment">// 序列化后的字节数组</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> (ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                 ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos)) &#123;</span><br><span class="line">                oos.writeObject(object);</span><br><span class="line">                bytes = bos.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bytes;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            T target = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(Arrays.toString(bytes));</span><br><span class="line">            <span class="keyword">try</span> (ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">                 ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis)) &#123;</span><br><span class="line">                target = (T) ois.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回反序列化后的对象</span></span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// Json的序列化和反序列化</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="keyword">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            String s = <span class="keyword">new</span> Gson().toJson(object);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="comment">// 指定字符集，获得字节数组</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            String s = <span class="keyword">new</span> String(bytes, StandardCharsets.UTF_8);</span><br><span class="line">            System.out.println(s);</span><br><span class="line">            <span class="comment">// 此处的clazz为具体类型的Class对象，而不是父类Message的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Gson().fromJson(s, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得序列化后的msg</span></span><br><span class="line"><span class="comment">// 使用指定的序列化方式</span></span><br><span class="line">SerializerAlgorithm[] values = SerializerAlgorithm.values();</span><br><span class="line"><span class="comment">// 获得序列化后的对象</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = values[out.getByte(<span class="number">5</span>)-<span class="number">1</span>].serialize(msg);</span><br></pre></td></tr></table></figure><p><strong>解码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得反序列化方式</span></span><br><span class="line">SerializerAlgorithm[] values = SerializerAlgorithm.values();</span><br><span class="line"><span class="comment">// 通过指定方式进行反序列化</span></span><br><span class="line"><span class="comment">// 需要通过Message的方法获得具体的消息类型</span></span><br><span class="line">Message message = values[seqType-<span class="number">1</span>].deserialize(Message.getMessageClass(messageType), bytes);</span><br></pre></td></tr></table></figure><h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li>属于 <strong>SocketChannal</strong> 的参数</li><li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// SocketChannel 5s内未建立连接就抛出异常</span></span><br><span class="line">        <span class="keyword">new</span> Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ServerSocketChannel 5s内未建立连接就抛出异常</span></span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// SocketChannel 5s内未建立连接就抛出异常</span></span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></p></li><li><p>服务器通过</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap</span><br></pre></td></tr></table></figure><p>  来配置参数，但是对于不同的 Channel 需要选择不同的方法</p><ul><li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li><li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p><p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Schedule connect timeout.</span></span><br><span class="line">    <span class="comment">// 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置</span></span><br><span class="line">    <span class="keyword">int</span> connectTimeoutMillis = config().getConnectTimeoutMillis();</span><br><span class="line">    <span class="comment">// 如果超时时间大于0</span></span><br><span class="line">    <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行</span></span><br><span class="line">        <span class="comment">// schedule(Runnable command, long delay, TimeUnit unit)</span></span><br><span class="line">        connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 判断是否建立连接，Promise进行NIO线程与主线程之间的通信</span></span><br><span class="line">                <span class="comment">// 如果超时，则通过tryFailure方法将异常放入Promise中</span></span><br><span class="line">                <span class="comment">// 在主线程中抛出</span></span><br><span class="line">                ChannelPromise connectPromise = AbstractNioChannel.<span class="keyword">this</span>.connectPromise;</span><br><span class="line">                ConnectTimeoutException cause = <span class="keyword">new</span> ConnectTimeoutException(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress);</span><br><span class="line">                <span class="keyword">if</span> (connectPromise != <span class="keyword">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                    close(voidPromise());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p><ul><li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li><li>如果指定时间内没有建立连接，则会执行其中的任务<ul><li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li></ul></li></ul><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p><h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211913.png" alt="img"></a></p><p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210429211952.png" alt="img"></a></p><p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210430094836.png" alt="img"></a></p><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p><ul><li>半连接队列 - sync queue<ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li>全连接队列 - accept queue<ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p><p><strong>设置方式如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置全连接队列，大小为2</span></span><br><span class="line"><span class="keyword">new</span> ServerBootstrap().option(ChannelOption.SO_BACKLOG, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> backlog = NetUtil.SOMAXCONN;</span><br></pre></td></tr></table></figure><p>具体的赋值操作如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SOMAXCONN = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Determine the default somaxconn (server socket backlog) value of the platform.</span></span><br><span class="line">        <span class="comment">// The known defaults:</span></span><br><span class="line">        <span class="comment">// - Windows NT Server 4.0+: 200</span></span><br><span class="line">        <span class="comment">// - Linux and Mac OS X: 128</span></span><br><span class="line">        <span class="keyword">int</span> somaxconn = PlatformDependent.isWindows() ? <span class="number">200</span> : <span class="number">128</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;/proc/sys/net/core/somaxconn&quot;</span>);</span><br><span class="line">        BufferedReader in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the</span></span><br><span class="line">            <span class="comment">// try / catch block.</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/4936</span></span><br><span class="line">            <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">                in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">                <span class="comment">// 将somaxconn设置为Linux配置文件中设置的值</span></span><br><span class="line">                somaxconn = Integer.parseInt(in.readLine());</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, file, somaxconn);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 返回backlog的值</span></span><br><span class="line">        <span class="keyword">return</span> somaxconn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>backlog的值会根据操作系统的不同，来</p><p>选择不同的默认值</p><ul><li>Windows 200</li><li>Linux/Mac OS 128</li></ul></li><li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p></li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 <strong>SocketChannel</strong> 参数</li><li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li><li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li></ul><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li><li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li><li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li></ul><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型</span></span><br><span class="line"><span class="comment">// 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型</span></span><br><span class="line"><span class="keyword">new</span> ServerBootstrap().childOption(ChannelOption.ALLOCATOR, <span class="keyword">new</span> PooledByteBufAllocator());</span><br></pre></td></tr></table></figure><p><strong>ByteBufAllocator类型</strong></p><ul><li><p>池化并使用直接内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// true表示使用直接内存</span><br><span class="line">new PooledByteBufAllocator(true);Copy</span><br></pre></td></tr></table></figure></li><li><p>池化并使用堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false表示使用堆内存</span></span><br><span class="line"><span class="keyword">new</span> PooledByteBufAllocator(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>非池化并使用直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ture表示使用直接内存</span></span><br><span class="line"><span class="keyword">new</span> UnpooledByteBufAllocator(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>非池化并使用堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// false表示使用堆内存</span></span><br><span class="line"><span class="keyword">new</span> UnpooledByteBufAllocator(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li><strong>控制 Netty 接收缓冲区大小</strong></li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li></ul><h2 id="3、RPC框架"><a href="#3、RPC框架" class="headerlink" title="3、RPC框架"></a>3、RPC框架</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在聊天室代码的基础上进行一定的改进</p><p><strong>Message</strong>中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加RPC消息类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RPC_MESSAGE_TYPE_REQUEST = <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RPC_MESSAGE_TYPE_RESPONSE = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 将消息类型放入消息类对象Map中</span></span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);</span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RPC请求消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用的接口全限定名，服务端根据它找到实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用接口中的方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; returnType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数类型数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class[] parameterTypes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数值数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RpcRequestMessage</span><span class="params">(<span class="keyword">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setSequenceId(sequenceId);</span><br><span class="line">        <span class="keyword">this</span>.interfaceName = interfaceName;</span><br><span class="line">        <span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">        <span class="keyword">this</span>.returnType = returnType;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">        <span class="keyword">this</span>.parameterValue = parameterValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getInterfaceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getReturnType() &#123;</span><br><span class="line">        <span class="keyword">return</span> returnType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class[] getParameterTypes() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameterTypes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] getParameterValue() &#123;</span><br><span class="line">        <span class="keyword">return</span> parameterValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RpcRequestMessage&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;interfaceName=&#x27;&quot;</span> + interfaceName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, methodName=&#x27;&quot;</span> + methodName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, returnType=&quot;</span> + returnType +</span><br><span class="line">                <span class="string">&quot;, parameterTypes=&quot;</span> + Arrays.toString(parameterTypes) +</span><br><span class="line">                <span class="string">&quot;, parameterValue=&quot;</span> + Arrays.toString(parameterValue) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要远程调用一个方法，必须知道以<strong>下五个信息</strong></p><ul><li>方法所在的全限定类名</li><li>方法名</li><li>方法返回值类型</li><li>方法参数类型</li><li>方法参数值</li></ul><p><strong>RPC响应消息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessage</span> <span class="keyword">extends</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object returnValue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Exception exceptionValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMessageType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReturnValue</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.returnValue = returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExceptionValue</span><span class="params">(Exception exceptionValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exceptionValue = exceptionValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">getReturnValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exception <span class="title">getExceptionValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exceptionValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RpcResponseMessage&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;returnValue=&quot;</span> + returnValue +</span><br><span class="line">                <span class="string">&quot;, exceptionValue=&quot;</span> + exceptionValue +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应消息中只需要获取<strong>返回结果和异常值</strong></p><p><strong>服务器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageSharableCodec messageSharableCodec = <span class="keyword">new</span> MessageSharableCodec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PRC 请求消息处理器</span></span><br><span class="line">        RpcRequestMessageHandler rpcRequestMessageHandler = <span class="keyword">new</span> RpcRequestMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProtocolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(loggingHandler);</span><br><span class="line">                    ch.pipeline().addLast(messageSharableCodec);</span><br><span class="line">                    ch.pipeline().addLast(rpcRequestMessageHandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器中添加了<strong>处理RPCRequest消息的handler</strong></p><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageSharableCodec messageSharableCodec = <span class="keyword">new</span> MessageSharableCodec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PRC 请求消息处理器</span></span><br><span class="line">        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> ProtocolFrameDecoder());</span><br><span class="line">                    ch.pipeline().addLast(loggingHandler);</span><br><span class="line">                    ch.pipeline().addLast(messageSharableCodec);</span><br><span class="line">                    ch.pipeline().addLast(rpcResponseMessageHandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过接口Class获取实例对象的<strong>Factory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServicesFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(Class&lt;?&gt; interfaceClass)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">// 根据Class创建实例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>);</span><br><span class="line">            Object instance = Class.forName(<span class="string">&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;</span>).newInstance();</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 放入 InterfaceClass -&gt; InstanceObject 的映射</span></span><br><span class="line">            map.put(clazz, instance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> map.get(interfaceClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RpcRequestMessageHandler"><a href="#RpcRequestMessageHandler" class="headerlink" title="RpcRequestMessageHandler"></a>RpcRequestMessageHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcRequestMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequestMessage rpcMessage)</span> </span>&#123;</span><br><span class="line">        RpcResponseMessage rpcResponseMessage = <span class="keyword">new</span> RpcResponseMessage();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置返回值的属性</span></span><br><span class="line">            rpcResponseMessage.setSequenceId(rpcMessage.getSequenceId());</span><br><span class="line">            <span class="comment">// 返回一个实例</span></span><br><span class="line">            HelloService service = (HelloService) ServicesFactory.getInstance(Class.forName(rpcMessage.getInterfaceName()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过反射调用方法，并获取返回值</span></span><br><span class="line">            Method method = service.getClass().getMethod(rpcMessage.getMethodName(), rpcMessage.getParameterTypes());</span><br><span class="line">            <span class="comment">// 获得返回值</span></span><br><span class="line">            Object invoke = method.invoke(service, rpcMessage.getParameterValue());</span><br><span class="line">            <span class="comment">// 设置返回值</span></span><br><span class="line">            rpcResponseMessage.setReturnValue(invoke);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 设置异常</span></span><br><span class="line">            rpcResponseMessage.setExceptionValue(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向channel中写入Message</span></span><br><span class="line">    ctx.writeAndFlush(rpcResponseMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程调用方法主要是通过反射实现的，大致步骤如下</p><ul><li>通过<strong>请求消息传入被调入方法的各个参数</strong></li><li>通过<strong>全限定接口名，在map中查询到对应的类并实例化对象</strong></li><li>通过反射获取Method，并调用其invoke方法的<strong>返回值，并放入响应消息中</strong></li><li>若有<strong>异常需要捕获，并放入响应消息中</strong></li></ul><h3 id="RpcResponseMessageHandler"><a href="#RpcResponseMessageHandler" class="headerlink" title="RpcResponseMessageHandler"></a>RpcResponseMessageHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponseMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        System.out.println((String)msg.getReturnValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端发送消息"><a href="#客户端发送消息" class="headerlink" title="客户端发送消息"></a>客户端发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// 创建请求并发送</span></span><br><span class="line">RpcRequestMessage message = <span class="keyword">new</span> RpcRequestMessage(<span class="number">1</span>,</span><br><span class="line">               <span class="string">&quot;cn.nyimac.study.day8.server.service.HelloService&quot;</span>,</span><br><span class="line">               <span class="string">&quot;sayHello&quot;</span>,</span><br><span class="line">               String.class,</span><br><span class="line">               <span class="keyword">new</span> Class[]&#123;String.class&#125;,</span><br><span class="line">               <span class="keyword">new</span> Object[]&#123;<span class="string">&quot;Nyima&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        channel.writeAndFlush(message);   </span><br><span class="line">            </span><br><span class="line">        ...    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1606</span> [nioEventLoopGroup-<span class="number">2</span>-<span class="number">1</span>] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue=你好，Nyima, exceptionValue=<span class="keyword">null</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="改进客户端"><a href="#改进客户端" class="headerlink" title="改进客户端"></a>改进客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClientManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产生SequenceId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger sequenceId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        HelloService service = (HelloService) getProxy(HelloService.class);</span><br><span class="line">        <span class="comment">// 通过代理对象执行方法</span></span><br><span class="line">        System.out.println(service.sayHello(<span class="string">&quot;Nyima&quot;</span>));</span><br><span class="line">        System.out.println(service.sayHello(<span class="string">&quot;Hulu&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例模式创建Channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    init();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用代理模式，帮助我们创建请求消息并发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Class&lt;?&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] classes = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;serviceClass&#125;;</span><br><span class="line">        <span class="comment">// 使用JDK代理，创建代理对象</span></span><br><span class="line">        Object o = Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 创建请求消息</span></span><br><span class="line">                <span class="keyword">int</span> id = sequenceId.getAndIncrement();</span><br><span class="line">                RpcRequestMessage message = <span class="keyword">new</span> RpcRequestMessage(id, serviceClass.getName(),</span><br><span class="line">                        method.getName(), method.getReturnType(),</span><br><span class="line">                        method.getParameterTypes(),</span><br><span class="line">                        args);</span><br><span class="line">                <span class="comment">// 发送消息</span></span><br><span class="line">                getChannel().writeAndFlush(message);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span></span><br><span class="line">                DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());</span><br><span class="line">                <span class="comment">// 将Promise放入Map中</span></span><br><span class="line">                RpcResponseMessageHandler.promiseMap.put(id, promise);</span><br><span class="line">                <span class="comment">// 等待被放入Promise中结果</span></span><br><span class="line">                promise.await();</span><br><span class="line">                <span class="keyword">if</span> (promise.isSuccess()) &#123;</span><br><span class="line">                    <span class="comment">// 调用方法成功，返回方法执行结果</span></span><br><span class="line">                    <span class="keyword">return</span> promise.getNow();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用方法失败，抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(promise.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        LoggingHandler loggingHandler = <span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG);</span><br><span class="line">        MessageSharableCodec messageSharableCodec = <span class="keyword">new</span> MessageSharableCodec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PRC 请求消息处理器</span></span><br><span class="line">        RpcResponseMessageHandler rpcResponseMessageHandler = <span class="keyword">new</span> RpcResponseMessageHandler();</span><br><span class="line"></span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.group(group);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> ProtocolFrameDecoder());</span><br><span class="line">                ch.pipeline().addLast(loggingHandler);</span><br><span class="line">                ch.pipeline().addLast(messageSharableCodec);</span><br><span class="line">                ch.pipeline().addLast(rpcResponseMessageHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = bootstrap.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)).sync().channel();</span><br><span class="line">            <span class="comment">// 异步关闭 group，避免Channel被阻塞</span></span><br><span class="line">            channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获得Channel</strong></p><ul><li>建立连接，获取Channel的操作被封装到了<code>init</code>方法中，当连接断开时，通过<code>addListener</code>方<strong>法异步关闭group</strong></li><li>通过<strong>单例模式</strong>创建与获取Channel</li></ul><p><strong>远程调用方法</strong></p><ul><li>为了让方法的调用变得简洁明了，将<code>RpcRequestMessage</code>的<strong>创建与发送过程通过JDK的动态代理来完成</strong></li><li>通过返回的代理对象调用方法即可，<strong>方法参数为被调用方法接口的Class类</strong></li></ul><p><strong>远程调用方法返回值获取</strong></p><ul><li><p>调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。<strong>要在不同线程中进行返回值的传递，需要用到Promise</strong></p></li><li><p>在<code>RpcResponseMessageHandler</code>中创建一个Map</p><ul><li>Key为<strong>SequenceId</strong></li><li>Value为对应的<strong>Promise</strong></li></ul></li><li><p><strong>主线程</strong>的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。<strong>需要使用await等待结果被放入Promise中</strong>。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的</span></span><br><span class="line">DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(getChannel().eventLoop());</span><br><span class="line"><span class="comment">// 将Promise放入Map中</span></span><br><span class="line">RpcResponseMessageHandler.promiseMap.put(id, promise);</span><br><span class="line"><span class="comment">// 等待被放入Promise中结果</span></span><br><span class="line">promise.await();</span><br><span class="line"><span class="keyword">if</span> (promise.isSuccess()) &#123;</span><br><span class="line">    <span class="comment">// 调用方法成功，返回方法执行结果</span></span><br><span class="line">    <span class="keyword">return</span> promise.getNow();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 调用方法失败，抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(promise.cause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>NIO线程</strong>负责通过SequenceId<strong>获取并移除（remove）</strong>对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值</p><ul><li>如果<strong>没有异常信息</strong>（ExceptionValue），就调用<code>promise.setSuccess(returnValue)</code>放入方法返回值</li><li>如果<strong>有异常信息</strong>，就调用<code>promise.setFailure(exception)</code>放入异常信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span></span><br><span class="line">Promise&lt;Object&gt; promise = promiseMap.remove(msg.getSequenceId());</span><br><span class="line">Object returnValue = msg.getReturnValue();</span><br><span class="line">Exception exception = msg.getExceptionValue();</span><br><span class="line"><span class="keyword">if</span> (promise != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回结果中有异常信息</span></span><br><span class="line">        promise.setFailure(exception);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 方法正常执行，没有异常</span></span><br><span class="line">        promise.setSuccess(returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="改进RpcResponseMessageHandler"><a href="#改进RpcResponseMessageHandler" class="headerlink" title="改进RpcResponseMessageHandler"></a>改进RpcResponseMessageHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcResponseMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(ChatServer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; promiseMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将返回结果放入对应的Promise中，并移除Map中的Promise</span></span><br><span class="line">        Promise&lt;Object&gt; promise = promiseMap.remove(msg.getSequenceId());</span><br><span class="line">        Object returnValue = msg.getReturnValue();</span><br><span class="line">        Exception exception = msg.getExceptionValue();</span><br><span class="line">        <span class="keyword">if</span> (promise != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 返回结果中有异常信息</span></span><br><span class="line">                promise.setFailure(exception);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 方法正常执行，没有异常</span></span><br><span class="line">                promise.setSuccess(returnValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿到返回结果并打印</span></span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、源码"><a href="#六、源码" class="headerlink" title="六、源码"></a>六、源码</h1><h2 id="1、启动流程"><a href="#1、启动流程" class="headerlink" title="1、启动流程"></a>1、启动流程</h2><p>Netty启动流程可以简化成如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span></span><br><span class="line">Selector selector = Selector.open(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span></span><br><span class="line">NioServerSocketChannel attachment = <span class="keyword">new</span> NioServerSocketChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); </span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 nio boss 线程执行接下来的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span></span><br><span class="line">SelectionKey selectionKey = serverSocketChannel.register(selector, <span class="number">0</span>, attachment);</span><br><span class="line"></span><br><span class="line"><span class="comment">// head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定端口</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 channel active 事件，在 head 中关注 op_accept 事件</span></span><br><span class="line">selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><ul><li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li><li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li><li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li><li>绑定端口</li><li>通过<code>interestOps</code>设置感兴趣的事件</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p><p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ChannelFuture bind(SocketAddress localAddress) &#123;</span><br><span class="line">validate();</span><br><span class="line">return doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 负责NioServerSocketChannel和ServerSocketChannel的创建</span></span><br><span class="line">    <span class="comment">// ServerSocketChannel的注册工作</span></span><br><span class="line">    <span class="comment">// init由main线程完成，regisetr由NIO线程完成</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为register操作是异步的</span></span><br><span class="line">    <span class="comment">// 所以要判断主线程执行到这里时，register操作是否已经执行完毕</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行doBind0绑定操作</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class="line">        <span class="comment">// 如果register操作还没执行完，就会到这个分支中来</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加监听器，NIO线程异步进行doBind0操作</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                    promise.registered();</span><br><span class="line"></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li><li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（<strong>主线程中完成</strong>）与ServerSocketChannel注册（NIO线程中完成）工作</li><li><strong>doBind0</strong>则负责连接的创建工作</li></ul><p><img src="https://s2.loli.net/2022/05/12/E8iAJgBLZ1KoQvG.png" alt="image-20220512093542584"></p><h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span></span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span></span><br><span class="line">    <span class="comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span></span><br><span class="line">    <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span></span><br><span class="line">    <span class="comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span></span><br><span class="line">    <span class="comment">//    added to the event loop&#x27;s task queue for later execution.</span></span><br><span class="line">    <span class="comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span></span><br><span class="line">    <span class="comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span></span><br><span class="line">    <span class="comment">//         because register(), bind(), and connect() are all bound to the same thread.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过反射初始化NioServerSocketChannel</span></span><br><span class="line">    channel = channelFactory.newChannel();</span><br><span class="line">    init(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newChannel方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射调用NioServerSocketChannel的构造方法</span></span><br><span class="line">        <span class="comment">// 创建NioServerSocketChannel对象</span></span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioServerSocketChannel构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建了ServerSocketChannel实例</span></span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newSocket方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ServerSocketChannel.open方法：</span></span><br><span class="line">        <span class="comment">// SelectorProvider.provider().openServerSocketChannel()</span></span><br><span class="line">    <span class="comment">// 所以此处相当于ServerSocketChannel.open()</span></span><br><span class="line">        <span class="comment">// 创建了ServerSocketChannel实例</span></span><br><span class="line">    <span class="keyword">return</span> provider.openServerSocketChannel();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Failed to open a server socket.&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>init方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NioSocketChannl的Pipeline    </span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向Pipeline中添加了一个handler，该handler等待被调用</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// register之后才调用该方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建handler并加入到pipeline中</span></span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 添加新的handler，在发生Accept事件后建立连接</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>init主要完成了以下三个操作</strong></p><ul><li><p>创建NioServerSocketChannel</p></li><li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p></li><li><p>由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initChannel</span><br></pre></td></tr></table></figure><p>方法向NioServerSocketChannel中添加了两个handler，</p><p>添加操作在register之后被执行</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accepet事件后建立连接</li></ul></li></ul><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p><p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p><p><strong>promise.channel().unsafe().register(this, promise)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 获取EventLoop</span><br><span class="line">    AbstractChannel.this.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">   // 此处完成了由 主线程 到 NIO线程 的切换</span><br><span class="line">    // eventLoop.inEventLoop()用于判断当前线程是否为NIO线程</span><br><span class="line">    if (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 向NIO线程中添加任务</span><br><span class="line">            eventLoop.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    // 该方法中会执行doRegister</span><br><span class="line">                    // 执行真正的注册操作</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register0方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void register0(ChannelPromise promise) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">       ...</span><br><span class="line">            </span><br><span class="line">        // 执行真正的注册操作</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = false;</span><br><span class="line">        registered = true;</span><br><span class="line"></span><br><span class="line">        // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br><span class="line">        // user may already fire events through the pipeline in the ChannelFutureListener.</span><br><span class="line">        </span><br><span class="line">        // 调用init中的initChannel方法</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>doRegister方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doRegister() throws Exception &#123;</span><br><span class="line">    boolean selected = false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // javaChannel()即为ServerSocketChannel</span><br><span class="line">            // eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br><span class="line">            // this为NIOServerSocketChannel，作为附件</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (CancelledKeyException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调initChannel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void initChannel(final Channel ch) &#123;</span><br><span class="line">    final ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">    ChannelHandler handler = config.handler();</span><br><span class="line">    if (handler != null) &#123;</span><br><span class="line">        pipeline.addLast(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加新任务，任务负责添加handler</span><br><span class="line">    // 该handler负责发生Accepet事件后建立连接</span><br><span class="line">    ch.eventLoop().execute(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            pipeline.addLast(new ServerBootstrapAcceptor(</span><br><span class="line">                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Register主要完成了以下三个操作</p><ul><li><p>完成了主线程到NIO的<strong>线程切换</strong></p><ul><li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li><li>切换的方式为让eventLoop执行register的操作</li><li><strong>register的操作在NIO线程中完成</strong></li></ul></li><li><p><strong>调用doRegister方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// javaChannel()即为ServerSocketChannel</span><br><span class="line">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br><span class="line">// this为NIOServerSocketChannel，作为附件</span><br><span class="line">selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);Copy</span><br></pre></td></tr></table></figure><ul><li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li><li>此时还未关注事件</li><li>添加NioServerSocketChannel附件</li></ul></li><li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p><ul><li><p>initChannel方法主要创建了</p><p>两个handler</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accept事件后建立连接</li></ul></li></ul></li></ul><h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由<strong>NIO线程</strong>异步执行doBind0绑定操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// initAndRegister为异步方法，会返回ChannelFuture对象</span><br><span class="line">final ChannelFuture regFuture = initAndRegister();</span><br><span class="line">regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">        Throwable cause = future.cause();</span><br><span class="line">        if (cause != null) &#123;</span><br><span class="line">            // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br><span class="line">            // IllegalStateException once we try to access the EventLoop of the Channel.</span><br><span class="line">            promise.setFailure(cause);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Registration was successful, so set the correct executor to use.</span><br><span class="line">            // See https://github.com/netty/netty/issues/2586</span><br><span class="line">            promise.registered();</span><br><span class="line">            // 如果没有异常，则执行绑定操作</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p><p>NioServerSocketChannel.doBind方法</p><p>通过该方法，绑定了对应的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span><br><span class="line">@Override</span><br><span class="line">protected void doBind(SocketAddress localAddress) throws Exception &#123;</span><br><span class="line">    if (PlatformDependent.javaVersion() &gt;= 7) &#123;</span><br><span class="line">        // 调用ServerSocketChannel的bind方法，绑定端口</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">    invokeLater(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            pipeline.fireChannelActive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="comment">// 如果ServerSocketChannel没有关注Accept事件</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 则让其关注Accepet事件</span></span><br><span class="line">        <span class="comment">// readInterestOp 取值是 16</span></span><br><span class="line">        <span class="comment">// 在 NioServerSocketChannel 创建时初始化</span></span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p><ul><li><p>首先获取Channel所有感兴趣的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final int interestOps = selectionKey.interestOps();</span><br></pre></td></tr></table></figure></li><li><p>然后再设置其感兴趣的事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.interestOps(interestOps | readInterestOp);</span><br></pre></td></tr></table></figure></li></ul><p><strong>各个事件对应的值</strong></p><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png"><img src="https://s2.loli.net/2022/05/12/dPnCsahzUtx4lqL.png" alt="img"></a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p><ul><li>NioServerSocketChannel与ServerSocketChannel的创建</li><li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li><li>绑定了对应的端口</li><li>关注了Accept事件</li></ul><h2 id="2、NioEventLoop剖析"><a href="#2、NioEventLoop剖析" class="headerlink" title="2、NioEventLoop剖析"></a>2、NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p><ul><li><p><strong>Selector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoop</span> <span class="keyword">extends</span> <span class="title">SingleThreadEventLoop</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// selector中的selectedKeys是基于数组的</span></span><br><span class="line">    <span class="comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> Selector unwrappedSelector;</span><br><span class="line">    <span class="keyword">private</span> SelectedSelectionKeySet selectedKeys;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Thread与TaskQueue</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThreadEventExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractScheduledEventExecutor</span> <span class="keyword">implements</span> <span class="title">OrderedEventExecutor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Runnable&gt; taskQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">           </span><br><span class="line">        <span class="comment">// 初始化selector，初始化过程在openSelector中</span></span><br><span class="line">        <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">        <span class="keyword">this</span>.selector = selectorTuple.selector;</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 此处等同于 Selector.open()方法</span></span><br><span class="line">        <span class="comment">// 创建了unwrappedSelector对象</span></span><br><span class="line">        unwrappedSelector = provider.openSelector();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;failed to open a new selector&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unwrappedSelector = provider.openSelector();</span><br></pre></td></tr></table></figure><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorTuple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">    <span class="keyword">final</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    SelectorTuple(Selector unwrappedSelector) &#123;</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = unwrappedSelector;</span><br><span class="line">        <span class="keyword">this</span>.selector = unwrappedSelector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一般调用的是这个构造方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;</span><br><span class="line">        <span class="keyword">this</span>.unwrappedSelector = unwrappedSelector;</span><br><span class="line">        <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li>selector中的SelectedKeys是<strong>基于数组</strong>的</li><li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        unwrappedSelector = provider.openSelector();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;failed to open a new selector&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得基于数组的selectedKeySet实现</span></span><br><span class="line">    <span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Object maybeException = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span></span><br><span class="line">                Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">&quot;selectedKeys&quot;</span>);</span><br><span class="line">                Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">&quot;publicSelectedKeys&quot;</span>);</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 暴力反射，修改私有属性</span></span><br><span class="line">                Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line">                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 替换为基于数组的selectedKeys实现</span></span><br><span class="line">                selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    selectedKeys = selectedKeySet;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用构造函数，创建unwrappedSelector与selector</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector,</span><br><span class="line">                             <span class="keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p><ul><li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得基于数组的selectedKeySet实现</span></span><br><span class="line"><span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"></span><br><span class="line">SelectedSelectionKeySet() &#123;</span><br><span class="line">keys = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p></li><li><p><strong>通过Selector的构造方法</strong>获得selector</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)Copy</span><br></pre></td></tr></table></figure></li><li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用构造函数，创建unwrappedSelector与selector</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector, <span class="keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</span><br></pre></td></tr></table></figure></li></ul><h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNioEventLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EventLoop eventLoop = <span class="keyword">new</span> NioEventLoopGroup().next();</span><br><span class="line">        <span class="comment">// 使用NioEventLoop执行任务</span></span><br><span class="line">        eventLoop.execute(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>execute</code>执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测传入的任务是否为空，为空会抛出NullPointerException</span></span><br><span class="line">    ObjectUtil.checkNotNull(task, <span class="string">&quot;task&quot;</span>);</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="comment">// 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true</span></span><br><span class="line">    execute(task, !(task <span class="keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入上述代码的<code>execute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前线程是否为NIO线程</span></span><br><span class="line">    <span class="comment">// 判断方法为 return thread == this.thread;</span></span><br><span class="line">    <span class="comment">// this.thread即为NIO线程，首次执行任务时，其为null</span></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向任务队列taskQueue中添加任务</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前线程不是NIO线程，则进入if语句</span></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// 启动NIO线程的核心方法</span></span><br><span class="line">        startThread();</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>startThread</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查看NIO线程状态是否为未启动</span></span><br><span class="line">    <span class="comment">// 该if代码块只会执行一次</span></span><br><span class="line">    <span class="comment">// state一开始的值就是ST_NOT_STARTED</span></span><br><span class="line">    <span class="comment">// private volatile int state = ST_NOT_STARTED;</span></span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="comment">// 通过原子属性更新器将状态更新为启动（ST_STARTED）</span></span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行启动线程</span></span><br><span class="line">                doStartThread();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                    STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_STARTED, ST_NOT_STARTED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 创建NIO线程并执行任务</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// thread即为NIO线程</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行内部run方法</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 死循环，不断地从任务队列中获取各种任务来执行</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 执行各种任务</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> strategy;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line">                <span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                    <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    <span class="keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();</span><br><span class="line">                    <span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">                        curDeadlineNanos = NONE; <span class="comment">// nothing on the calendar</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">                            strategy = select(curDeadlineNanos);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// This update is just to help block unnecessary selector wakeups</span></span><br><span class="line">                        <span class="comment">// so use of lazySet is ok (no race condition)</span></span><br><span class="line">                        nextWakeupNanos.lazySet(AWAKE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 死循环，不断地从任务队列中获取各种任务来执行</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">// 执行各种任务</span></span><br><span class="line">   ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p><p>run方法中有SELECT分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line"><span class="keyword">long</span> curDeadlineNanos = nextScheduledTaskDeadlineNanos();</span><br><span class="line"><span class="keyword">if</span> (curDeadlineNanos == -<span class="number">1L</span>) &#123;</span><br><span class="line">        curDeadlineNanos = NONE; <span class="comment">// nothing on the calendar</span></span><br><span class="line">    &#125;</span><br><span class="line">nextWakeupNanos.set(curDeadlineNanos);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasTasks()) &#123;</span><br><span class="line">            <span class="comment">// 执行select方法</span></span><br><span class="line">            strategy = select(curDeadlineNanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> deadlineNanos)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有指定阻塞事件，就调用select()</span></span><br><span class="line">    <span class="keyword">if</span> (deadlineNanos == NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> selector.select();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞</span></span><br><span class="line">    <span class="comment">// Timeout will only be 0 if deadline is within 5 microsecs</span></span><br><span class="line">    <span class="keyword">long</span> timeoutMillis = deadlineToDelayNanos(deadlineNanos + <span class="number">995000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">    <span class="keyword">return</span> timeoutMillis &lt;= <span class="number">0</span> ? selector.selectNow() : selector.select(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要注意的是，<strong><code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程</strong></p><p>唤醒是通过execute最后的if代码块来完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span></span><br><span class="line"><span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;</span><br><span class="line">    wakeup(inEventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒</span></span><br><span class="line">    <span class="comment">// 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功</span></span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) &#123;</span><br><span class="line">        <span class="comment">// 唤醒被selector.select方法阻塞的NIO线程</span></span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唤醒时需要进行两个判断</p><ul><li><p>判断提交任务的</p><p>是否为NIO线程</p><ul><li>若是其他线程，才能唤醒NIO线程</li><li>若是NIO线程自己，则不能唤醒</li></ul></li><li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p></li></ul><h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());</span><br><span class="line"><span class="keyword">switch</span> (strategy) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strategy的值由<code>calculateStrategy</code>方法确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// selectSupplier.get() 底层是 selector.selectNow();</span></span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p><ul><li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p><ul><li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IntSupplier selectNowSupplier = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NioEventLoop.<span class="keyword">this</span>.selectNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.selector.selectNow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>若没有任务，就会进入SELECT分支</p></li></ul><p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p><h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 可能发生空轮询，无法阻塞NIO线程</span></span><br><span class="line">        strategy = select(curDeadlineNanos);  </span><br><span class="line">        ...     </span><br><span class="line">    </span><br><span class="line">     <span class="keyword">if</span>(...) &#123;</span><br><span class="line">...</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;</span><br><span class="line">            <span class="comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span></span><br><span class="line">            <span class="comment">// 并将selectCnt重置为0</span></span><br><span class="line">            selectCnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">    <span class="comment">// The selector returned prematurely many times in a row.</span></span><br><span class="line">    <span class="comment">// Rebuild the selector to work around the problem.</span></span><br><span class="line">    logger.warn(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,selectCnt, selector);</span><br><span class="line">    <span class="comment">// 重建selector，将原selector的配置信息传给新selector</span></span><br><span class="line">    <span class="comment">// 再用新selector覆盖旧selector</span></span><br><span class="line">    rebuildSelector();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p><h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p><p><strong>NioEventLoop.run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理IO事件时间比例，默认为50%</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果IO事件时间比例设置为100%</span></span><br><span class="line"><span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果需要去处理IO事件</span></span><br><span class="line">        <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先处理IO事件</span></span><br><span class="line">            processSelectedKeys();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">        <span class="comment">// 剩下的时间都去处理普通任务和定时任务</span></span><br><span class="line">        ranTasks = runAllTasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strategy &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果需要去处理IO事件</span></span><br><span class="line">    <span class="comment">// 记录处理IO事件前的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 去处理IO事件</span></span><br><span class="line">        processSelectedKeys();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">        <span class="comment">// ioTime为处理IO事件耗费的事件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">        <span class="comment">// 计算出处理其他任务的事件</span></span><br><span class="line">        <span class="comment">// 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行</span></span><br><span class="line">        ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有IO事件需要处理</span></span><br><span class="line">    <span class="comment">// This will run the minimum number of tasks</span></span><br><span class="line">    <span class="comment">// 直接处理普通和定时任务</span></span><br><span class="line">    ranTasks = runAllTasks(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p><ul><li><p>判断ioRatio是否为100</p><ul><li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p><ul><li>若需要处理IO事件，则先处理IO事件</li></ul></li><li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有指定执行任务的时间</span></span><br><span class="line">ranTasks = runAllTasks();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>若ioRatio不为100</p><ul><li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p></li><li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如ioTime为10s，ioRatio为50</span></span><br><span class="line"><span class="comment">// 那么通过 10*(100-50)/50=10 计算出其他任务可用的时间为 10s</span></span><br><span class="line"><span class="comment">// 处理IO事件占用的事件总比例为50%</span></span><br><span class="line">ranTasks = runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br></pre></td></tr></table></figure></li><li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p></li></ul></li><li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行最少数量的任务</span></span><br><span class="line">ranTasks = runAllTasks(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果selectedKeys是基于数组的</span></span><br><span class="line">    <span class="comment">// 一般情况下都走这个分支</span></span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理各种IO事件</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processSelectedKeysOptimized方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="comment">// 拿到SelectionKeyec</span></span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        <span class="comment">// null out entry in the array to allow to have it GC&#x27;ed once the Channel close</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/2363</span></span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span></span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            <span class="comment">// 处理事件，传入附件NioServerSocketChannel</span></span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            <span class="comment">// null out entries in the array to allow to have it GC&#x27;ed once the Channel close</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/2363</span></span><br><span class="line">            selectedKeys.reset(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            selectAgain();</span><br><span class="line">            i = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final SelectionKey k = selectedKeys.keys[i];Copy</span><br></pre></td></tr></table></figure><p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br><span class="line">final Object a = k.attachment();Copy</span><br></pre></td></tr></table></figure><p>如果附件继承自AbstractNioChannel，则会调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理事件，传入附件NioServerSocketChannel</span></span><br><span class="line">processSelectedKey(k, (AbstractNioChannel) a);</span><br></pre></td></tr></table></figure><p>去处理各个事件</p><p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p><p>获取SelectionKey的事件，然后进行相应处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop = ch.eventLoop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">            <span class="comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span></span><br><span class="line">            <span class="comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span></span><br><span class="line">            <span class="comment">// to close ch.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span></span><br><span class="line">        <span class="comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span></span><br><span class="line">        <span class="comment">// still healthy and should not be closed.</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/5125</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// close the channel if the key is not valid anymore</span></span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span></span><br><span class="line">        <span class="comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span></span><br><span class="line">            <span class="comment">// See https://github.com/netty/netty/issues/924</span></span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span></span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line">        <span class="comment">// to a spin loop</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、Accept剖析"><a href="#3、Accept剖析" class="headerlink" title="3、Accept剖析"></a>3、Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p><ul><li>selector.select()阻塞线程，直到事件发生</li><li>遍历selectionKeys</li><li>获取一个key，判断事件类型是否为Accept</li></ul><hr><ul><li>创建SocketChannel，设置为非阻塞</li><li>将SocketChannel注册到selector中</li><li>关注selectionKeys的read事件</li></ul><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞直到事件发生</span></span><br><span class="line">selector.select();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectionKeys().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;    </span><br><span class="line">    <span class="comment">// 拿到一个事件</span></span><br><span class="line">    SelectionKey key = iter.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果是 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行accept，获得SocketChannel</span></span><br><span class="line">        SocketChannel channel = serverSocketChannel.accept();</span><br><span class="line">        channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将SocketChannel注册到selector中，并关注read事件</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p><h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">unsafe.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NioMessageUnsafe.read</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// doReadMessages中执行了accept获得了SocketChannel</span></span><br><span class="line">                <span class="comment">// 并创建NioSocketChannel作为消息放入readBuf</span></span><br><span class="line">                <span class="comment">// readBuf是一个ArrayList用来缓存消息</span></span><br><span class="line">                <span class="comment">// private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();</span></span><br><span class="line">                <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                </span><br><span class="line">                ...</span><br><span class="line">                </span><br><span class="line"><span class="comment">// localRead值为1，就一条消息，即接收一个客户端连接</span></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 触发read事件，让pipeline上的handler处理</span></span><br><span class="line">            <span class="comment">// ServerBootstrapAcceptor.channelRead</span></span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NioSocketChannel.doReadMessages</code>方法</p><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 处理accpet事件，获得SocketChannel</span></span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建了NioSocketChannel，作为消息放在了readBuf中</span></span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ServerBootstrapAcceptor.<span class="function">channelRead</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这时的msg是NioSocketChannel</span></span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NioSocketChannel添加childHandler，即初始化器</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置选项</span></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这行代码完成的是nio boss -&gt; nio worker线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 真正的注册操作</span></span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line">AbstractChannel.AbstractUnsafe.<span class="function">register0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 该方法将SocketChannel注册到Selector中</span></span><br><span class="line">        doRegister();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span></span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                <span class="comment">// 触发pipeline上active事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将Selector注册到Selector中</span></span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line">HeadContext.<span class="function">channelActive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line"><span class="comment">// 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 这时候 interestOps是0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关注read事件</span></span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、Read剖析"><a href="#4、Read剖析" class="headerlink" title="4、Read剖析"></a>4、Read剖析</h2><p>read事件的处理也是在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">unsafe.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得Channel的配置</span></span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line"><span class="comment">// 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）</span></span><br><span class="line"><span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="comment">// 用来分配 byteBuf，确定单次读取大小</span></span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 创建ByteBuf</span></span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            <span class="comment">// 读取内容，放入ByteBUf中</span></span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 触发read 事件，让pipeline上的handler处理</span></span><br><span class="line">            <span class="comment">// 这时是处理NioSocketChannel上的handler</span></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 是否要继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        <span class="comment">// 触发 read complete事件</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Check if there is a readPending which was not processed yet.</span></span><br><span class="line">         <span class="comment">// This could be for two reasons:</span></span><br><span class="line">         <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span></span><br><span class="line">         <span class="comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// See https://github.com/netty/netty/issues/2254</span></span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy</span><br><span class="line">DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">           <span class="comment">// 一般为true</span></span><br><span class="line">           config.isAutoRead() &amp;&amp;</span><br><span class="line">           <span class="comment">// respectMaybeMoreData默认为true</span></span><br><span class="line">           <span class="comment">// maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true</span></span><br><span class="line">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">           <span class="comment">// 小于最大次数，maxMessagePerRead默认16</span></span><br><span class="line">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">           <span class="comment">// 实际读到了数据</span></span><br><span class="line">           totalBytesRead &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="微服务" scheme="http://ppnostalgia.github.io./categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
    <category term="笔记" scheme="http://ppnostalgia.github.io./tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Netty" scheme="http://ppnostalgia.github.io./tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Kafka与Zookeeper</title>
    <link href="http://ppnostalgia.github.io./ce79866c.html"/>
    <id>http://ppnostalgia.github.io./ce79866c.html</id>
    <published>2022-03-28T02:31:34.000Z</published>
    <updated>2022-06-20T12:56:04.578Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://s2.loli.net/2022/06/20/Oam9RKkLWAgYsEn.webp" alt="img"></p><p><img src="https://s2.loli.net/2022/06/20/FKrXfHaUndkwC73.webp" alt="img"></p><h1 id="一、Zookeeper对于Kafka的作用"><a href="#一、Zookeeper对于Kafka的作用" class="headerlink" title="一、Zookeeper对于Kafka的作用"></a>一、Zookeeper对于Kafka的作用</h1><h2 id="1-注册中心"><a href="#1-注册中心" class="headerlink" title="1. 注册中心"></a>1. 注册中心</h2><h3 id="1-1-broker注册"><a href="#1-1-broker注册" class="headerlink" title="1.1 broker注册"></a>1.1 broker注册</h3><p>​    broker分布式部署，需要一个注册中心统一管理，Zookeeper使用专门节点保存Broker服务列表，即/broker/ids</p><p>​    broker在启动时，向Zookeeper发送注册请求，Zookeeper会在/brokers/ids下创建这个broker节点，如/brokers/ids/[0…N]，并保存broker的IP地址和端口。</p><p>​    这个节点临时节点，一旦broker宕机，这个临时节点会被自动删除。</p><h3 id="1-2-Topic注册"><a href="#1-2-Topic注册" class="headerlink" title="1.2 Topic注册"></a>1.2 Topic注册</h3><p>Zookeeper同时也会为topic分配一个单独节点，即/brokers/topics/[topic_name]</p><p>一个topic的消息会被保存到多个partition，这些partition跟broker的对应关系也需要保存到Zookeeper。</p><p>partition是多副本保存的，上图中红色partition是leader副本。当leader副本所在的broker发生故障时，partition需要重新<strong>选举leader</strong>，这个需要由<strong>Zookeeper</strong>主导完成。</p><p>broker启动后，会把自己的Broker ID注册到到对应topic节点的分区列表中。</p><p>我们查看一个topic是xxx，分区编号是1的信息，命令如下：</p><p>[root@master] get /brokers/topics/xxx/partitions/1/state {“controller_epoch”:15,”leader”:11,”version”:1,”leader_epoch”:2,”isr”:[11,12,13]} </p><p>当broker退出后，Zookeeper会更新其对应topic的分区列表。</p><h3 id="1-3-Consumer注册"><a href="#1-3-Consumer注册" class="headerlink" title="1.3 Consumer注册"></a>1.3 Consumer注册</h3><p>消费者组也会向Zookeeper进行注册，Zookeeper会为其分配节点来保存相关数据，节点路径为/consumers/{group_id}，有3个子节点，如下图:</p><p><img src="https://s2.loli.net/2022/06/20/rZnG2vNxADCeOl4.webp" alt="img"></p><p>这样Zookeeper可以记录分区跟消费者的关系，以及分区的offset。[3]</p><h2 id="二、-负载均衡"><a href="#二、-负载均衡" class="headerlink" title="二、 负载均衡"></a>二、 负载均衡</h2><p>​    broker向Zookeeper进行注册后，生产者根据broker节点来感知broker服务列表变化，这样可以实现动态负载均衡。</p><p>​    consumer group中的消费者，可以根据topic节点信息来拉取特定分区的消息,实现负载均衡。</p><p>​    实际上，Kafka在Zookeeper中保存的元数据非常多，看下面这张图：</p><p><img src="https://s2.loli.net/2022/06/20/eSUbTvt6xpamEAZ.webp" alt="img"></p><p>随着broker、topic和partition增多，保存的数据量会越来越大。</p><h1 id="Kafka与Zookeeper之间的交互"><a href="#Kafka与Zookeeper之间的交互" class="headerlink" title="Kafka与Zookeeper之间的交互"></a>Kafka与Zookeeper之间的交互</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Kafka" scheme="http://ppnostalgia.github.io./categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://ppnostalgia.github.io./tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>项目常见问题汇总</title>
    <link href="http://ppnostalgia.github.io./7a8238d6.html"/>
    <id>http://ppnostalgia.github.io./7a8238d6.html</id>
    <published>2022-03-20T09:39:34.000Z</published>
    <updated>2022-11-04T06:23:39.626Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="论坛项目问题"><a href="#论坛项目问题" class="headerlink" title="论坛项目问题"></a>论坛项目问题</h1><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="自增主键问题"><a href="#自增主键问题" class="headerlink" title="自增主键问题"></a>自增主键问题</h3><p>mybatis自增主键，主键回传，返回id为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userMapper.insertUser(user);</span><br><span class="line"><span class="keyword">int</span> userId = user.getId();<span class="comment">//为空</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.ps.community.entity.User&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into user (<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;insertFields&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>)</span><br><span class="line">    values(#&#123;username&#125;, #&#123;password&#125;, #&#123;salt&#125;, #&#123;email&#125;, #&#123;type&#125;, #&#123;status&#125;, #&#123;activationCode&#125;, #&#123;headerUrl&#125;, #&#123;createTime&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​            useGeneratedKeys、keyProperty两者缺一不可</p><h3 id="字段不一致问题"><a href="#字段不一致问题" class="headerlink" title="字段不一致问题"></a>字段不一致问题</h3><p>数据库字段与实体类型名字不一致时设置resultMap, 并且设置select语句返回类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.ps.community.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;salt&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;salt&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;type&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;type&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;status&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span> <span class="attr">property</span>=<span class="string">&quot;status&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;activation_code&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;activationCode&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;header_url&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span> <span class="attr">property</span>=<span class="string">&quot;headerUrl&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;create_time&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;TIMESTAMP&quot;</span> <span class="attr">property</span>=<span class="string">&quot;createTime&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="POJO对象属性问题"><a href="#POJO对象属性问题" class="headerlink" title="POJO对象属性问题"></a>POJO对象属性问题</h3><p>阿里Java代码规范里提到一条：所有POJO类型属性必须使用包装数据类型，尤其是int</p><p>原因：</p><ol><li><p>Java泛型是不支持基础类型的，如果没有这些包装类，你的泛型类将不能用在基础数据上，比如你的泛型容器类不能存放int数字</p><p><img src="https://s2.loli.net/2022/03/23/9vLqNIMRnJDEBFO.png" alt="img"></p></li><li><p>和对象一样，为基本类型提供一些较为复杂但也非常常用的方法。比如万物皆有的toString() 方法，将整数转字符串，以及一些整数特有的方法，如 toHexString()，转为十六进制字符串显示。</p><p><img src="https://s2.loli.net/2022/03/23/9vLqNIMRnJDEBFO.png" alt=""></p></li><li><p>对象是可以为 null 的，而基本类型不可以，必要的时候需要使用包装类型避免产生歧义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a; <span class="comment">// 即使不给字面量，也会有默认值0 </span></span><br><span class="line">Integer b; <span class="comment">// 因为没有实例化对象，所以b为null</span></span><br></pre></td></tr></table></figure><p>如果返回给字段值为null，int类型会报错，Integer不会报错。因为int类型声明的是变量，而null是对象所以会报错。Integer是包装类，包装类符合对象的特征并提供了一些必要的属性和方法。</p></li></ol><h4 id="实体类数据类型选择策略"><a href="#实体类数据类型选择策略" class="headerlink" title="实体类数据类型选择策略"></a>实体类数据类型选择策略</h4><ol><li>当某个值一定不为null时，可以使用基本数据类型，例如：<strong>状态标志位，分类标志位</strong>，只要有这条数据就这个字段值就一定有值，并且需要传给前端。<br>因为如果Entity类中使用了基础数据类型private int number;但是数据库为null的时候，如果返回了一个null，接口会报500，Null value</li><li>JpaBuilder的Specification底层有一个Root泛型接口，但凡涉及到泛型，包装类的性能绝对是好过基本数据类型，即使JDK会做自动拆箱和装箱（当我们变量声明为对象类型而赋值为基本数据类型时，Java编译器会对我们的基本数据类型进行装箱，而我们的变量声明为基本类型赋值为对象类型时，编译器又会对我们的对象类型进行拆箱处理。），也绝对不可能为null。<br>因此，在后续的扩展中，如果专门对null值有处理或者约定的话，基本数据类型都是无法做到的。<br>MybatisPlus的QueryWrapper也有这个问题，而且QueryWrapper对null的封装更加完善，不能传null会带来很多问题。</li></ol><p>综上所述，如果没有要求，优先选择包装类。<br>要求数据永远不为空时，有两种解决方案<br>（1）可以在建表时就添加约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `onetable` (</span><br><span class="line">  `id` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;主键id&#x27;,</span><br><span class="line">  `node` bigint(20) DEFAULT 0 not null COMMENT &#x27;车辆品牌&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure><p>（2）Entity类直接赋初始值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Entity</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> Integer number = <span class="number">0</span>；</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Web开发" scheme="http://ppnostalgia.github.io./categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Springboot" scheme="http://ppnostalgia.github.io./tags/Springboot/"/>
    
    <category term="Mybatis" scheme="http://ppnostalgia.github.io./tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>优化网站性能-缓存</title>
    <link href="http://ppnostalgia.github.io./e4d5605b.html"/>
    <id>http://ppnostalgia.github.io./e4d5605b.html</id>
    <published>2022-03-18T02:08:34.000Z</published>
    <updated>2022-11-04T06:23:56.169Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化网站性能"><a href="#优化网站性能" class="headerlink" title="优化网站性能"></a>优化网站性能</h1><p><img src="https://s2.loli.net/2022/03/18/El8GI5HDsqUjCrP.png" alt="image-20220318101246362"></p><h2 id="一级缓存（本地缓存）"><a href="#一级缓存（本地缓存）" class="headerlink" title="一级缓存（本地缓存）"></a>一级缓存（本地缓存）</h2><p>若使用本地缓存缓存用户息息相关数据，如登录凭证等，请求1访问到服务器1，服务器1向本地缓存查找信息，若没有从DB中查询并更新缓存。之后若请求2访问服务器2，服务器2中本地缓存若没有登录凭证则认为请求2没有登录，不会去访问db结束线程。因此<strong>本地缓存不能用来缓存用户息息相关的数据</strong>。</p><p>本地缓存因为没有网络开销，所以速度更快。</p><p><img src="https://s2.loli.net/2022/03/18/KLhtsIiYBO8EQd6.png" alt="image-20220318101757308"></p><h2 id="二级缓存（Redis缓存）"><a href="#二级缓存（Redis缓存）" class="headerlink" title="二级缓存（Redis缓存）"></a>二级缓存（Redis缓存）</h2><p>Redis可以<strong>跨服务器</strong>，因此用来存放用户数据</p><p><img src="https://s2.loli.net/2022/03/18/mejNQzSKfkRGXAT.png" alt="image-20220318102408757"></p><h2 id="查询数据过程"><a href="#查询数据过程" class="headerlink" title="查询数据过程"></a>查询数据过程</h2><p>以两层缓存为例</p><p><img src="https://s2.loli.net/2022/03/18/CspcrBD8UGORvo1.png" alt="image-20220318102856192"></p><p>查询：本地缓存-&gt;Redis缓存—&gt;DB  数据同步：DB-&gt;Redis—&gt;本地</p><ul><li>需要存放到缓存的数据：更新频率较低的数据</li></ul><h1 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h1><h2 id="缓存热帖列表"><a href="#缓存热帖列表" class="headerlink" title="缓存热帖列表"></a>缓存热帖列表</h2><p>不推荐Springboot整合缓存管理包，其会对所有缓存进行统一配置</p><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>设置参数（缓存空间、淘汰时间等）</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">caffine:</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="number">15</span></span><br><span class="line">    <span class="attr">expire-seconds:</span> <span class="number">180</span></span><br></pre></td></tr></table></figure><ol><li>业务层</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Caffine核心接口：Cache, LoadingCache, AsyncLoadingCache</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照key缓存value</span></span><br><span class="line">    <span class="comment">//帖子列表缓存</span></span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;String, List&lt;DiscussPost&gt;&gt; postListCache;</span><br><span class="line">    <span class="comment">//帖子总数缓存</span></span><br><span class="line">    <span class="keyword">private</span> LoadingCache&lt;Integer, Integer&gt; postRowsCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不需要初始化多次，在首次启动初始化一次就够了</span></span><br><span class="line">    <span class="comment">//被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化帖子列表缓存</span></span><br><span class="line">        postListCache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(maxSize)</span><br><span class="line">                .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">                .build(<span class="keyword">new</span> CacheLoader&lt;String, List&lt;DiscussPost&gt;&gt;() &#123;</span><br><span class="line">                    <span class="comment">//缓存中没有数据时查询数据库得到数据的办法</span></span><br><span class="line">                    <span class="comment">//当你使用Caffeine的API构建缓存时，在load方法内所返回的数据，会被自动装在到***里。</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">List&lt;DiscussPost&gt; <span class="title">load</span><span class="params">(<span class="meta">@NonNull</span> String key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(key==<span class="keyword">null</span> || key.length()==<span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;参数错误！&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        String[] params = key.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(params==<span class="keyword">null</span> || params.length!=<span class="number">2</span>)&#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;参数错误！&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> offset = Integer.valueOf(params[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">int</span> limit = Integer.valueOf(params[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//二级缓存:Redis——&gt;mysql</span></span><br><span class="line"></span><br><span class="line">                        logger.debug(<span class="string">&quot;load post list from DB.&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> discussPostMapper.selectDiscussPosts(<span class="number">0</span>, offset, limit, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">//初始化帖子总数缓存</span></span><br><span class="line">        postRowsCache = Caffeine.newBuilder()</span><br><span class="line">                .maximumSize(maxSize)</span><br><span class="line">                .expireAfterWrite(expireSeconds, TimeUnit.SECONDS)</span><br><span class="line">                .build(<span class="keyword">new</span> CacheLoader&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Integer <span class="title">load</span><span class="params">(<span class="meta">@NonNull</span> Integer key)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        logger.debug(<span class="string">&quot;load post list from DB.&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> discussPostMapper.selectDiscussPostRows(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DiscussPost&gt; <span class="title">findDiscussPosts</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> offset, <span class="keyword">int</span> limit, <span class="keyword">int</span> orderMode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userId==<span class="number">0</span>&amp;&amp;orderMode==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> postListCache.get(offset + <span class="string">&quot;:&quot;</span> + limit);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">&quot;load post list from DB.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPosts(userId, offset, limit, orderMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDiscussPostRows</span><span class="params">(<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(userId==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> postRowsCache.get(userId);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">&quot;load post rows from DB.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> discussPostMapper.selectDiscussPostRows(userId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>压力测试查看吞吐量对比</li></ol><p>​        测试工具<a href="https://jmeter.apache.org/download_jmeter.cgi">jmeter</a></p><p>​        点击jemeter.bat</p><p>​        <img src="https://s2.loli.net/2022/03/18/3i7ZrumsUnfDpQB.png" alt="image-20220318154933463">    </p><p><img src="https://s2.loli.net/2022/03/18/iRYxsO3DGwJZFmV.png" alt="image-20220318155013478"></p><p><img src="https://s2.loli.net/2022/03/18/tw7IFE1asB2NdDg.png" alt="image-20220318155030590"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Web开发" scheme="http://ppnostalgia.github.io./categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Redis" scheme="http://ppnostalgia.github.io./tags/Redis/"/>
    
    <category term="缓存" scheme="http://ppnostalgia.github.io./tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>任务执行和调度</title>
    <link href="http://ppnostalgia.github.io./42c48bba.html"/>
    <id>http://ppnostalgia.github.io./42c48bba.html</id>
    <published>2022-03-14T01:58:34.000Z</published>
    <updated>2022-03-27T05:36:50.301Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="任务执行和调度——Quartz"><a href="#任务执行和调度——Quartz" class="headerlink" title="任务执行和调度——Quartz"></a>任务执行和调度——Quartz</h1><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="https://s2.loli.net/2022/03/14/aw4OgErmQ5dBqiz.png" alt="image-20220314100157290"></p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池是一种池化的技术，类似的还有数据库连接池、HTTP 连接池等等。<br>池化的思想主要是为了减少每次获取和结束资源的消耗，提高对资源的利用率。<br>比如在一些偏远地区打水不方便的，大家会每段时间把水打过来存在池子里，这样平时用的时候就直接来取就好了。<br>线程池同理，正是因为每次创建、销毁线程需要占用太多系统资源，所以我们建这么一个池子来统一管理线程。用的时候从池子里拿，不用了就放回来，也不用你销毁，是不是方便了很多？</p><h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><p>用线程池来统一管理线程就能够很好的解决这种<strong>资源管理问题</strong>。</p><ol><li>降低资源消耗：通过重复利用现有的线程来执行任务，避免多次创建和销毁线程。</li><li>提高相应速度：因为省去了创建线程这个步骤，所以在拿到任务时，可以立刻开始执行。</li><li>提供附加功能：线程池的可拓展性使得我们可以自己加入新的功能，比如说定时、延时来执行某些线程。</li></ol><p>Java 中的线程池是由 <code>juc</code> 即 <code>java.util.concurrent</code> 包来实现的，最主要的就是 <code>ThreadPoolExecutor</code> 这个类。</p><p><img src="https://s2.loli.net/2022/03/14/DcWiV4KzktTbyqG.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="SpringBoot" scheme="http://ppnostalgia.github.io./categories/SpringBoot/"/>
    
    
    <category term="Spring" scheme="http://ppnostalgia.github.io./tags/Spring/"/>
    
    <category term="多线程" scheme="http://ppnostalgia.github.io./tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="任务调度" scheme="http://ppnostalgia.github.io./tags/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>(三)Redis高级数据类型</title>
    <link href="http://ppnostalgia.github.io./f7ea9536.html"/>
    <id>http://ppnostalgia.github.io./f7ea9536.html</id>
    <published>2022-03-11T12:59:34.000Z</published>
    <updated>2022-03-27T05:36:50.305Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis高级数据类型"><a href="#Redis高级数据类型" class="headerlink" title="Redis高级数据类型"></a>Redis高级数据类型</h1><p><img src="https://s2.loli.net/2022/03/27/z8Jr2uVSsEP7BiT.png" alt="image-20220327130821187"></p><h1 id="基数计算"><a href="#基数计算" class="headerlink" title="基数计算"></a>基数计算</h1><p><strong>基数</strong>计算（cardinality counting）指的是统计一批数据中的<strong>不重复元素的个数</strong>，常见于计算独立用户数（UV）、维度的独立取值数等等。实现基数统计最直接的方法，就是采用集合（Set）这种数据结构，当一个元素从未出现过时，便在集合中增加一个元素；如果出现过，那么集合仍保持不变。<br> 在大数据的场景中，实现基数统计往往去面临以下的两个问题：</p><ul><li>如果有效的存储原始数据，以<strong>避免数据占用空间过多</strong>，这里就涉及到<strong>存储空间压缩</strong>的问题</li><li>如果能够跨不同的维度、不同的时间段实现基数计算，比如在计算日度UV的情况下，如果计算出周度、或者月度的UV</li></ul><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p><img src="https://s2.loli.net/2022/03/11/IDEQhnz2LT7w4Fi.png" alt="image-20220311210319795"></p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p>常用于签到</p><p><img src="https://s2.loli.net/2022/03/11/Un2qWEYrOsmxR7A.png" alt="image-20220311210342909"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Redis" scheme="http://ppnostalgia.github.io./categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://ppnostalgia.github.io./tags/Redis/"/>
    
  </entry>
  
</feed>
